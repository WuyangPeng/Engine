C++ 程序设计原理与实践（Programming Principles and Practice Using C++）
（第2版）

官方网站 
https://www.stroustrup.com/programming.html。

编译器：
https://www.stroustrup.com/compilers.html。

基础篇
★★★
作者：Bjarne Stroustrup
其他书籍：《C++ 语言导学》、《C++ 程序设计语言》、《C++ 语言的设计和演化》。

知识点 
1.	C++基础知识。
2.	C++11基础知识。
3.	C++基础知识练习。
4.	编写一个简单的计算器。

代码 
1.  第1版书籍代码。 
2.  第2版书籍代码。 
3.  练习代码。 

要点
1.	实用调试建议（5.9 调试）。
	（1）为代码做好注释。
	（2）使用有意义的名字。
	（3）使用一致的代码层次结构。
	（4）代码应该被分成许多小函数，每个函数表达一个逻辑功能。
	（5）避免使用复杂的程序语句。
	（6）在可能的情况下，使用标准库而不是你自己的代码。
2.	传值和传引用的基本原则（8.5.6 传值与传引用的对比）：
	（1）使用传值方式传递非常小的对象。
	（2）使用传常量引用方式传递你不需修改的大对象。
	（3）让函数返回一个值，而不是修改通过引用参数传递来的对象。
	（4）只有迫不得已时才使用传引用方式。

前言
	★ 程序设计远非遵循语法规则和阅读手册那么简单，而在于理解基本思想、原理和技术，并进行大量实践。
	★ 程序设计是这样一门艺术，它将问题求解方案描述成计算机可以执行的形式。
	致学生
	致教师
	ISO标准C++
	资源
	致谢
引言
	★ 当实际地形与地图不符时，相信实际地形。
	讲授和学习本书的方法
		★  思想能指导你求解实际问题——可以帮助你知道在什么情况下问题求解方案是好的、合理的。
		★	要对所有互联网资源保持足够的怀疑，直至你有足够的理由相信它们。
		一般方法
			★	学习回答好的问题是学习如何像一个程序员那样思考所必的。
				只回答那些简单的、浅显的问题会使你感觉良好，但无助于你成长为一名程序员。
		简单练习和习题等
		进阶学习
		本书内容顺序和安排
			★	主要是具体优先和深度优先方法，并对重点概念和技术加以强调。
		程序设计和程序设计语言
		可移植性
		提示标记
		附言 
	程序设计和计算机科学
	创造性和问题求解
	反馈方法
	参考文献
作者简介
第1章 计算机、人与程序设计
	1.1 简介
	1.2 软件
	1.3 人
	1.4 计算机科学
	1.5 计算机已远处不在
		1.5.1 有屏幕和无屏幕
		1.5.2 船舶
		1.5.3 电信
		1.5.4 医疗
		1.5.5 信息领域
		1.5.6 一种垂直的视角
		1.5.7 与C++程序设计有何联系
	1.6 程序员的理解境界
	思考题
	术语
	习题
	附言
第2章 Hello,World!
	2.1 程序
	2.2 经典的第一个程序
	2.3 编译
	2.4 链接
	2.5 编程环境
	简单练习
	思考题
	术语
	习题
	附言
第3章 对象、类型和值
	3.1 输入
	3.2 变量
	3.3 输入和类型
	3.4 运算和运算符
	3.5 赋值和初始化
		3.5.1 实例：检测重复单词
	3.6 复合赋值运算符
		3.6.1 实例：重复单词计数
	3.7 命名
	3.8 类型和对象
	3.9 类型安全
		3.9.1 安全转换
		3.9.2 不安全转换
	简单练习
	思考题
	术语
	习题
	附言
第4章 计算
	4.1 简介
	4.2 目标和工具
	4.3 表达式
		4.3.1 常量表达式
		4.3.2 运算符
		4.3.3 类型转换
	4.4 语句
		4.4.1 选择语句
			4.4.1.1 if语句
			4.4.1.2 switch语句
			4.4.1.3 switch技术
		4.4.2 循环语句
			4.4.2.1 While语句
			4.4.2.2 程序块
			4.4.2.3 for语句
	4.5 函数
		4.5.1 为什么使用函数
		4.5.2 函数声明 
	4.6 vector
		4.6.1 遍历一个vector
		4.6.2 vector空间增长
		4.6.3 一个数值计算实例
		4.6.4 一个文本实例
	4.7 语言特性
	简单练习
	思考题
	术语
	习题
	附言
第5章 错误
	5.1 简介
	5.2 错误的来源
	5.3 编译时错误
		5.3.1 语法错误
		5.3.2 类型错误
		5.3.3 警告
	5.4 链接时错误
	5.5 运行时错误
		5.5.1 调用者处理错误
		5.5.2 被调用者处理错误
		5.5.3 报告错误
	5.6 异常
		5.6.1 参数错误
		5.6.2 范围错误
		5.6.3 输入错误
		5.6.4 窄化错误
	5.7 逻辑错误
	5.8 估计
	5.9 调试
		5.9.1 实用调试建议
	5.10 前置条件和后置条件
		5.10.1 后置条件
	5.11 测试
	简单练习
	思考题
	术语
	习题
	附言
第6章 编写一个程序
	6.1 一个问题
	6.2 对问题的思考
		6.2.1 程序设计的几个阶段
		6.2.2 策略
	6.3 回到计算器问题
		6.3.1 第一步尝试
		6.3.2 单词
		6.3.3 实现单词
		6.3.4 使用单词
		6.3.5 重新开始
	6.4 文法
		6.4.1 英文文法
		6.4.2 设计一个文法
	6.5 将文法转换为程序
		6.5.1 实现文法规则
		6.5.2 表达式
			6.5.2.1 表达式：第一次尝试
			6.5.2.2 表达式：第二次尝试
			6.5.2.3 表达式：幸运的第三次
		6.5.3 项
		6.5.4 基本表达式
	6.6 试验第一个版本
	6.7 试验第二个版本
	6.8 单词流
		6.8.1 实现Token_stream
		6.8.2 读单词
		6.8.3 读数值
	6.9 程序结构
	简单练习
	思考题
	术语
	习题
	附言
第7章 完成一个程序
	7.1 简介
	7.2 输入和输出
	7.3 错误处理
	7.4 处理负数
	7.5 模运算%
	7.6 清理代码
		7.6.1 符号常量
		7.6.2 使用函数
		7.6.3 代码布局
		7.6.4 注释
	7.7 错误恢复
	7.8 变量
		7.8.1 变量和定义
		7.8.2 引入name单词
		7.8.3 预定义名字
		7.8.4 我们到达目的地了吗
	简单练习
	思考题
	术语
	习题
	附言
第8章 函数相关的技术细节
	8.1 技术细节
	8.2 声明和定义
		8.2.1 声明的类别
		8.2.2 变量和常量声明
		8.2.3 默认初始化
	8.3 头文件
	8.4 作用域
	8.5 函数调用和返回
		8.5.1 声明参数和返回类型
		8.5.2 返回一个值
		8.5.3 传值
		8.5.4 传常量引用
		8.5.5 传引用
		8.5.6 传值与传引用的对比
		8.5.7 参数检查和转换
		8.5.8 实现函数调用
		8.5.9 constexpr函数
	8.6 计算顺序
		8.6.1 表达式计算
		8.6.2 全局初始化
	8.7 名字空间
		8.7.1 using声明和using指令
	简单练习
	思考题
	术语
	习题
	附言
第9章 类相关的技术细节
	9.1 用户自定义类型
	9.2 类和成员
	9.3 接口和实现
	9.4 演化一个类
		9.4.1 结构和函数
		9.4.2 成员函数和构造函数
		9.4.3 保持细节私有性
		9.4.4 定义成员函数
		9.4.5 引用当前对象
		9.4.6 报告错误
	9.5 枚举类型
		9.5.1 “平坦”枚举
	9.6 运算符重载
	9.7 类接口
		9.7.1 参数类型
		9.7.2 拷贝
		9.7.3 默认构造函数
		9.7.4 const成员函数
		9.7.5 类成员和“辅助函数”
	9.8 Date类
	简单练习
	思考题
	术语
	习题
	附言
第10章 输入输出流
	10.1 输入和输出
	10.2 I/O流模型
	10.3 文件
	10.4 打开文件
	10.5 读写文件
	10.6 I/O错误处理
	10.7 读取单个值
		10.7.1 将程序分解为易管理的子模块
		10.7.2 将人机对话从函数中分离
	10.8 用户自定义输出运算符
	10.9 用户自定义输入运算符
	10.10 一个标准的输入循环
	10.11 读取结构化的文件
		10.11.1 在内存中的表示
		10.11.2 读取结构化的值
		10.11.3 改变表示方法
	练习
	思考题
	术语
	习题
	附言
第11章 定制输入输出
	11.1 有规律的与无规律的输入和输出
	11.2 格式化输出
		11.2.1 输出整数
		11.2.2 输入整数
		11.2.3 输出浮点数
		11.2.4 精度
		11.2.5 域
	11.3 打开和定位文件
		11.3.1 文件打开模式
		11.3.2 二进制文件
		11.3.3 在文件中定位
	11.4 字符串流
	11.5 面向行的输入
	11.6 字符分类
	11.7 使用非标准分隔符
	11.8 更多未讨论内容
	简单练习
	思考题
	术语
	习题
	附言
第12章 向量和自由空间
	12.1 简介
	12.2 vector的基本知识
	12.3 内存、地址和指针
		12.3.1 sizeof运算符
	12.4 自由空间和指针
		12.4.1 自由空间分配
		12.4.2 通过指针访问数据
		12.4.3 指针范围
		12.4.4 初始化
		12.4.5 空指针
		12.4.6 自由空间释放
	12.5 析构函数
		12.5.1 生成的析构函数
		12.5.2 析构函数和自由空间
	12.6 访问元素
	12.7 指向类对象的指针
	12.8 类型混用：void*和类型转换
	12.9 指针和引用 
		12.9.1 指针参数和引用参数
		12.9.2 指针、引用和继承
		12.9.3 实例：链表
		12.9.4 链表操作
		12.9.5 链表的使用
	12.10 this指针
		12.10.1 关于链表使用的更多讨论
	简单练习
	思考题
	术语
	习题
	附言
第13章 向量和数组
	13.1 简介
	13.2 初始化
	13.3 拷贝
		13.3.1 拷贝构造函数
		13.3.2 拷贝赋值
		13.3.3 拷贝术语
		13.3.4 移动
	13.4 必要的操作
		13.4.1 显式构造函数
		13.4.2 调试构造函数和析构函数
	13.5 访问vector元素
		13.5.1 对const向量重载运算符
	13.6 数组
		13.6.1 指向数组元素的指针
		13.6.2 指针和数组
		13.6.3 数组初始化
		13.6.4 指针问题
	13.7 实例：回文
		13.7.1 使用string实现回文
		13.7.2 使用数组实现回文
		13.7.3 使用指针实现回文
	简单练习
		数组练习
		标准库vector练习
	思考题
	术语
	习题
	附言
第14章 向量、模板和异常
	14.1 问题
	14.2 改变大小
		14.2.1 表示方式
		14.2.2 reserve和capacity
		14.2.3 resize
		14.2.4 push_back
		14.2.5 赋值
		14.2.6 到目前为止的vector类
	14.3 模板
		14.3.1 类型作为模板参数
		14.3.2 泛型编程
		14.3.3 概念
		14.3.4 容器和继承
		14.3.5 整数作为模板参数
		14.3.6 模板实参推断
		14.3.7 泛化vector
	14.4 范围检查和异常
		14.4.1 旁白：设计上的考虑
			14.4.1.1 兼容性
			14.4.1.2 效率
			14.4.1.3 约束
			14.4.1.4 检查的可选性
		14.4.2 坦白：使用宏
	14.5 资源和异常
		14.5.1 潜在的资源管理问题
		14.5.2 资源获取即初始化
		14.5.3 保证
		14.5.4 unique_ptr
		14.5.5 以移动方式返回结果
		14.5.6 vector类的RAII
	简单练习
	思考题
	术语
	习题
	附言
附录A C++语言概要
	A.1 一般内容
		A.1.1 术语
		A.1.2 程序开始和结束
		A.1.3 注释
	A.2 字面值常量
		A.2.1 整数字面值常量
		A.2.2 浮点字面值常量
		A.2.3 布尔字面值常量 
		A.2.4 字符字面值常量
		A.2.5 字符串字面值常量
		A.2.6 指针字面值常量
	A.3 标识符
		A.3.1 关键字
	A.4 作用域、内存类别和生命期
		A.4.1 作用域
		A.4.2 内存类别
		A.4.3 生命期
	A.5 表达式
		A.5.1 用户自定义运算符
		A.5.2 隐式类型转换
			A.5.2.1 提升
			A.5.2.3 用户自定义转换
		A.5.3 常量表达式
		A.5.4 sizeof
		A.5.5 逻辑表达式
		A.5.6 new和delete
		A.5.7 类型转换
	A.6 语句
	A.7 声明 
		A.7.1 定义
	A.8 内置类型
		A.8.1 指针
		A.8.2 数组
		A.8.3 引用 
	A.9 函数
		A.9.1 重载解析
		A.9.2 默认参数
		A.9.3 未指定参数
		A.9.4 连接规范 
	A.10 用户自定义类型
		A.10.1 运算符重载
	A.11 枚举
	A.12 类
		A.12.1 成员访问
			A.12.1.1 this指针
			A.12.1.2 友元函数
		A.12.2 类成员定义
		A.12.3 构造、析构和拷贝 
			A.12.3.1 析构函数
			A.12.3.2 拷贝
			A.12.3.3 移动
		A.12.4 派生类
			A.12.4 1 虚函数
			A.12.4 2 抽象类
			A.12.4 3 默认操作
		A.12.5 位域
		A.12.6 联合
	A.13 模板
		A.13.1 模板参数
		A.13.2 模板实例化
		A.13.3 模板成员类型
	A.14 异常
	A.15 名字空间
	A.16 别名
	A.17 预处理指令
		A.17.1 #include 
		A.17.2 #define
附录B Visual Studio简要入门教程
	B.1 让程序运行起来
	B.2 安装Visual Studio
	B.3 创建、运行一个程序 
		B.3.1 创建一个新项目
		B.3.2 使用std_lib_facilities.h头文件
		B.3.3 向项目中添加C++源文件
		B.3.4 输入源码
		B.3.5 生成可执行程序
		B.3.6 执行程序
		B.3.7 保存程序
	B.4 后续学习
术语表
 
进阶篇
★★★
作者：Bjarne Stroustrup
 
知识点
1.	C++基础知识。
2.	C++11基础知识。
3.	C++基础知识练习。
4.	依赖库FLTK。
5.	嵌入式系统程序设计（第25章）。
6.	C语言（第27章）。

代码
1.  第1版书籍代码。 
2.  第2版书籍代码。 
3.  练习代码。

前言
	致学生
	致老师
	ISO标准C++
	资源
	致谢
引言
	讲授和学习本书的方法
		一般方法
		简单练习和习题等
		进阶学习
		本书内容顺序和安排
		程序设计和程序设计语言
		可移植性
		提示标记
		附言 
	程序设计和计算机科学
	创造性和问题求解
	反馈方法
	参考文献
作者简介
第15章 容器和迭代器
	15.1 存储和处理数据
		15.1.1 处理数据
		15.1.2 泛化代码
	15.2 STL概念
	15.3 序列和迭代器
		15.3.1 回到实例
	15.4 链表
		15.4.1 链表操作
		15.4.2 遍历
	15.5 再次泛化vector
		15.5.1 遍历容器
		15.5.2 auto
	15.6 实例：一个简单的文本编辑器
		15.6.1 处理行
		15.6.2 遍历
	15.7 vector、list和string
		15.7.1 insert和erase
	15.8 调整vector类达到STL版本的功能
	15.9 调整内置数组达到STL版本的功能
	15.10 容器概览
		15.10.1 迭代器类别
	简单练习
	思考题
	术语
	习题
	附言
第16章 算法和映射
	16.1 标准库算法
	16.2 最简单的算法find()
		16.2.1 一些一般的应用
	16.3 通用搜索算法find_if()
	16.4 函数对象
		16.4.1 函数对象的抽象视图
		16.4.2 类成员上的断言
		16.4.3 lambda表达式
	16.5 数值算法
		16.5.1 累积
		16.5.2 泛化accumulate()
		16.5.3 内积
		16.5.4 泛化inner_product()
	16.6 关联容器
		16.6.1 map
		16.6.2 map概览
		16.6.3 另一个map实例
		16.6.4 unordered_map
		16.6.5 set
	16.7 拷贝
		16.7.1 基本拷贝算法
		16.7.2 流迭代器
		16.7.3 使用set保持顺序
		16.7.4 copy_if
	16.8 排序和搜索
	16.9 容器算法
	简单练习
	思考题
	术语
	习题
	附言
第17章 一个显示模型
	17.1 为什么要使用图形
	17.2 一个基本显示模型 
	17.3 第一个例子
	17.4 使用GUI库
	17.5 坐标系
	17.6 Shape
	17.7 使用Shape类
		17.7.1 图形头文件和主函数
		17.7.2 一个几乎空白的窗口
		17.7.3 坐标轴
		17.7.4 绘制函数图
		17.7.5 Polygon
		17.7.6 Rectangle
		17.7.7 填充
		17.7.8 Text
		17.7.9 Image
		17.7.10 更多未讨论的内容
	17.8 让图形程序运行起来
		17.8.1 源文件
	简单练习
	思考题
	术语
	习题
	附言
第18章 图形类
	18.1 图形类概览
	18.2 Point和Line
	18.3 Lines
	18.4 Color
	18.5 Line_style
	18.6 Open_polyline
	18.7 Closed_polyline
	18.8 Polygon
	18.9 Rectangle
	18.10 管理未命名对象
	18.11 Text
	18.12 Circle
	18.13 Ellipse
	18.14 Marked_polyline
	18.15 Marks
	18.16 Mark
	18.17 Image
	简单练习
	思考题
	术语
	习题
	附言
第19章 设计图形类
	19.1 设计原则
		19.1.1 类型
		19.1.2 操作
		19.1.3 命名
		19.1.4 可变性
	19.2 Shape
		19.2.1 一个抽象类
		19.2.2 访问控制
		19.2.3 绘制形状
		19.2.4 拷贝和可变性
	19.3 基类和派生类
		19.3.1 对象布局
		19.3.2 类的派生和虚函数的定义
		19.3.3 覆盖
		19.3.4 访问
		19.3.5 纯虚函数
	19.4 面向对象程序设计的好处
	简单练习
	思考题
	术语
	习题
	附言
第20章 绘制函数图和数据图
	20.1 简介
	20.2 绘制简单函数图
	20.3 Function
		20.3.1 默认参数
		20.3.2 更多例子
		20.3.3 lanbda表达式
	20.4 Axis
	20.5 近似
	20.6 绘制数据图
		20.6.1 读取文件
		20.6.2 一般布局
		20.6.3 数据比例
		20.6.4 构造数据图
	简单练习
	思考题
	术语
	习题
	附言
第21章 图形用户界面
	21.1 用户界面的选择
	21.2 “Next”按钮
	21.3 一个简单的窗口
		21.3.1 回调函数
		21.3.2 等待循环
		21.3.3 lambda表达式作为回调函数
	21.4 Button和其他Widget
		21.4.1 Widget
		21.4.2 Button
		21.4.3 In_box和Out_box
		21.4.4 Menu
	21.5 一个实例
	21.6 控制流反转
	21.7 添加菜单
	21.8 调试GUI代码
	简单练习
	思考题
	术语
	习题
	附言
第22章 理念和历史
	22.1 历史、理念和专业水平
		22.1.1 程序设计语言的目标和哲学
		22.1.2 编程理念
			22.1.2.1 我们需要的是什么
			22.1.2.2 一般性的方法
			22.1.2.3 思想的直接表达
			22.1.2.4 抽象层次
			22.1.2.5 模块化
			22.1.2.6 一致性和简约主义
		22.1.3 风格/范型
	22.2 程序设计语言历史概览
		22.2.1 最早的程序设计语言
		22.2.2 现代程序设计语言的起源
			22.2.2.1 Fortran
			22.2.2.2 COBOL
			22.2.2.3 Lisp
		22.2.3 Algol家族
			22.2.3.1 Algol60
			22.2.3.2 Pascal
			22.2.3.3 Ada
		22.2.4 Simula
		22.2.5 C
		22.2.6 C++
		22.2.7 今天
		22.2.8 参考资料
	思考题
	术语
	习题
	附言
第23章 文本处理
	23.1 文本
	23.2 字符串
	22.3 I/O流
	22.4 映射
		22.4.1 实现细节
	22.5 一个问题
	23.6 正则表达式的思想
		23.6.1 原始字符串常量
	23.7 用正则表达式进行搜索
	23.8 正则表达式语法
		23.8.1 字符和特殊字符
		23.8.2 字符集
		23.8.3 重复
		23.8.4 子模式
		23.8.5 可选项
		23.8.6 字符集和范围
		23.8.7 正则表达式错误
	23.9 使用正则表达式进行模式匹配
	23.10 参考文献
	简单练习
	思考题
	术语
	习题
	附言
第24章 数值计算
	24.1 简介
	24.2 大小、精度和溢出
		24.2.1 数值限制
	24.3 数组
	24.4 C风格的多维数组
	22.5 Matrix库
		24.5.1 矩阵的维和矩阵访问
		24.5.2 一维矩阵
		24.5.3 二维矩阵
		24.5.4 矩阵I/O
		24.5.5 三维矩阵
	24.6 实例：求解线性方程组
		24.6.1 经典的高斯消去法
		24.6.2 选取主元
		24.6.3 测试
	24.7 随机数
	24.8 标准数学函数
	24.9 复数
	24.10 参考文献
	简单练习
	思考题
	术语
	习题
	附言
第25章 嵌入式系统程序设计
	25.1 嵌入式系统
	25.2 基本概念
		25.2.1 可预测性
		25.2.2 理想
		25.2.3 生活在故障中
	25.3 内存管理
		25.3.1 动态内存分配存在的问题
		25.3.2 动态内存分配的替代方法
		25.3.3 存储池实例
		25.3.4 栈实例
	25.4 地址、指针和数组
		25.4.1 未经检查的类型转换
		25.4.2 一个问题：不正常的接口
		25.4.3 解决方案：接口类
		25.4.4 继承和容器
	25.5 位、字节和字
		25.5.1 位和位运算
		25.5.2 bitset
		25.5.3 有符号数和无符号数
		25.5.4 位运算
		25.5.5 位域
		25.5.6 实例：简单加密
	25.6 编码规范
		25.6.1 编码规范应该是怎样的
		25.6.2 编码原则实例
		25.6.3 实际编码规范
	简单练习
	思考题
	术语
	习题
	附言
第26章 测试
	26.1 我们想要什么
		26.1.1 警告
	26.2 程序正确性证明 
	26.3 测试
		26.3.1 回归测试
		26.3.2 单元测试
			26.3.2.1 测试策略
			26.3.2.2 一个简单的测试
			26.3.2.3 随机序列
		26.3.3 算法和非算法
			26.3.3.1 相关性
			26.3.3.2 资源管理
			26.3.3.3 循环
			26.3.3.4 分支
		26.3.4 系统测试
		26.3.5 寻找不成立的假设
	26.4 测试方案设计 
	26.5 调试
	26.6 性能
		26.6.1 计时
	26.7 参考文献
	简单练习
	思考题
	术语
	习题
	附言
第27章 C语言
	27.1 C和C++：兄弟
		27.1.1 C/C++兼容性
		27.1.2 C不支持的C++特性
		27.1.3 C标准库
	27.2 函数
		27.2.1 不支持函数名重载
		27.2.2 函数参数类型检查
		27.2.3 函数定义
		27.2.4 C++调用C和C调用C++
		27.2.5 函数指针
	27.3 小的语言差异
		27.3.1 struct标签名字空间
		27.3.2 关键字
		27.3.3 定义
		27.3.4 C风格类型转换
		27.3.5 无类型指针的转换
		27.3.6 枚举
		27.3.7 名字空间
	27.4 自由存储空间
	27.5 C风格字符串
		27.5.1 C风格字符串和const
		27.5.2 字节操作
		27.5.3 实例：strcpy()
		27.5.4 一个风格问题
	27.6 输入/输出：stdio
		27.6.1 输出
		27.6.2 输入
		27.6.3 文件
	27.7 常量和宏
	27.8 宏
		27.8.1 类函数宏
		27.8.2 语法宏
		27.8.3 条件编译
	27.9 实例：侵入式容器
	简单练习
	思考题
	术语
	习题
	附言
附录C 标准库概要
	C.1 概述
		C.1.1 头文件
		C.1.2 名字空间std
		C.1.3 描述风格
	C.2 错误处理
		C.2.1 异常
	C.3 迭代器
		C.3.1 迭代器模型
		C.3.2 迭代器类别
	C.4 容器
		C.4.1 容器操作概述
		C.4.2 成员类型
		C.4.3 构造、析构函数和赋值
		C.4.4 迭代器
		C.4.5 元素访问
		C.4.6 栈和队列操作
		C.4.7 链表操作
		C.4.8 大小和容量
		C.4.9 其他操作
		C.4.10 关联容器操作
	C.5 算法
		C.5.1 非变动性序列算法
		C.5.2 变动性序列算法
		C.5.3 工具算法
		C.5.4 排序和搜索
		C.5.5 集合算法
		C.5.6 堆
		C.5.7 排列
		C.5.8 min和max
	C.6 STL工具
		C.6.1 插入器
		C.6.2 函数对象
		C.6.3 pair和tuple
		C.6.4 initlalizer_list
		C.6.5 资源管理指针
	C.7 I/O流
		C.7.1 I/O流层次
		C.7.2 I/O错误处理
		C.7.3 输入操作
		C.7.4 输出操作
		C.7.5 格式化
		C.7.6 标准格式操纵符
	C.8 字符串处理
		C.8.1 字符分类
		C.8.2 字符串
		C.8.3 正则表达式匹配
	C.9 数值
		C.9.1 数值限制
		C.9.2 标准数学函数
		C.9.3 复数
		C.9.4 valarray
		C.9.5 泛型数值算法
		C.9.6 随机数
	C.10 时间组件
	C.11 C标准库函数
		C.11.1 文件
		C.11.2 printf()函数家族
		C.11.3 C风格字符串
		C.11.4 内存
		C.11.5 日期和时间
		C.11.6 其他函数
	C.12 其他库
附录D 安装FLTK
	D.1 介绍
	D.2 下载FLTK
	D.3 安装FLTK
	D.4 在Visual Studio中使用FLTK
	D.5 测试是否工作正常
附录E GUI实现
	E.1 回调函数实现
	E.2 Widget实现
	E.3 Window实现
	E.4 Vector_ref
	E.5 实例：操作Widget
术语表