C++ 高级编程（Professional C++）
（第4版）

官方网站：
http://becpp.org/blog/ 、http://www.nuonsoft.com/blog/ 、http://www.wrox.com/。

C++：
https://en.cppreference.com/w/ 、http://www.cplusplus.com/reference/ 。

★
作者：Marc Gregoire

知识点 
1.	C++	基础知识。

代码 
1.  书籍代码。 

前言
	读者对象
	本书主要内容 
	本书结构
	使用本书的条件
	Microsoft Visual C++
	GCC
	勘误表
	源代码
第Ⅰ部分 专业的C++简介
	第1章  C++和标准库速成
		1.1 C++基础知识
			1.1.1 小程序“Hello world”
			1.1.2 名称空间
			1.1.3 字面量
			1.1.4 变量
			1.1.5 运算符
			1.1.6 类型
			1.1.7 条件语句
			1.1.8 逻辑比较运算符
			1.1.9 函数
			1.1.10 C风格的数组
			1.1.11 std::array
			1.1.12 std::vector
			1.1.13 结构化绑定
			1.1.14 循环
			1.1.15 初始化列表
			1.1.16 这些都是基础
		1.2 深入研究C++
			1.2.1 C++中的字符串
			1.2.2 指针和动态内存
			1.2.3 const的多种用法
			1.2.4 引用
			1.2.5 异常
			1.2.6 类型推断
		1.3 作为面向对象语言的C++
			1.3.1 定义类
			1.3.2 使用类
		1.4 统一初始化
		1.5 标准库
		1.6 第一个有用的C++程序
			1.6.1 雇员记录系统
			1.6.2 Employee类
			1.6.3 Database类
			1.6.4 用户界面
			1.6.5 评估程序
		1.7 本章小结
	第2章 使用string和string_view
		2.1 动态字符串
			2.1.1 C风格的字符串
			2.1.2 字符串字面量
			2.1.3 C++ std::string类
			2.1.4 std::string_view类
			2.1.5 非标准字符串
		2.2 本章小结
	第3章 编码风格
		3.1 良好外观的重要性
			3.1.1 事先考虑
			3.1.2 良好风格的元素
		3.2 为代码编写文档
			3.2.1 使用注释的原因
			3.2.2 注释的风格
		3.3 分解
			3.3.1 通过重构分解
			3.3.2 通过设计来分解
			3.3.3 本书中的分解
		3.4 命名
			3.4.1 选择恰当的名称
			3.4.2 命名约定
		3.5 使用具有风格的语言特性
			3.5.1 使用常量
			3.5.2 使用引用代替指针
			3.5.3 使用自定义异常
		3.6 格式
			3.6.1 关于大括号对齐的争论
			3.6.2 关于空格和圆括号的争论
			3.6.3 空格和制表符
		3.7 风格的挑战
		3.8 本章小结
第II部分 专业的C++软件设计
	第4章 设计专业的C++程序
		4.1 程序设计概述
		4.2 程序设计的重要性
		4.3 C++设计的特点
		4.4 C++设计的两个原则
			4.4.1 抽象
			4.4.2 重用
		4.5 重用代码
			4.5.1 关于术语的说明
			4.5.2 决定是否重用代码
			4.5.3 重用代码的策略
			4.5.4 绑定第三方应用程序
			4.5.5 开放源代码库
			4.5.6 C++标准库
		4.6 设计一个国际象棋程序
			4.6.1 需求
			4.6.2 设计步骤
		4.7 本章小结
	第5章 面向对象设计
		5.1 过程化的思考方式
		5.2 面向对象思想
			5.2.1 类
			5.2.2 组件
			5.2.3 属性
			5.2.4 行为
			5.2.5 综合考虑
		5.3 生活在对象世界里
			5.3.1 过度使用对象
			5.3.2 过于通用的对象
		5.4 对象之间的关系
			5.4.1 “有一个”关系
			5.4.2 “是一个”关系(继承)
			5.4.3 “有一个”与“是一个”的区别
			5.4.4 not-a关系
			5.4.5 层次结构
			5.4.6 多重继承
			5.4.7 混入类
		5.5 抽象
			5.5.1 接口与实现
			5.5.2 决定公开的接口
			5.5.3 设计成功的抽象
		5.6 本章小结
	第6章 设计可重用代码
		6.1 重用哲学
		6.2 如何设计可重用代码
			6.2.1 使用抽象
			6.2.2 构建理想的重用代码
			6.2.3 设计有用的接口
			6.2.4 SOLID原则
		6.3 本章小结
第III部分 专业的C++编码方法
	第7章 内存管理
		7.1 使用动态内存
			7.1.1 如何描绘内存
			7.1.2 分配和释放
			7.1.3 数组
			7.1.4 使用指针
		7.2 数组-指针的对偶性
			7.2.1 数组就是指针
			7.2.2 并非所有指针都是数组
		7.3 低级内存操作
			7.3.1 指针运算
			7.3.2 自定义内存管理
			7.3.3 垃圾回收
			7.3.4 对象池
		7.4 智能指针
			7.4.1 unique_ptr
			7.4.2 shared_ptr
			7.4.3 weak_ptr
			7.4.4 移动语义
			7.4.5 enable_shared_from_this
			7.4.6 旧的、过时的/取消的auto_ptr
		7.5 常见的内存陷阱
			7.5.1 分配不足的字符串
			7.5.2 访问内存越界
			7.5.3 内存泄漏
			7.5.4 双重删除和无效指针
		7.6 本章小结
	第8章 熟悉类和对象
		8.1 电子表格示例介绍
		8.2 编写类
			8.2.1 类定义
			8.2.2 定义方法
			8.2.3 使用对象
		8.3 对象的生命周期
			8.3.1 创建对象
			8.3.2 销毁对象
			8.3.3 对象赋值
			8.3.4 编译器生成的复制构造函数和复制赋值运算符
			8.3.5 复制和赋值的区别
		8.4 本章小结
	第9章 精通类与对象
		9.1 友元
		9.2 对象的动态内存分配
			9.2.1 Spreadsheet类
			9.2.2 使用析构函数释放内存
			9.2.3 处理复制和赋值
			9.2.4 使用移动语义处理移动
			9.2.5 零规则
		9.3 与方法有关的更多内容
			9.3.1 静态方法
			9.3.2 const方法
			9.3.3 方法重载
			9.3.4 内联方法
			9.3.5 默认参数
		9.4 不同的数据成员类型
			9.4.1 静态数据成员
			9.4.2 静态常量数据成员
			9.4.3 引用数据成员
			9.4.4 常量引用数据成员
		9.5 嵌套类
		9.6 类内的枚举类型
		9.7 运算符重载
			9.7.1 示例：为SpreadsheetCell实现加法
			9.7.2 重载算术运算符
			9.7.3 重载比较运算符
			9.7.4 创建具有运算符重载的类型
		9.8 创建稳定的接口
		9.9 本章小结
	第10章 揭秘继承技术
		10.1 使用继承构建类
			10.1.1 扩展类
			10.1.2 重写方法
		10.2 使用继承重用代码
			10.2.1 WeatherPrediction类
			10.2.2 在派生类中添加功能
			10.2.3 在派生类中替换功能
		10.3 利用父类
			10.3.1 父类构造函数
			10.3.2 父类的析构函数
			10.3.3 使用父类方法
			10.3.4 向上转型和向下转型
		10.4 继承与多态性
			10.4.1 回到电子表格
			10.4.2 设计多态性的电子表格单元格   
			10.4.3 SpreadsheetCell基类
			10.4.4 独立的派生类
			10.4.5 利用多态性
			10.4.6 考虑将来
		10.5 多重继承
			10.5.1 从多个类继承
			10.5.2 名称冲突和歧义基类
		10.6 有趣而晦涩的继承问题
			10.6.1 修改重写方法的特征
			10.6.2 继承的构造函数
			10.6.3 重写方法时的特殊情况
			10.6.4 派生类中的复制构造函数和赋值运算符
			10.6.5 运行时类型工具
			10.6.6 非public继承
			10.6.7 虚基类
		10.7 本章小结
	第11章 理解灵活而奇特的C++
		11.1 引用
			11.1.1 引用变量
			11.1.2 引用数据成员
			11.1.3 引用参数
			11.1.4 将引用作为返回值
			11.1.5 右值引用
			11.1.6 使用引用还是指针
		11.2 关键字的疑问
			11.2.1 const关键字
			11.2.2 static关键字
			11.2.3 非局部变量的初始化顺序  
			11.2.4 非局部变量的销毁顺序
		11.3 类型和类型转换
			11.3.1 类型别名
			11.3.2 函数指针的类型别名
			11.3.3 方法和数据成员的指针的类型别名
			11.3.4 typedef
			11.3.5 类型转换
		11.4 作用域解析
		11.5 特性
			11.5.1 [[noreturn]]特性
			11.5.2 [[deprecated]]特性
			11.5.3 [[fallthrough]]特性
			11.5.4 [[nodiscard]]特性
			11.5.5 [[maybe_unused]]特性
			11.5.6 供应商专用特性
		11.6 用户定义的字面量
		11.7 头文件
		11.8 C++的实用工具
			11.8.1 变长参数列表
			11.8.2 预处理器宏
		11.9 本章小结
	第12章 利用模板编写泛型代码
		12.1 模板概述
		12.2 类模板
			12.2.1 编写类模板
			12.2.2 尖括号
			12.2.3 编译器处理模板的原理
			12.2.4 将模板代码分布在多个文件中
			12.2.5 模板参数
			12.2.6 方法模板
			12.2.7 类模板的特例化
			12.2.8 从类模板派生
			12.2.9 继承还是特例化
			12.2.10 模板别名
		12.3 函数模板
			12.3.1 函数模板的特例化
			12.3.2 函数模板的重载
			12.3.3 类模板的友元函数模板
			12.3.4 对模板参数推导的更多介绍
			12.3.5 函数模板的返回类型
		12.4 可变模板
		12.5 本章小结
	第13章 C++ I/O揭秘
		13.1 使用流
			13.1.1 流的含义
			13.1.2 流的来源和目的地
			13.1.3 流式输出
			13.1.4 流式输入
			13.1.5 对象的输入输出
		13.2 字符串流
		13.3 文件流
			13.3.1 文本模式与二进制模式
			13.3.2 通过seek()和tell()在文件中转移
			13.3.3 将流链接在一起
		13.4 双向I/O
		13.5 本章小结
	第14章 错误处理
		14.1 错误与异常
			14.1.1 异常的含义
			14.1.2 C++中异常的优点
			14.1.3 我们的建议
		14.2 异常机制
			14.2.1 抛出和捕获异常
			14.2.2 异常类型
			14.2.3 按const和引用捕获异常对象
			14.2.4 抛出并捕获多个异常
			14.2.5 未捕获的异常
			14.2.6 noexcept
			14.2.7 抛出列表（已不赞成使用/已删除）
		14.3 异常与多态性
			14.3.1 标准异常体系
			14.3.2 在类层次结构中捕获异常
			14.3.3 编写自己的异常类
			14.3.4 嵌套异常
		14.4 重新抛出异常
		14.5 堆栈的释放与清理 
			14.5.1 使用智能指针
			14.5.2 捕获、清理并重新抛出
		14.6 常见的错误处理问题
			14.6.1 内存分配错误
			14.6.2 构造函数中的错误
			14.6.3 构造函数的function-try-blocks
			14.6.4 析构函数中的错误
		14.7 综合应用
		14.8 本章小结
	第15章 C++运算符重载
		15.1 运算符重载概述
			15.1.1 重载运算符的原因
			15.1.2 运算符重载的限制
			15.1.3 运算符重载的选择
			15.1.4 不应重载的运算符
			15.1.5 可重载运算符小结
			15.1.6 右值引用 
			15.1.7 关系运算符
		15.2 重载算术运算符
			15.2.1 重载一元负号和一元正号运算符
			15.2.2 重载递增和递减运算符
		15.3 重载按位运算符和二元逻辑运算符
		15.4 重载插入运算符和提取运算符
		15.5 重载下标运算符
			15.5.1 通过operator[]提供只读访问
			15.5.2 非整数数组索引
		15.6 重载函数调用运算符
		15.7 重载解除引用运算符
			15.7.1 实现operator*
			15.7.2 实现operator->
			15.7.3 operator.*和operator->*的含义 
		15.8 编写转换运算符
			15.8.1 使用显式转换运算符解决多义性问题
			15.8.2 用于布尔表达式的转换
		15.9 重载内存分配和内存释放运算符
			15.9.1 new和delete的工作原理 
			15.9.2 重载operator new和operator delete
			15.9.3 显式地删除/默认化operator new和operator delete
			15.9.4 重载带有额外参数的operator new和operator delete
			15.9.5 重载带有内存大小参数的operator delete
		15.10 本章小结
	第16章 C++标准库概述
		16.1 编码原则
			16.1.1 使用模板
			16.1.2 使用运算符重载
		16.2 C++标准库概述
			16.2.1 字符串
			16.2.2 正则表达式
			16.2.3 I/O流
			16.2.4 智能指针
			16.2.5 异常
			16.2.6 数学工具
			16.2.7 时间工具
			16.2.8 随机数
			16.2.9 初始化列表
			16.2.10 pair和tuple
			16.2.11 optional、variant和any
			16.2.12 函数对象
			16.2.13 文件系统
			16.2.14 多线程
			16.2.15 类型特质
			16.2.16 标准整数类型
			16.2.17 容器
			16.2.18 算法 
			16.2.19 标准库中还缺什么
		16.3 本章小结
	第17章 理解容器与迭代器
		17.1 容器概述
			17.1.1 对元素的要求
			17.1.2 异常和错误检查
			17.1.3 迭代器
		17.2 顺序容器
			17.2.1 vector
			17.2.2 vector<bool>特化
			17.2.3 deque
			17.2.4 list
			17.2.5 forward_list
			17.2.6 array
		17.3 容器适配器
			17.3.1 queue
			17.3.2 priority_queue
			17.3.3 stack
		17.4 有序关联容器
			17.4.1 pair工具类
			17.4.2 map
			17.4.3 multimap
			17.4.4 set
			17.4.5 multiset
		17.5 无序关联容器/哈希表
			17.5.1 哈希函数
			17.5.2 unordered_map
			17.5.3 unordered_multimap
			17.5.4 unordered_set/unordered_multiset
		17.6 其他容器
			17.6.1 标准C风格数组
			17.6.2 string
			17.6.3 流
			17.6.4 bitset
		17.7 本章小结
	第18章 掌握标准库算法 
		18.1 算法概述
			18.1.1 find()和find_if()算法 
			18.1.2 accumulate()算法 
			18.1.3 在算法中使用移动语义
		18.2 std::function
		18.3 lambda表达式
			18.3.1 语法
			18.3.2 泛型lambda表达式
			18.3.3 lambda捕捉表达式
			18.3.4 将lambda表达式用作返回类型
			18.3.5 将lambda表达式用作参数
			18.3.6 标准库算法示例
		18.4 函数对象
			18.4.1 算术函数对象
			18.4.2 比较函数对象
			18.4.3 逻辑函数对象
			18.4.4 按拉函数对象
			18.4.5 函数对象适配器
			18.4.6 std::invoke()
			18.4.7 编写自己的函数对象
		18.5 算法详解 
			18.5.1 迭代器
			18.5.2 非修改序列算法 
			18.5.3 修改序列算法 
			18.5.4 操作算法
			18.5.5 交换算法 
			18.5.6 分区算法 
			18.5.7 排序算法 
			18.5.8 二叉树搜索算法 
			18.5.9 集合算法 
			18.5.10 最大/最小算法 
			18.5.11 并行算法 
			18.5.12 数值处理算法 
		18.6 算法示例：审核选民登记
			18.6.1 选择登记审核问题描述
			18.6.2 auditVoterRolls()函数
			18.6.3 getDuplicates()函数
			18.6.4 测试auditVoterRolls()函数
		18.7 本章小结
	第19章 字符串的本地化与正则表达式
		19.1 本地化
			19.1.1 本地化字符串字面量
			19.1.2 宽字符
			19.1.3 非西方字符集
			19.1.4 转换
			19.1.5 locale和facet
		19.2 正则表达式
			19.2.1 DCMAScript语法
			19.2.2 regex库
			19.2.3 regex_match()
			19.2.4 regex_search()
			19.2.5 regex_iterator
			19.2.6 regex_token_iterator
			19.2.7 regex_replace()
		19.3 本章小结
	第20章 其他库工具
		20.1 ratio库
		20.2 chrono库
			20.2.1 持续时间
			20.2.2 时钟
			20.2.3 时点
		20.3 生成随机数
			20.3.1 随机数引擎
			20.3.2 随机数引擎适配器
			20.3.3 预定义的随机数引擎和引擎适配器
			20.3.4 生成随机数
			20.3.5 随机数分布
		20.4 optional
		20.5 variant
		20.6 any
		20.7 元组
			20.7.1 分解元组
			20.7.2 串联
			20.7.3 比较
			20.7.4 make_from_tuple()
			20.7.5 apply()
		20.8 文件系统支持库
			20.8.1 path
			20.8.2 directory_entry
			20.8.3 辅助函数
			20.8.4 目录迭代
		20.9 本章小结
第Ⅳ部分 掌握C++的高级特性
	第21章 自定义和扩展标准库
		21.1 分配器
		21.2 流适配器
			21.2.1 输出流迭代器
			21.2.2 输入流迭代器
		21.3 迭代器适配器
			21.3.1 反向迭代器
			21.3.2 插入迭代器
			21.3.3 移动迭代器
		21.4 扩展标准库
			21.4.1 扩展标准库的原因
			21.4.2 编写标准库算法 
			21.4.3 编写标准库容器
		21.5 本章小结
	第22章 高级模板
		22.1 深入了解模板参数
			22.1.1 深入了解模板类型参数
			21.1.2 template template参数介绍
			21.1.3 深入了解非类型模板参数
		22.2 模板类部分特例化
		22.3 通过重载模拟函数部分特例化
		22.4 模板递归
			22.4.1 N维网络：初次尝试
			22.4.2 真正的N维网络
		22.5 可变参数模板
			22.5.1 类型安全的变长参数列表
			22.5.2 可变数目的混入类
			22.5.3 折叠表达式
		22.6 模板元编程
			22.6.1 编译时阶乘
			22.6.2 循环展开
			22.6.3 打印元组
			22.6.4 类型trait
			22.6.5 模板元编程结论
		22.7 本章小结
	第23章 C++多线程编程
		23.1 多线程编程概述 
			23.1.1 争用条件
			23.1.2 撕裂
			23.1.3 死锁
			23.1.4 伪共享
		23.2 线程
			23.2.1 通过函数指针创建线程
			23.2.2 通过函数对象创建线程
			23.2.3 通过lambda创建线程
			23.2.4 通过成员函数创建线程
			23.2.5 线程本地存储
			23.2.6 取消线程
			23.2.7 从线程获得结果
			23.2.8 复制和重新抛出异常
		23.3 原子操作库
			23.3.1 原子类型示例
			23.3.2 原子操作
		23.4 互斥
			23.4.1 互斥体类
			23.4.2 锁
			23.4.3 std::call_once
			23.4.4 互斥体对象的用法示例
		23.5 条件变量
			23.5.1 假唤醒
			23.5.2 使用条件变量
		23.6 future
			23.6.1 std::promise和std::future
			23.6.2 std::packaged_task
			23.6.3 std::async
			23.6.4 异常处理
			23.6.5 std::shared_future
		23.7 示例：多线程的Logger类
		23.8 线程池
		23.9 线程设计和最佳实践
		23.10 本章小结
第Ⅴ部分 C++软件工程
	第24章 充分利用软件工程方法
		24.1 过程的必要性
		24.2 软件生命周期模型
			24.2.1 瀑布模型
			24.2.2 生鱼片模型
			24.2.3 螺旋类模型
			24.2.4 敏捷
		24.3 软件工程方法论
			24.3.1 UP
			24.3.2 RUP
			24.3.3 Scrum
			24.3.4 极限编程
			24.3.5 软件分流
		24.4 构建自己的过程和方法
			24.4.1 对新思想采取开放态度
			24.4.2 提出新想法 
			24.4.3 知道什么行得通、什么行不通
			24.4.4 不要逃避
		24.5 源代码控制
		24.6 本章小结
	第25章 编写高效的C++程序
		25.1 性能和效率概述
			25.1.1 提升效率的两种方式
			25.1.2 两种程序
			25.1.3 C++是不是低效的语言
		25.2 语言层次的效率
			25.2.1 高效地操纵对象
			25.2.2 预分配内存
			25.2.3 使用内联方法和函数
		25.3 设计层次的效率
			25.3.1 尽可能多地缓存
			25.3.2 使用对象池
		25.4 剖析
			25.4.1 使用gprof的剖析示例
			25.4.2 使用Visual C++ 2017的剖析示例
		25.5 本章小结
	第26章 熟练掌握测试技术
		26.1 质量控制
			26.1.1 谁负责测试
			26.1.2 bug的生命周期
			26.1.3 bug的跟踪工具
		26.2 单元测试
			26.2.1 单元测试方法
			26.2.2 单元测试过程
			26.2.3 实际中的单元测试
		26.3 高级测试
			26.3.1 集成测试
			26.3.2 系统测试
			26.3.3 回归测试
		26.4 用于成功测试的建议
		26.5 本章小结
	第27章 熟练掌握调试技术 
		27.1 调试的基本定律
		27.2 bug分类学
		27.3 避免bug
		27.4 为bug做好规划
			27.4.1 错误日志
			27.4.2 调试跟踪
			27.4.3 断言
			27.4.4 崩溃转储
		27.5 静态断言 
		27.6 调试技术
			27.6.1 重现bug
			27.6.2 调试可重复的bug
			27.6.3 调试不可重现的bug
			27.6.4 调试退化
			27.6.5 调试内存问题
			27.6.6 调试多线程程序
			27.6.7 调试示例：文章引用
			27.6.8 从articleCitations示例中总结出的教训
		27.7 本章小结
	第28章 使用设计技术和框架
		28.1 容易忘记的语法 
			28.1.1 编写类
			28.1.2 派生类
			28.1.3 使用“复制和交换”惯用语法 
			28.1.4 抛出和捕捉异常
			28.1.5 读取文件
			28.1.6 写入文件
			28.1.7 写入模板类
		28.2 始终存在更好的方法
			28.2.1 RAII
			28.2.2 双分派
			28.2.3 混入类
		28.3 面向对象的框架
			28.3.1 使用框架
			28.3.2 MVC范型
		28.4 本章小结
	第29章 应用设计模式
		29.1 迭代器模式
		29.2 单例模式
			29.2.1 日志记录机制
			29.2.2 实现单例
			29.2.3 使用单例
		29.3 抽象工厂模式
			29.3.1 示例：模拟汽车工厂
			29.3.2 实现工厂
			29.3.2 使用工厂
			29.3.4 工厂的其他用法 
		29.4 代理模式
			29.4.1 示例：隐藏网络连接问题
			29.4.2 实现代理
			29.4.3 使用代理
		29.5 适配器模式
			29.5.1 示例：改偏Logger类
			29.5.2 实现适配器
			29.5.3 使用适配器
		29.6 装饰器模式
			29.6.1 示例：在网页中定义样式
			29.6.2 装饰器的实现
			29.6.3 使用装饰器
		29.7 责任链模式
			29.7.1 示例：事件处理
			29.7.2 实现责任链
			29.7.3 没有层次结构的责任链
		29.8 观察者模式
			29.8.1 实现观察者
			29.8.1 实现可观察类
			29.8.3 使用观察者
		29.9 本章小结
	第30章 开发跨平台和跨语言应用程序
		30.1 跨平台开发
			30.1.1 架构问题
			30.1.2 实现问题
			30.1.3 平台专用功能
		30.2 跨语言开发
			30.2.1 混用C和C++
			30.2.2 改变范型
			30.2.3 链接C代码
			30.2.4 从C#调用C++代码
			30.2.5 从Java使用JNI调用C++代码
			30.2.6 从C++代码调用脚本
			30.2.7 从脚本调用C++代码
			30.2.8 从C++调用汇编代码
		30.3 本章小结
附录
	附录A C++面试
	附录B 带注解的参考文献
	附录C 标准库头文件
	附录D UML简介