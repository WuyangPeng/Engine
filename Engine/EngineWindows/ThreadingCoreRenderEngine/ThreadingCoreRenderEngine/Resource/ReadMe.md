@ingroup group_Engine_Documentation

----------------------------
编码规范

1.  命名空间，类名和函数名以大写字母开头，驼峰式大小写。
2.  变量名以小写字母开头，驼峰式大小写。
3.  宏必须全大写，且以下划线隔开。除了宏之外，不使用全大写的变量名。
4.  以下命名前缀为可选，除止之外禁止使用命名前缀：成员变量使用m_开头，类静态变量使用sm_开头，全局变量使用g_开头，局部静态变量使用s_开头。
5.  使用enum class的方式定义枚举。枚举名以大写字母开头，驼峰式大小写。
6.  头文件使用.h的扩展名，源文件使用.cpp的扩展名，内联文件使用.inl的扩展名，json配置文件使用.json的扩展名，
    日志文件使用.log的扩展名，模板实现文件使用.h的扩展名，并以Detail或Achieve结尾。
7.  外部类（导出类）前加XXX_DEFAULT_DECLARE，XXX为所在库名的全大写。
8.  内部类（不导出类）前加XXX_HIDDEN_DECLARE，XXX为所在库名的全大写。
9.  尽量不直接使用除0和1之外的整数值，避免使用文字量，应使用具名常量或具有适当作用域的变量代替。
10. 不同平台或项目配置命名规则：Static + $(Platform) + $(Configuration)，如StaticX64Debug。
11. 使用min和max表示[min,max]区间，使用begin和end表示[begin,end)区间。
12. 对直接抛出异常的函数使用[[noreturn]] 。
13. 对必须检查返回值的函数使用[[nodiscard]]。
14. 对可能不会使用的参数使用[[maybe_unused]]。
15. 对于没有break的case标签使用[[fallthrough]]。
16. 禁止注释掉代码，必需保留不执行的代码使用预处理器。
17. 定义宏为空时，使用static_cast<void>(0)，可防止宏被用作右值。
18. 使用using代替typedef。
19. 整型转换不使用static_cast，转换失败抛出异常使用boost::numeric_cast，不能抛出异常使用gsl::narrow_cast消除警告。
20. 使用make_shared和make_unique来创建智能指针，而不是new。
21. 使用必要的noexcept、final和override。
22. 如果一个析构函数调用了任何函数，这些函数都可能抛出异常。一个析构函数不能抛出异常。
	所以任何调用了其他函数的析构函数都应该捕获和管理它自己的异常。
23. 移动复制构造函数、移动赋值运算符、swap函数、析构函数必须定义为noexcept。
24. 对于可能返回空指针的函数使用MAYBE_NULLPTR。
25. 对于内置类型，优先使用bool、char、int、double和必要的size_t。
    需要使用其它类型时，尽量使用固定大小的整型。网络或系统相关调用必须使用固定大小的整型。
26. 构造函数不重载具有std::initializer_list型别的形参。

----------------------------
设计规范

1.  使用C++17标准。
2.  所有在各个操作系统实现不同的函数，全转移到System库。
3.  除System库外，尽量不使用参数返回值。与性能相关，需要使用参数返回时，转移到各个库的底层调用模块中，如Mathematics库增加Underlying模块。
4.  除Sysetm库外，所有类必须使用类不变式，并定义ClassType和必要的ParentType，且尽量使用ASSETRTION。
    由于调试性能原因，不直接调用内部类的类不变式，即调用“impl->IsValid();”。
5.  所有单例及静态数据调用必须使用锁。
6.  将警告设置为Level4，并将警告视为错误，代码需要通过代码分析。
7.  禁止浮点数直接比较相等或不相等。
8.  在没有明显的理由需要指定数据类型时，一般使用auto。
9.  使用初始化器列表的形式初始化，只在必要时使用括号形式（如vector）和等号形式（如auto）初始化。
10. 除特殊需求外，禁止返回空指针、传递空指针和使用裸指针。可使用特例模式进行替代返回空指针。
11. 只包含必须包含的头文件，头文件的包含顺序：从最特殊到最一般。本地目录中的任何头文件首先被包含，
    然后是我们自己的所用工具头文件，随后是第三方库头文件，接着是标准C++库头文件和C库头文件。
12. 除非你确实需要共享所有权，否则别轻易使用shared_ptr，请使用unique_ptr。
    但由于unique_ptr析构函数需要知道指定类的大小，Impl模式不使用unique_ptr封装指针，而使用更容易编程的shared_ptr。
13. 同时存在标准库和boost库实现时，使用标准库的实现。
14. 首选传值方式而不是const引用方式返回函数的结果。
15. 错误使用异常而非返回码。
16.	派生类的前置条件相比基类可以更宽松，但不能更严格。 
17.	派生类应该从基类继承所有后置条件。
18.	移动构造函数和移动赋值运算符必须定义成noexcept。
19.	函数都是异常安全的，这意味着它们至少提供基本异常安全保证。
20. 非必要不使用mutable变量，需要保证const成员函数的线程安全性。
21. 使用Impl模式封装类，通过定义ClassShareType来标识类是属于：
   （1）当类必须共享资源时，复制只是复制类的指针成员，需要在类前注释（共享类），构造函数和赋值运算符进行简单的复制指针。共享类必须以Share结尾。
   （2）类没有修改自身的成员函数，为了提高性能，复制只是复制类的指针成员，构造函数和赋值运算符进行简单的复制指针。
   （3）类有修改自身的成员函数，此时定义复制构造函数和赋值运算符对类进行深复制。
   （4）类有修改自身的成员函数，构造函数和赋值运算符简单的复制指针，只在调用非常量成员函数时对类进行深复制，即写时复制机制（Copy on Write，COW）。
        但以下情况禁止使用延迟复制：
	    导出类有虚函数的情况下。
        导出类内部某个成员析构函数有特殊调用的情况下。
	    导出类有返回内部成员的引用或指针的情况下。
   （5）类禁止复制。

----------------------------
建议规范

1. 函数要短，命名清晰。
2. 减少if、for的使用，使用子类或for_each。
3. 对于p是指针，使用if(p != nullptr)，而不是更简洁的if(p)或if(nullptr != p)。
4. 避免使用do语句。
5. 使用弱指针weak_ptr保存对象，而不是使用保存对象id，然后通过单例去索引。
6. 任何编写类模板或函数模板的程序员都应该将概念检查作为他们所编写的代码的正常部分。
7. 声明一个类或函数时，使用包含头文件的方法。如果一个库很大，应该提供一个头文件的简写形式。
8. 使用move和forward的代码应该使用std::move和std::forward而不使用using声明。这样做可以避免潜在的名字冲突。
9. 按照数轴的顺序或变量――常量的顺序编写数值表达式。
10.if语句、else语句、while语句等，其中的代码块应该只有一行。该行大抵应该是一个函数调用语句。
11.把try和catch代码块的主体部分抽离出来，另外形成函数。
12.当向const函数传入引用或指针时，也要考虑该参数是否可以声明为const。
13.优先使用函数重载而不是默认参数。
14.不要把默认参数作为一个标志去决定执行函数的哪一块。在这种情况下，就应该把函数成两个或多个重载的函数。
15.避免在整型和指针型别之间重载。

----------------------------
注释规范

1. 使用Doxygen的注释风格。
2. 使用/// @的风格。
3. 主页标识： mainpage
4. 版权信息： copyright 
5. 作者信息： author 
6. 版本信息： version
7. 日期： date 
8. 简要说明： brief 
9. 返回结果描述： return 
10.类不变式描述： invariant 
11.前置条件描述： pre 
12.后置条件描述： post 
13.代码示例：code endcode 
14.分组标识：ingroup 
15.类名：class 

---------------------------- 
编程原则

1.	清晰原则：清晰用于技巧。
2.	组合原则：设计能够互相连接的组件。
3.	多样性原则：质疑任何被声称为“真正惟一”的途径。
4.	经济原则：和机器的时间相比，程序员的时间是更宝贵的。
5.	可扩展性原则：设计着眼未来，因为未来比你想象得来得更快。
6.	生成原则：避免手动编码，可以的话，编写程序来生成程序。
7.	最小意外原则：在接口设计中作出的决策应该始终是那个令人最少感到意外的选择。
8.	模块化原则：编写简单的模块，模块与模块间通过干净的接口连接。
9.	最大意外原则：如果免不了要失败的话，要弄出最大动静，而且失败得越早越好。
10.	优化原则：首先要能工作，然后能能谈得上优化。
11.	吝啬原则：除非确无它法，否则不要编写大的组件。
12.	健壮性原则：透明性和简单性是健壮性的父母。
13.	分离原则：策略和机制分离，接口与引擎分离。
14.	简单原则：设计应该是简单的，只在必须的时候才增加或暴露复杂性。
15.	透明原则：设计的时候应考虑透明性，以方便检查和调试。

---------------------------- 
