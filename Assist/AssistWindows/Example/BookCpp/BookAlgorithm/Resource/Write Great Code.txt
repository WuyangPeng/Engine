编程卓越之道（Write Great Code）

第一卷：深入理解计算机（Volume 1:Understanding the Machine）
★
作者：Randall Hyde

知识点 
1.	算法基础知识。 

致谢
第1章 编写卓越代码须知
	1.1 编程卓越之道系列
	1.2 本卷内容
	1.3 本卷所做的假设
	1.4 卓越代码的各项特征
	1.5 本卷涉及的环境
	1.6 获取更多信息
第2章 数值表示
	2.1 什么是数
	2.2 计数系统
		2.2.1 十进制位值计数系统
		2.2.2 进制（基数）
		2.2.3 二进制计数系统
		2.2.4 十六进制计数系统
		2.2.5 八进制（基数为8）计数系统
	2.3 数/字符串转换
	2.4 数的内部表示
		2.4.1 位
		2.4.2 位串
	2.5 有符号数与无符号数
	2.6 二进制数一些有用的特征
	2.7 符号扩展，零扩展，以及缩减
	2.8 饱和操作
	2.9 二进制编码的十进制表示法
	2.10 定点表示法
	2.11 比例数格式 
	2.12 有理数表示法
	2.13 获取更多信息
第3章 二进制算术语位运算
	3.1 二进制数与十六进制数的算术运算
		3.1.1 二进制加法
		3.1.2 二进制减法
		3.1.3 二进制乘法
		3.1.4 二进制除法
	3.2 位逻辑运算
	3.3 二进制数和位串的逻辑运算
	3.4 有用的位运算
		3.4.1 使用与运算检测串的各个位
		3.4.2 使用与运算来检测一组位是零/非零
		3.4.3 比较一个位串中的一组位
		3.4.4 使用逻辑与创建模-n计数器
	3.5 移位与循环移位
	3.6 位域与打包数据
	3.7 打包与解包数据
	3.8 获取更多信息
第4章 浮点表示法
	4.1 浮点运算简介
	4.2 IEEE浮点数格式 
		4.2.1 单精度浮点格式 
		4.2.2 双精度浮点格式
		4.2.3 扩展精度浮点格式 
	4.3 规格化与反向规格化数
	4.4 舍入
	4.5 特殊的浮点数
	4.6 浮点异常
	4.7 浮点运算
		4.7.1 浮点表示
		4.7.2 浮点加法与减法
		4.7.3 浮点乘法与除法
	4.8 获取更多信息
第5章 字符表示法
	5.1 字符数据
		5.1.1 ASCII字符集
		5.1.2 EBCDIC字符集
		5.1.3 双字节字符集
		5.1.4 Unicode 字符集
	5.2 字符串
		5.2.1 字符串格式
		5.2.2 字符串类型：静态，伪动态，以及动态字符串
		5.2.3 字符串引用计数
		5.2.4 Delphi/Kylix字符串
		5.2.5 创建你自己的字符串格式
	5.3 字符集合
		5.3.1 字符集合的幂集表示法
		5.3.2 字符集合的列表表示法
	5.4 设计你自己的字符集
		5.4.1 设计一种高效的字符集
		5.4.2 为数字分组字符码
		5.4.3 分组字母字符
		5.4.4 比较字母字符
		5.4.5 其他字符分组
	5.5 获取更多信息
第6章 内存组织与访问
	6.1 基本的系统组成部分
		6.1.1 系统总线
		6.1.2 地址总线
		6.1.3 控制总线
	6.2 内存物理组织
		6.2.1 位地址总线
		6.2.2 16位数据总线
		6.2.3 32位数据总线
		6.2.4 64位总线
		6.2.5 在非80x86处理器上访问小数据单位
	6.3 大端组织与小端组织
	6.4 系统时钟
		6.4.1 内存访问与系统时钟
		6.4.2 等待状态
		6.4.3 调整缓存内存
	6.5 CPU内存访问
		6.5.1 直接内存寻址模式
		6.5.2 间接寻址模式
		6.5.3 变址寻址模式
		6.5.4 比例变址寻址模式
	6.6 获取更多信息
第7章 复合数据类型与内存对象
	7.1 指针类型
		7.1.1 指针的实现
		7.1.2 指针与动态内存分配 
		7.1.3 指针操作与指针运算
	7.2 数组
		7.2.1 数组声明
		7.2.2 数组在内存中的表示
		7.2.3 访问数组元素
		7.2.4 多维数组
	7.3 记录/结构
		7.3.1 Pascal/Delphi中的记录
		7.3.2 C/C++中的记录
		7.3.3 HLA中的记录
		7.3.4 记录的内存存储
	7.4 判别式联合
		7.4.1 C/C++中的联合
		7.4.2 Pascal/Delphi/Kylix中的联合
		7.4.3 HLA中的联合
		7.4.4 联合的内存存储
		7.4.5 联合的其他用途
	7.5 获取更多信息
第8章 布尔逻辑与数字设计
	8.1 布尔代数
		8.1.1 布尔运算符
		8.1.2 布尔代数的公理
		8.1.3 布尔运算符优先级
	8.2 布尔函数与真值表
	8.3 函数号
	8.4 布尔表达式的代数运算
	8.5 标准型
		8.5.1 最小项之和标准型与真值表
		8.5.2 使用代数方法得到最小项之和标准型
		8.5.3 最大项之积标准型
	8.6 布尔函数化简
	8.7 但是，这些和计算机又有什么关系呢
		8.7.1 电子线路与布尔函数的对应
		8.7.2 组合电路
		8.7.3 时序与钟控逻辑
	8.8 获取更多信息
第9章 CPU体系结构
	9.1 CPU设计基础
	9.2 指令解码与执行：随机逻辑与微码
	9.3 指令执行详解
		9.3.1 mov指令
		9.3.2 add指令
		9.3.3 jnz指令
		9.3.4 loop指令
	9.4 并行——提高处理速度的关键
		9.4.1 预取队列
		9.4.2 妨碍预取队列性能的情况
		9.4.3 流水线操作——重叠执行多条指令
		9.4.4 指令调整缓存——提供访问内存的多条通路
		9.4.5 流水线相关
		9.4.6 超标量运算——并行执行指令
		9.4.7 乱序执行
		9.4.8 寄存器重命名
		9.4.9 甚长指令字体系结构
		9.4.10 并行处理
		9.4.11 多处理
	9.5 获取更多信息
第10章 指令集体系结构
	10.1 指令集设计的重要性
	10.2 指令设计基本目标
		10.2.1 选择指令长度
		10.2.2 规划未来
		10.2.3 选择指令
		10.2.4 给指令指派操作码
	10.3 Y86假想处理器
		10.3.1 Y86的限制
		10.3.2 Y86指令
		10.3.3 Y86的寻址模式
		10.3.4 Y86指令编码
		10.3.5 Y86指令编码举例
		10.3.6 扩展Y86指令集
	10.4 80x86指令编码
		10.4.1 编码指令操作码
		10.4.2 add指令编码的例子
		10.4.3 编码立即操作数
		10.4.4 8,16与32位操作数编码
		10.4.5 指令的替代编码
	10.5 指令集设计对程序员的意义
	10.6 获取更多信息
第11章 内存体系结构与组织
	11.1 内存层次结构
	11.2 内存层次结构是如何工作的
	11.3 内存子系统的相对性能
	11.4 高速缓存体系结构
		11.4.1 直接映射高速缓存
		11.4.2 全相联高速缓存
		11.4.3 n路组相联高速缓存
		11.4.4 高速缓存方案与数据访问类型的匹配
		11.4.5 缓存线替换策略
		11.4.6 写数据到内存中
		11.4.7 高速缓存使用与软件
	11.5 虚存，保护，以及页面调度
	11.6 颠簸
	11.7 NUMA与外围设备
	11.8 编写理解内存层次结构的软件
	11.9 运行时内存组织
		11.9.1 静态与动态对象，绑定，以及生命期
		11.9.2 代码，只读，以及常量段
		11.9.3 静态变量段
		11.9.4 未初始化存储段
		11.9.5 栈段
		11.9.6 堆段与动态内存分配
	11.10 获取更多信息
第12章 输入与输出（I/O）
	12.1 将CPU与外界相连
	12.2 将端口连接到系统的其他方式
	12.3 I/O机制
		12.3.1 内存映射输入输出
		12.3.2 输入输出与高速缓存
		12.3.3 I/O映射输入/输出
		12.3.4 直接内存访问
	12.4 输入输出速度等级
	12.5 系统总线与数据传输率
		12.5.1 PCI总线的性能
		12.5.2 ISA总线的性能
		12.5.3 AGP总线
	12.6 缓冲
	12.7 握手
	12.8 I/O端口的超时
	12.9 中断与轮询方式I/O
	12.10 保护模式操作与设备驱动程序
		12.10.1 设备驱动程序
		12.10.2 与设备驱动程序以及“文件”通信
	12.11 深入研究各种PC外设
	12.12 键盘
	12.13 标准PC并口
	12.14 串口
	12.15 磁盘驱动器
		12.15.1 软盘驱动器
		12.15.2 硬盘驱动器
		12.15.3 RAID系统
		12.15.4 Zin与其他光读软盘驱动器
		12.15.5 光驱
		12.15.6 CD-ROM，CD-R，CD-R/W，DVD，DVD-R，DVD-RAM与DVD-R/W驱动器
	12.16 磁带驱动器
	12.17 闪存
	12.18 RAM盘与关导体盘
	12.19 SCSI设备与控制器
	12.20 IDE/ATA接口
	12.21 大容量存储设备上的文件系统
		12.21.1 使用空闲空间位图管理文件
		12.21.2 文件分配表
		12.21.3 块表文件组织
	12.22 编写处理大容器存储设备上的数据的软件
		12.22.1 文件访问性能
		12.22.2 同步与异步I/O
		12.22.3 I/O类型的影响
		12.22.4 内存映射文件
	12.23 通用串行总线
		12.23.1 USB的设计
		12.23.2 USB的性能
		12.23.3 USB传输的类型
		12.23.4 USB设备驱动程序
	12.24 鼠标，触控板与其他指点设备
	12.25 操纵杆与游戏控制器
	12.26 声卡
		12.26.1 音频接口外设如何产生声音
		12.26.2 音频与MIDI文件格式
		12.26.3 编程处理音频设备
	12.27 获取更多信息
运用底层语言思想编写高级语言代码
附录A ASCII字符集

第二卷：运用底层语言思想编写高级语言代码（Volume 2:Thinking Low-Level,Writing High-Level）
★
作者：Randall Hyde

知识点 
1.	算法基础知识。 

致谢
引言
第1章 以底层语言思考，用高级语言编程
	1.1 关于编译器质量的误区
	1.2 最好还是学学汇编语言
	1.3 为何学习汇编语言并非绝对必要
	1.4 以底层语言思考
		1.4.1 编译器生成的机器码只会与送入的源代码质量一样
		1.4.2 协助编译器生成更好的机器码
		1.4.3 在用高级语言编程时，如何以汇编语言思考
	1.5 编程用高级语言
	1.6 假设条件
	1.7 不特定于某种语言的方法
	1.8 卓越代码的特征
	1.9 本卷涉及的环境
	1.10 获取更多信息
第2章 要不要学汇编语言
	2.1 学习汇编语言的障碍
	2.2 向《编程卓越之道》第二卷求援
	2.3 向高层汇编器求援
	2.4 HLA
	2.5 以高级语言思考，用底层语言编程
	2.6 汇编语言的编程范型——在底层思考
	2.7 《汇编语言编程艺术》及其他资源
第3章 高级语言程序员应具备的80x86知识
	3.1 学一种汇编语言很好，能学几种更好
	3.2 80x86汇编语言的语法
	3.3 80x86基本架构
		3.3.1 寄存器
		3.3.2 80x86通用寄存器
		3.3.3 80x86的EFLAGS寄存器
	3.4 文字常量
		3.4.1 二进制文字常量
		3.4.2 十进制文字常量
		3.4.3 十六进制文字常量
		3.4.4 字符与字符串文字常量
		3.4.5 浮点型文字常量
	3.5 汇编语言中的字面（符号）常量
		3.5.1 HLA中的字面常量
		3.5.2 Gas中的字面常量
		3.5.3 MASM和TASM中的字面常量
	3.6 80x86的寻址模式
		3.6.1 80x86的寄存器寻址
		3.6.2 立即寻址
		3.6.3 位移寻址
		3.6.4 寄存器间接寻址
		3.6.5 变址寻址
		3.6.6 比例变址寻址
	3.7 汇编语言的数据声明
		3.7.1 HLA的字节数据声明
		3.7.2 MASM和TASM的字节数据声明
		3.7.3 Gas的字节数据声明
		3.7.4 在汇编语言中访问字节变量
		3.7.5 16位和32位数据的声明
	3.8 在汇编语言中指定操作数尺寸
		3.8.1 HLA的类型强制
		3.8.2 MASM和TASM的类型强制
		3.8.3 Gas的类型强制
	3.9 80x86最简指令集
	3.10 获取更多信息
第4章 高级语言程序员应具备的PowerPC汇编知识
	4.1 学一种汇编语言很好，能学几种更好
	4.2 汇编语言的语法
	4.3 PowerPC基本架构
		4.3.1 通用整数寄存器
		4.3.2 通用浮点寄存器
		4.3.3 用户模式可访问的特殊寄存器
	4.4 文字常量
		4.4.1 二进制文字常量
		4.4.2 十进制文字常量
		4.4.3 十六进制文字常量
		4.4.4 字符和字符串文字常量
		4.4.5 浮点文字常量
	4.5 汇编语言中的字面常量
	4.6 PowerPC的寻址模式
		4.6.1 访问寄存器
		4.6.2 立即寻址
		4.6.3 PowerPC的内存寻址模式
	4.7 汇编语言的数据声明
	4.8 在汇编语言中指定操作数尺寸
	4.9 PowerPC最简指令集
	4.10 获取更多信息
第5章 编译器的操作与代码生成
	5.1 编程语言所用的文件类型
	5.2 编程语言的源文件
		5.2.1 源文件的记号化
		5.2.2 专门的源文件格式
	5.3 计算机语言处理器的类型
		5.3.1 纯解释器
		5.3.2 解释器
		5.3.3 编译器
		5.3.4 增量编译器
	5.4 转换过程
		5.4.1 词法分析与记号
		5.4.2 分析（语法分析阶段）
		5.4.3 中间代码生成阶段
		5.4.4 优化
		5.4.5 对比不同编译器的优化方案
		5.4.6 本机码生成
	5.5 编译器的输出
		5.5.1 编译器输出高级语言代码
		5.5.2 编译器输出汇编语言代码
		5.5.3 编译器输出目标文件
		5.5.4 编译器输出可执行文件
	5.6 目标文件的格式 
		5.6.1 COFF文件头
		5.6.2 COFF可选文件头
		5.6.3 COFF区域头
		5.6.4 COFF区域
		5.6.5 重定位区域
		5.6.6 调试与符号信息
		5.6.7 了解目标文件格式的其他信息
	5.7 可执行文件的格式 
		5.7.1 页、段和文件大小
		5.7.2 内部碎片
		5.7.3 那为什么还要为空间优化
	5.8 目标文件中的数据和代码对齐
		5.8.1 选择区域对齐值
		5.8.2 合并区域
		5.8.3 区域对齐的控制
		5.8.4 区域对齐与库模块
	5.9 链接器及其对代码的影响
	5.10 获取更多信息
第6章 分析编译器输出的工具
	6.1 背景知识
	6.2 让编译器输出汇编语言
		6.2.1 GNU和Borland编译器的汇编输出
		6.2.2 Visual C++的汇编输出
		6.2.3 汇编语言的输出示例
		6.2.4 分析编译器的汇编输出
	6.3 通过目标码工具分析编译器的输出
		6.3.1 Mircrosoft的dumpbin.exe工具
		6.3.2 FSF/GNU的objdump.exe工具
	6.4 通过反汇编器分析编译器的输出
	6.5 通过调试器分析编译器的输出
		6.5.1 使用集成开发环境带的调试器
		6.5.2 使用独立调试器
	6.6 比对两次编译的输出
		6.6.1 用diff比对代码修改前后的编译器输出
		6.6.2 人工对比
	6.7 获取更多信息
第7章 常量与高级语言
	7.1 文字常量与程序效率
	7.2 文字常量与明示常量的比较
	7.3 常量表达式
	7.4 明示常量与只读内存数据的比较
	7.5 枚举类型
	7.6 布尔常量
	7.7 浮点数常量 
	7.8 字符串常量
	7.9 复合数据类型的常量
	7.10 获取更多信息
第8章 变量
	8.1 运行时期的内存组织
		8.1.1 代码、常量和只读区域
		8.1.2 静态变量区域
		8.1.3 BSS区域
		8.1.4 栈区域
		8.1.5 堆区域与动态内存分配
	8.2 变量是什么
		8.2.1 属性
		8.2.2 绑定
		8.2.3 静态数据
		8.2.4 动态数据
		8.2.5 作用域
		8.2.6 生命期
		8.2.7 那么变量是何物
	8.3 变量的存储
		8.3.1 静态绑定与静态变量
		8.3.2 伪静态绑定和自动变量
		8.3.3 动态绑定与动态变量
	8.4 常见的基本数据类型
		8.4.1 整型变量
		8.4.2 浮点型/实数变量
		8.4.3 字符型变量
		8.4.4 布尔变量
	8.5 变量地址与高级语言
		8.5.1 对全局变量和静态变量分配存储空间
		8.5.2 使用自动变量减小偏移量
		8.5.3 中间变量的存储空间分配
		8.5.4 动态变量和指针的存储空间分配
		8.5.5 使用记录/结构减小指令偏移量尺寸
		8.5.6 寄存器变量
	8.6 内存中的变量对齐
		8.6.1 记录与对齐
	8.7 获取更多信息
第9章 数组
	9.1 何谓数组
	9.2 数组声明
		9.2.1 C、C++和Java的数组声明
		9.2.2 HLA的数组声明
		9.2.3 Pascal、Delphi和Kylix的数组声明
		9.2.4 以非整数下标值声明数组
	9.3 数组在内存中的表示
	9.4 数组元素的访问
	9.5 填充与打包的比较
	9.6 多维数组
		9.6.1 声明多维数组
		9.6.2 多维数组元素到内存的映射
		9.6.3 行优先顺序
		9.6.4 列优先顺序
		9.6.5 访问多维数组的元素
		9.6.6 行优先和列优先的模仿
		9.6.7 提高应用程序访问数组的效率
	9.7 动态数组与静态数组的比较
		9.7.1 一维伪动态数组
		9.7.2 多维伪动态数组
		9.7.3 纯动态数组
	9.8 获取更多信息
第10章 字符串
	10.1 字符串格式 
		10.1.1 以0结尾的字符串
		10.1.2 带长度值前缀的字符串格式
		10.1.3 7位字符的字符串
		10.1.4 HLA字符串格式
		10.1.5 基于描述记录的字符串格式
	10.2 静态、伪动态和动态字符串
		10.2.1 静态字符串
		10.2.2 伪动态字符串
		10.2.3 动态字符串
	10.3 字符串的引用计数
	10.4 Delphi/Kylix字符串格式
	10.5 在高级语言中使用字符串
	10.6 字符串中的字符数据
	10.7 获取更多信息
第11章 指针
	11.1 指针的定义与揭秘
	11.2 高级语言的指针实现
	11.3 指针与动态内存分配
	11.4 指针操作与指针算术
		11.4.1 指针与整数求和
		11.4.2 指针与整数之差
		11.4.3 指针与指针之差
		11.4.4 指针比较
		11.4.5 指针与“与/或”逻辑
		11.4.6 对指针的其他操作
	11.5 内存分配的简单示例
	11.6 垃圾收集
	11.7 操作系统与内存分配
	11.8 堆的内存开销
	11.9 常见的指针问题
		11.9.1 所用的指针未初始化
		11.9.2 所用的指针含有非法值
		11.9.3 存储空间释放后仍试图继续使用之
		11.9.4 程序用过某存储空间后却不释放
		11.9.5 使用不当的数据类型访问间接数据
	11.10 获取更多信息 
第12章 记录、联合和类
	12.1 记录
		12.1.1 在各种语言中声明记录
		12.1.2 记录的例化
		12.1.3 编译时期初始化记录数据
		12.1.4 记录的内存表示
		12.1.5 使用记录改善内存效能
		12.1.6 动态记录类型和数据库
	12.2 判别式联合
		12.2.1 在各种语言中声明联合
		12.2.2 联合的内存表示
		12.2.3 联合的其他用法
	12.3 变数类型
	12.4 命名空间
	12.5 类与对象
		12.5.1 类和对象的比较
		12.5.2 C++中的简单类声明
		12.5.3 虚方法表
		12.5.4 共享虚方法表
		12.5.5 类的继承
		12.5.6 类的多态
		12.5.7 类、对象和性能
	12.6 获取更多信息
第13章 算术与逻辑表达式
	13.1 算术表达式与计算机架构
		13.1.1 基于栈的机器
		13.1.2 基于累加器的机器
		13.1.3 基于寄存器的机器
		13.1.4 算术表达式的典型形式
		13.1.5 三地址架构
		13.1.6 双地址架构
		13.1.7 架构差异与写代码的关系
		13.1.8 复杂表达式的处理
	13.2 算术语句的优化
		13.2.1 常量折叠
		13.2.2 常量传播
		13.2.3 死码消除
		13.2.4 公共子表达式消除
		13.2.5 强度削弱
		13.2.6 归纳变量
		13.2.7 循环不变体
		13.2.8 优化器与程序员
	13.3 算术表达式的副效应
	13.4 包含副效应：序列点
	13.5 避免让副效应造成麻烦
第14章 控制结构与程序判定
	14.1 控制之类的操作较计算慢
	14.2 底层控制结构入门
	14.3 goto语句
	14.4 goto语句的限制形式
	14.5 if语句
		14.5.1 提高某些if/else语句的效率
		14.5.2 强制在if语句中全面布尔求值
		14.5.3 强制在if语句中短路布尔求值
	14.6 switch/cast语句
		14.6.1 switch/case语句的语义
		14.6.2 跳转表与链式比较
		14.6.3 switch/case语句的其他实现方案
		14.6.4 switch语句的编译器输出
	14.7 获取列多信息
第15章 迭代控制结构
	15.1 while循环
		15.1.1 在while循环中强制全面布尔求值
		15.1.2 在while循环中强制短路布尔求值
	15.2 repeat...until式的循环
		15.2.1 在repeat...until循环中强制全面布尔求值
		15.2.2 在repeat...until循环中强制短路布尔求值
	15.3 forever...endfor式的循环
		15.3.1 在forever循环中强制全面布尔求值
		15.3.2 的forever循环中强制短路布尔求值
	15.4 定次的for循环
	15.5 获取更多信息
第16章 函数与过程
	16.1 简单的函数与过程调用
		16.1.1 保存返回地址
		16.1.2 开销的其他来由
	16.2 叶函数/过程
	16.3 宏和内联函数
	16.4 向函数/过程传递参数
	16.5 活动记录和栈
		16.5.1 活动记录的构成
		16.5.2 对局部变量指定偏移量
		16.5.3 对参数指定偏移量
		16.5.4 参数和局部变量的访问
	16.6 参数传递机制
		16.6.1 传递值
		16.6.2 传递引用
	16.7 函数返回值
	16.8 获取更多信息
软件工程学
附录A 80x86和PowerPC处理器家庭的概要对比
	A.1 CISC和RISC的架构差异
		A.1.1 每条指令完成的工作量
		A.1.2 指令尺寸
		A.1.3 时钟速度和每条指令的时钟周期数
		A.1.4 内存访问和寻址模式
		A.1.5 寄存器
		A.1.6 立即数/常量
		A.1.7 栈
	A.2 编译器和应用程序二进制接口
	A.3 为两种架构卓越编程
