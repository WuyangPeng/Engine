C++ 模板元编程（C++ Template Metaprogramming）

官方网站：
http://www.boost-consulting.com/mplbook （已失效）。
http://www.crystalclearsoftware.com/cgi-bin/boost_wiki/wiki.pl?CPP_Template_Metaprogramming_Book_-_Answers_Page

★★★★
作者： David Abrahams、Aleksey Gurtovoy

知识点 
1.	C++模板基础知识。 

序言
前言
	补充材料
	试验
致谢
	Dave的致谢
	Aleksey的致谢
第1章 概述	
	1.1 起步走
		★ 一个元程序写好了，只要它能够工作，你就大可以放心使用，而不必关心其底层工作机制究竟是怎样的。
	1.2 元程序的概念
		★  元程序就是用于操纵代码的程序。
	1.3 在宿主语言中进行元编程
	1.4 在C++中进行元编程
		1.4.1 数值计算
		1.4.2 类型计算
	1.5 为何进行元编程
		1.5.1 替代方案1：运行期计算
		1.5.2 替代方案2：用户分析
		1.5.3 为何进行C++元编程
			★  用户可以径自使用领域语言，而无需学习一种异质的语法，而且也不会打断原先代码的流程。
			★  将元程序与其他代码、尤其是其他元程序进行接口连接，会变得平滑得多。
			★  无需附加的生成步骤。
	1.6 何时进行元编程
		★  你希望代码根据问题领域的抽象进行表达。
		★  如果不使用模板元编程的话，你需要编写大量刻板的实现代码。
		★  你需要基于组件的类型参数的属性来选择组件实现。
		★  你希望利用C++中泛型编程的极富价值的特性，同时无需付出效率上的代价。
		★  你希望全部在C++语言内做这件事，而无需使用第三方的工具或定制的源代码生成器。
	1.7 为何需要元编程程序库
		★  质量。
		★  复用。
		★  移植性。
		★  乐趣。
		★  生产率。
第2章 Traits和类型操纵
	2.1 类型关联
		★  可以在编译期进行操纵的实体称为元数据，大致可以分为两个范畴：类型和非类型。
		2.1.1 采用一种直接的方式
		2.1.2 采用一种迂回方式
			★  我们可以通过引入一个额外的间接层来解决任何问题。
		2.1.3 寻找一个捷径
	2.2 元函数
		★  traits模板展示了两个显著的特征：
			1. 特化。
			2. 多个“返回值”。
		★  “The blob”是一种反模式，因为它降低了一个程序的总体互操作能力或其各组件彼此平滑协作的能力。
		★  这种允许不同的实参类型可交换地使用的属性，称为多态。
	2.3 数值元函数
	2.4 在编译期作出选择
		2.4.1 进一步讨论iter_swap
		2.4.2 美中不足
		2.4.3 另一个美中不足
		2.4.4 “美中不足”之外覆器
	2.5 BoostTypeTraits程序库概览
		2.5.1 一般知识
		2.5.2 主类型归类（PrimaryTypeCategorization）
		2.5.3 次类型归类（SecondaryTypeCategorization)
		2.5.4 类型属性
		2.5.5 类型之间的关系
		2.5.6 类型转化
	2.6 无参元函数
		★  一个无参元函数可以是任何类型，不管它是一个普通的类还是一个类模板特化。
	2.7 元函数的定义
		★  一个元函数可以是一个类模板，它的所有参数都是类型或者一个类，带有一个名为“type”的可公开访问的嵌套结果类型。
	2.8 历史
	2.9 细节
		2.9.1 特化
		2.9.2 实例化
		2.9.3 多态
	2.10 练习
第3章 深入探索元函数
	3.1 量纲分析
		3.1.1 量纲的表示
		3.1.2 物理量的表示
		3.1.3 实现加法和减法
		3.1.4 实现乘法
			★	元函数类是这样的一种类：内嵌有一个可公开访问的名为apply的元函数。
			★	虽然元函数是模板而非类型，但是元函数类却以一个普通的非模板类将其包覆起来，使其成为一个类型。
				因为元函数操作和返回的都是类型，所以元函数类也可被作为参数传递给另一个元函数，且元函数也可以返回一个元函数类。
		3.1.5 实现除法
	3.2 高阶元函数
		★	使用函数去操纵其他函数：高阶函数式编程。
		★	操纵其他函数的函数被称为高阶函数。
		★	高阶元函数：即为一个操纵其他元函数的元函数。
	3.3 处理占位符
		3.3.1 lambda元函数
		3.3.2 apply元函数
	3.4 lambda的其他能力
		3.4.1 偏元函数应用
			★	在函数式编程世界中，将一组实参绑定到某个函数的形参的一个子集的过程被称为偏函数应用。
		3.4.2 元函数复合
	3.5 Lambda的细节
		3.5.1 占位符
			★	占位符是一个形式为mpl::arg<N>的元函数类。
			★	在某个给定的模板特化中第n个出现的匿名占位符会被替换为_n。
		3.5.2 占位符表达式的定义
			★	一个占位符表达式是：一个占位符。或者一个至少有一个参数是占位符表达式的模板特化。
		3.5.3 Lambda和非元函数模板
		3.5.4“懒惰”的重要性
			★	元函数接收了参数后仍可以被延迟调用。
			★	当一个元函数的结果只是被选择性地使用时，我们可以使用惰性评估来减少编译时间。
	3.6 细节
		★	元函数转发：使用公有派生将基类元函数中内嵌的::type暴露给用户的技术。
		★	元函数类：内嵌有名为apply元函数的类。
		★	高阶函数：一种操作或返回函数的函数。
		★	lambda表达式：有两个基本形式：元函数类和占位符表达式。
		★	占位符表达式：通过使用占位符达成偏元函数应用和元函数复合。
		★	惰性评估：一种将计算推迟到其结果被要求时的策略，从而可以避免任何不必要的计算以及任何有关的不必要的错误。
	3.7 练习
第4章 整型外覆器和操作
	4.1 布尔外覆器和操作
		4.1.1 类型选择
		4.1.2 缓式类型选择
		4.1.3 逻辑运算符
	4.2 整数外覆器和运算
		4.2.1 整型运算符
		4.2.2 _c整型速记法
	4.3 练习
第5章 序列和迭代器
	5.1 Concepts
	5.2 序列和算法
	5.3 迭代器
	5.4 迭代器Concepts
		5.4.1 前向迭代器
		5.4.2 双向迭代器
		5.4.3 随机访问迭代器
	5.5 序列Concepts
		5.5.1 序列遍历Concepts
		5.5.2 可扩展性
		5.5.3 关联式序列
		5.5.4 可扩展的关联式序列
	5.6 序列相等性
	5.7 固有的序列操作
	5.8 序列类
		5.8.1 list
		5.8.2 vector
		5.8.3 deque
		5.8.4 range_c
		5.8.5 map
		5.8.6 set
		5.8.7 iterator_range
	5.9 整型序列外覆器
	5.10 序列派生
	5.11 编写你自己的序列
		5.11.1 构建tiny序列
		5.11.2 迭代器的表示
		5.11.3 为tiny实现at
		5.11.4 完成tiny_iterator的实现
		5.11.5 begin和end
		5.11.6 加入扩充性
	5.12 细节
	5.13 练习
第6章 算法
	6.1 算法、惯用法、复用和抽象
	6.2 MPL中的算法
	6.3 插入器
	6.4 基础序列算法
	6.5 查询算法
	6.6 序列构建算法
	6.7 编写你自己的算法
	6.8 细节
	6.9 练习
第7章 视图与迭代器适配器
	7.1 一些例子
		7.1.1 对从序列元素计算出来的值进行比较
		7.1.2 联合多个序列
		7.1.3 避免不必要的计算
		7.1.4 选择性的元素处理
	7.2 视图Concept
	7.3 迭代器适配器
	7.4 编写你自己的视图
	7.5 历史
	7.6 练习
第8章 诊断
	8.1 调试错误
		8.1.1 实例化回溯
		8.1.2 错误消息格式化怪癖
	8.2 使用工具进行诊断分析
		8.2.1 听取他者的意见
		8.2.2 使用导航助手
		8.2.3 清理场面
	8.3 有目的的诊断消息生成
		8.3.1 静态断言 
		8.3.2 MPL静态断言 
		8.3.3 类型打印
	8.4 历史
	8.5 细节
	8.6 练习
第9章 跨越编译期和运行期边界
	9.1 for_each
		9.1.1 类型打印
		9.1.2 类型探访
	9.2 实现选择
		9.2.1 if语句
		9.2.2 类模板特化
		9.2.3 标签分派
	9.3 对象生成器
	9.4 结构选择
	9.5 类复合
	9.6（成员）函数指针作为模板实参
	9.7 类型擦除
		9.7.1 一个例子
		9.7.2 一般化
		9.7.3“手工”类型擦除
		9.7.4 自动类型擦除
		9.7.5 保持接口
	9.8 奇特的递归模板模式
		9.8.1 生成函数
		9.8.2 管理重载决议
	9.9 显式管理重载集
	9.10 sizeof技巧
	9.11 总结
	9.12 练习
第10章 领域特定的嵌入式语言
	10.1 一个小型语言
	10.2 路漫漫其修远兮
		10.2.1 Make工具语言
		10.2.2 巴科斯——诺尔模式
		10.2.3 YACC
		10.2.4 DSL摘要
	10.3 DSL
	10.4 C++用作宿主语言
	10.5 Blitz++和表达式模板
		10.5.1 问题
		10.5.2 表达式模板
		10.5.3 更多的Blitz++魔法
	10.6 通用DSEL
		10.6.1 具名参数
		10.6.2 构建匿名函数
	10.7 Boost Spirit程序库
		10.7.1 闭包
		10.7.2 子规则
	10.8 总结
	10.9 练习
第11章 DSEL设计演练
	11.1 有限状态机
		11.1.1 领域抽象
		11.1.2 符号
	11.2 框架设计目标
	11.3 框架接口基础
	11.4 选择一个DSL
		11.4.1 转换表
		11.4.2 组装成一个整体
	11.5 实现
	11.6 分析
	11.7 语言方向
	11.8 练习
附录A 预处理元编程简介
附录B typename和template关键字
附录C 编译期性能
附录D MPL可移植性摘要