计算机系统：系统架构与操作系统的高度集成（Computer Systems:An Integrated Approach to Architecture and Operating Systems）

★
作者：  Umakishore Ramachandran、William D.Leahy Jr.

前言
	为什么在计算机系统领域需要一本新书
	教学风格
	本书的结构和可能的阅读路径
	本教材在计算机科学课程体系中的位置
	讲授系统的集成课程的补充材料
	在补充材料中包含的样例实验
	注意
	致谢
第1章 概述
	1.1 盒子里有什么
	1.2 计算机系统中的抽象层次
	1.3 操作系统的作用
	1.4 盒子里正在发生什么事
		1.4.1 在计算机上启动应用程序
	1.5 计算机硬件的演化
	1.6 操作系统的演化
	1.7 本书导读
	练习题
	参考文献注释和扩展阅读
第2章 处理器体系结构
	2.1 处理器设计涉及什么
	2.2 如何设计指令集
	2.3 常见的高级语言功能集
	2.4 表达式和赋值语句
		2.4.1 操作数放在哪里
		2.4.2 在指令中如何指定内存地址
		2.4.3 每个操作数应该有多宽
		2.4.4 字节序
		2.4.5 操作数打包以及字操作数的对齐
	2.5 高级数据抽象
		2.5.1 结构
		2.5.2 数组
	2.6 条件语句和循环
		2.6.1 if-then-else语句
		2.6.2 switch语句
		2.6.3 循环语句
	2.7 检查点
	2.8 编译函数调用
		2.8.1 调用者的状态
		2.8.2 过程调用剩余的工作
		2.8.3 软件惯例
		2.8.4 活动记录
		2.8.5 递归
		2.8.6 帧指针
	2.9 指令集体系结构选择
		2.9.1 额外的指令
		2.9.2 额外的寻址模式
		2.9.3 体系结构类型
		2.9.4 指令格式
	2.10 LC-2200指令集
		2.10.1 指令格式
		2.10.2 LC-2200寄存器组
	2.11 影响处理器设计的问题
		2.11.1 指令集
		2.11.2 应用程序对指令集设计的影响
		2.11.3 其他驱动处理器设计的问题
	小结
	练习题
	参考文献注释和扩展阅读
第3章 处理器实现
	3.1 体系结构与实现
	3.2 处理器实现涉及什么
	3.3 重要的硬件概念
		3.3.1 电路
		3.3.2 数据通路的硬件资源
		3.3.3 边沿触发逻辑
		3.3.4 连接数据通路元件
		3.3.5 基于总线的设计
		3.3.6 有限状态机
	3.4 数据通路设计
		3.4.1 ISA与数据通路宽度
		3.4.2 时钟脉冲宽度
		3.4.3 检查点
	3.5 控制单元设计
		3.5.1 ROM加状态寄存器
		3.5.2 FETCH宏状态
		3.5.3 DECODE宏状态
		3.5.4 EXECUTE宏状态：ADD指令（R型指令部分)
		3.5.5 EXECUTE宏状态：NAND指令（R型指令部分)
		3.5.6 EXECUTE宏状态：JALR指令（J型指令部分)
		3.5.7 EXECUTE宏状态：LW指令（I型指令部分)
		3.5.8 EXECUTE宏状态：SW和ADDI指令（I型指令部分)
		3.5.9 EXECUTE宏状态：BEQ指令（I型指令部分） 
		3.5.10 设计微程序中的条件分支
		3.5.11 再谈DECODE宏状态
	3.6 控制单元设计的另一种选择
		3.6.1 微程序控制
		3.6.2 硬连线控制
		3.6.3 在两种控制设计风格中选择
	小结
	历史回顾
	练习题
	参考文献注释和扩展阅读
第4章 中断、陷入及异常
	4.1 程序执行中的不连续性
	4.2 处理程序不连续性
	4.3 处理程序不连续性的体系结构改进
		4.3.1 修改FSM
		4.3.2 一个简单的中断处理过程
		4.3.3 处理级联中断
		4.3.4 从处理过程中返回
		4.3.5 检查点
	4.4 处理程序不连续性的硬件细节
		4.4.1 中断的数据通路细节
		4.4.2 获得处理过程地址的细节
		4.4.3 保存/恢复栈
	4.5 信息汇总
		4.5.1 体系结构和硬件改进总结
		4.5.2 工作中的中断机制
	小结
	练习题
	参考文献注释和扩展阅读
第5章 处理器性能与流水线处理器的设计
	5.1 时间和空间性能指标 
	5.2 指令频率
	5.3 基准测试程序
	5.4 提升处理器的性能
	5.5 加速比
	5.6 提升处理器的吞吐量
	5.7 流水线简介
	5.8 指令处理流水线
	5.9 简单指令流水线的问题
	5.10 修正指令流水线里的问题
	5.11 指令流水线的数据通路元件
	5.12 针对流水线的体系结构与实现
		5.12.1 指令穿过流水线的过程详解
		5.12.2 流水线寄存器的设计
		5.12.3 各个阶段的实现
	5.13 冒险
		5.13.1 结构性冒险
		5.13.2 数据冒险
		5.13.3 控制冒险
		5.13.4 冒险总结
	5.14 在流水线处理器里处理程序不连续性
	5.15 处理器设计的高级话题
		5.15.1 指令级并行
		5.15.2 更深的流水线
		5.15.3 在乱序执行下再次讨论程序不连续性
		5.15.4 管理共享资源
		5.15.5 功耗
		5.15.6 多核处理器设计
		5.15.7 Intel Core微架构：一个流水线
	小结
	历史回顾
	练习题
	参考文献注释和扩展阅读
第6章 处理器调度
	6.1 引言
	6.2 程序和进程
	6.3 调度环境
	6.4 调度基础
	6.5 性能指标
	6.6 非抢占式调度算法
		6.6.1 先到先服务
		6.6.2 最短作业优先
		6.6.3 优先级
	6.7 抢占式调度算法
		6.7.1 轮转调度器
	6.8 结合优先级和抢占
	6.9 元调度器
	6.10 评价
	6.11 调度对处理器体系结构的影响
	小结和展望
	Linux调度器―一个案例研究
	历史回顾
	练习题
	参考文献注释和扩展阅读
第7章 内存管理技术
	7.1 内存管理器提供的功能
	7.2 内存管理的简单方案
	7.3 内存分配方案
		7.3.1 固定尺寸分区
		7.3.2 变长分区
		7.3.3 缩并
	7.4 分页虚拟内存
		7.4.1 页表
		7.4.2 支持分页的硬件 
		7.4.3 页表的建立 
		7.4.4 虚拟和物理内存的相对大小
	7.5 分段虚拟内存
		7.5.1 支持分段的硬件
	7.6 分页和分段的比较
		7.6.1 解读CPU生成的地址
	小结
	历史回顾
	MULTICS
	Intel的内存体系结构
	练习题
	参考文献注释和扩展阅读
第8章 页式内存管理
	8.1 按需分页
		8.1.1 按需分页的硬件
		8.1.2 页错误处理程序
		8.1.3 按需分页内存管理的数据结构
		8.1.4 页错误解析
	8.2 进程调度器和内存管理器间交互
	8.3 页替换策略
		8.3.1 Belady的Min算法
		8.3.2 随机替换 
		8.3.3 先进先出策略
		8.3.4 最近最少使用策略
		8.3.5 第二次机会页替换算法
		8.3.6 页替换算法回顾
	8.4 优化内存管理
		8.4.1 空闲页帧池
		8.4.2 颠簸
		8.4.3 工作集
		8.4.4 颠簸控制 
	8.5 其他考虑
	8.6 旁路转换缓存
		8.6.1 TLB的地址转换
	8.7 内存管理的高级话题
		8.7.1 多级页表
		8.7.2 局部页表项的访问权限
		8.7.3 反向页表
	小结
	练习题
	参考文献注释和扩展阅读
第9章 分级存储体系
	9.1 缓存的概念
	9.2 局部性原理 
	9.3 基本术语
	9.4 多级存储层次
	9.5 缓存结构
	9.6 直接映射缓存结构
		9.6.1 缓存查找
		9.6.2 缓存项中的字段
		9.6.3 用于直接映射缓存的硬件
	9.7 流水线处理器设计的影响
	9.8 缓存读/写算法 
		9.8.1 CPU对缓存的读访问
		9.8.2 CPU对缓存的写访问
	9.9 处理器流水线中的缓存缺失处理
		9.9.1 在流水线性能上缓存缺失对内存延迟的影响
	9.10 利用空间局部性提高缓存性能
		9.10.1 增加块大小对性能的影响
	9.11 灵活的布局策略
		9.11.1 全相关缓存
		9.11.2 组相关缓存
		9.11.3 组相关的极端情况
	9.12 指令和数据缓存
	9.13 降低缺失损失
	9.14 缓存替换的策略
	9.15 缺失类型简要说明
	9.16 TLB和缓存整合
	9.17 缓存控制器
	9.18 虚拟索引物理标记的缓存
	9.19 缓存设计因素概述
	9.20 主存的设计因素
		9.20.1 简单的主存
		9.20.2 与缓存块大小相匹配的主存和总线
		9.20.3 交错式内存
	9.21 现代主存系统分析
		9.21.1 页式DRAM
	9.22 分级存储体系的性能影响
	小结
	现代处理器的分级存储体系（一个例子）
	练习题
	参考文献注释和扩展阅读
第10章 输入/输出和稳定性存储
	10.1 CPU和I/O设备间的通信
		10.1.1 设备控制器
		10.1.2 内存映射I/O
	10.2 程控I/O
	10.3 DMA
	10.4 总线
	10.5 I/O处理器
	10.6 设备驱动
		10.6.1 例子
	10.7 外围设备
	10.8 磁盘存储器
		10.8.1 磁盘技术的传奇故事
	10.9 磁盘调度算法 
		10.9.1 先到先服务
		10.9.2 最短寻道时间优先
		10.9.3 SCAN
		10.9.4 C-SCAN
		10.9.5 LOOK和C-LOOK
		10.9.6 磁盘调度总结
		10.9.7 算法比较
	10.10 固态硬盘
	10.11 I/O总线和设备驱动的演化
		10.11.1 设备驱动的动态负载
		11.11.2 信息汇总
	小结
	练习题
	参考文献注释和扩展阅读
第11章 文件系统
	11.1 属性
	11.2 在磁盘子系统上实现文件系统的设计选择
		11.2.1 连续分配
		11.2.2 带有溢出区域的连续分配
		11.2.3 链接分配
		11.2.4 文件分配表
		11.2.5 索引分配
		11.2.6 多级索引分配
		11.2.7 混合索引分配
		11.2.8 不同分配策略的比较
	11.3 信息汇总
		11.3.1 索引节点
	11.4 文件系统的组件
		11.4.1 创建、写入文件的剖析
	11.5 各种子系统的交互
	11.6 文件系统在物理媒介上的布局
		11.6.1 内存中的数据结构
	11.7 处理系统崩溃
	11.8 其他物理媒介上的文件系统
	11.9 现代文件系统一览
		11.9.1 Linux
		11.9.2 Mircosoft Windows
	小结
	练习题
	参考文献注释和扩展阅读
第12章 多线程编程与多处理器
	12.1 为什么需要多线程
	12.2 线程所需的编程支持
		12.2.1 线程创建和终止
		12.2.2 线程之间的通信
		12.2.3 读/写冲突、竞争条件及不确定性
		12.2.4 线程之间的同步
		12.2.5 线程库中数据类型的内部表示
		12.2.6 简单的编程示例
		12.2.7 死锁和活锁
		12.2.8 条件变量
		12.2.9 视频处理示例的完整解决方案
		12.2.10 解决方案的讨论
		12.2.11 重新检查条件
	12.3 线程函数调用和多线程编程概念总结
	12.4 线程编程的一些注意事项
	12.5 使用线程作为软件结构抽象
	12.6 POSIX pthread库调用总结
	12.7 操作系统对线程的支持
		12.7.1 用户级线程
		12.7.2 内核级线程
		12.7.3 Solaris线程：一个内核级线程例子
		12.7.4 线程和库
	12.8 在单处理器上的多线程的硬件支持
		12.8.1 线程创建、终止以及线程间的通信 
		12.8.2 线程之间的同步
		12.8.3 原子的Test-and-Set指令
		12.8.4 使用Test-and-Set指令的Lock算法 
	12.9 多处理器
		12.9.1 页表
		12.9.2 分组存储体系
		12.9.3 保证原子性
	12.10 高级话题
		12.10.1 操作系统话题
		12.10.2 架构话题
		12.10.3 未来之路：多核与众核架构
	小结
	历史回顾
	练习题
	参考文献注释和扩展阅读
第13章 网络与网络协议基础知识
	13.1 预备知识
	13.2 基本术语
	13.3 网络软件
	13.4 协议栈
		13.4.1 因特网协议栈
		13.4.2 OSI模型
		13.4.3 分层的实际问题
	13.5 应用层
	13.6 传输层
		13.6.1 停止并等待协议
		13.6.2 流水线协议 
		13.6.3 可靠的流水线协议 
		13.6.4 处理传输错误
		13.6.5 因特网上的传输协议
		13.6.6 传输层总结
	13.7 网络层
		13.7.1 路由算法
		13.7.2 因特网寻址
		13.7.3 网络服务模式
		13.7.4 网络路由与转发
		13.7.5 网络层总结
	13.8 链路层和局域网
		13.8.1 以太网
		13.8.2 CSMA/CD
		13.8.3 IEEE 802.3
		13.8.4 无线局域网与IEEE 802.11
		13.8.5 令牌环
		13.8.6 其他链路层协议
	13.9 网络硬件
	13.10 协议栈各层之间的关系
	13.11 用于数据包传输的数据结构
		13.11.1 TCP/IP 包头
	13.12 消息传输时间
	13.13 协议层功能总结
	13.14 网络软件与操作系统
		13.14.1 套接字库
		13.14.2 在操作系统中实现协议栈
		13.14.3 网络设备驱动程序
	13.15 使用UNIX套接字进行网络编程
	13.16 网络服务与高层协议 
	小结
	历史回顾
	练习题
	参考文献注释和扩展阅读
第14章 尾声：旅途回顾
	14.1 处理器设计
	14.2 进程 
	14.3 虚拟内存系统和内存管理
	14.4 分组存储体系
	14.5 并行系统
	14.6 输入/输出系统
	14.7 永久性存储
	14.8 网络
	结束语
附录A 使用UNIX套接字进行网络编程