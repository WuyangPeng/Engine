C++ API设计（API Design for C++）

官方网站：
http://APIBook.com、 http://www.apidiff.com/en/。

★★★  
作者：Martin Reddy

知识点 
1.	编写健壮而优雅的应用程序编程接口。 

代码
1.	hide_class（2.2 隐藏实现细节）。
2.	coord2d_template（2.4 易用性）。
3.	shared_pointer（2.4 易用性）。
4.	callback_instance（2.5 松耦合）。
5.	callback_static（2.5 松耦合）。
6.	pimpl_bad（3.1 Pimpl惯用法）。
7.	pimpl_good（3.1 Pimpl惯用法）。
8.	pimpl_boost（3.1 Pimpl惯用法）。
9.	opaque_pointer（3.1 Pimpl惯用法）。
10.	singleton（3.2 单例）。
11.	factory_simple（3.3 工厂模式）。
12.	factory_extensible（3.3 工厂模式）。
13.	proxy_simple（3.4 API包装器模式）。
14.	proxy_interface（3.4 API包装器模式）。
15.	adapter（3.4 API包装器模式）。
16.	facade（3.4 API包装器模式）。
17.	observer（3.5 观察者模式）。

要点
1.	API是软件组件的逻辑接口，隐藏了实现这个接口所需的内部细节。（1.1 什么是API）
2.	API描述了其他工程师构建他们的应用软件所使用的软件。
	因此，API必须拥有良好的设计、文档、回归测试，并且保证发布之间的稳定性。（1.2 API设计上有什么不同）
3.	优质的API应该设计精巧且实用性强。它不仅能带来愉悦的使用体验，且能与各种应用程序完美融合，甚至让使用者感觉不到其存在。（2.1 问题域建模）
4.	类的数据成员应该始终声明为私有的，而不是公有的或受保护的。（2.2 隐藏实现细节）
5.	永远不要返回私有数据成员的非const指针或引用。这会破坏封装性。（2.2 隐藏实现细节）
6.	谨记以下几点原则：（2.3 最小完备性）
	（1）如果类包含任一虚函数，那么必须将析构函数声明为虚函数。
	（2）一定要编写文档，说明类的方法是如何相互调用的。
	（3）绝不在构造函数或析构函数中调用虚函数，这些调用不会指向子类。
7.	除非确实需要#include类的完整定义，否则应该为类使用前置声明。（2.5 松耦合）

第1章 API简介
	★	C++ API包含如下的元素：
		1.	头文件。
		2.	类库。
		3.	文档。
	★	API开发中的一些关键因素：
		1.	API是为开发者设计的接口，如同GUI是为用户设计的接口一样。
		2.	多个应用程序可以共享一个API。
		3.	修改API时，必须尽可能保证向后兼容。
		4.	出于向后兼容的需求，一定要具有变更控制流程。
		5.	API的生存周期一般都比较长。
		6.	在编写API时，良好的文档必不可少，特别是当不提供实现的源代码时。
		7.	自动化测试同样也很重要。
	★	构建API带来以下好处：
		1.	隐藏实现。
		2.	延长寿命。
		3.	促进模块化。
		4.	减少代码重复。
		5.	消除硬编码假设。
		6.	易于改变实现。
		7.	易于优化。
	★	何时应该避免使用API：
		1.	许可证限制。
		2.	功能不匹配。
		3.	缺少源代码。
		4.	缺乏文档。
	★	每当于创建一个文件格式或者客户端/服务器协议时，同时也要为其创建API。
		这样，规范的细节以及未来的任何变更都将是集中且隐蔽的。
第2章 特征
	★	创建API的主要原因是隐藏所有的实现细节，以免将来修改API对已有客户造成影响。有两种技巧可以达到此目标：物理隐藏和信息隐藏。
	★	声明告诉编译器某个标识符的名称及类型。定义提供该标识符的完整细节，即它是一个函数还是一块内存区域。
	★	物理隐藏表示将内部细节（.cpp）和公有接口（.h）分离，存储在不同的文件中。
	★	封装是将API的公有接口与其底层实现分离的过程。
	★	逻辑隐藏指的是使用C++语言中受保护的和私有的访问控制从而限制访问内部细节。
	★	使用getter/setter惯用法与直接暴露成员变量相比，还有以下额外的好处：
		1.	有效性验证。
		2.	惰性求值。
		3.	缓存。
		4.	额外的计算。
		5.	通知。
		6.	调试。
		7.	同步。
		8.	更精细的访问控制。
		9.	维护
	★	将私有功能声明为.cpp文件中的静态函数，而不要将其作为私有方法暴露在公开的头文件中。（更好的做法是使用Pimpl惯用法）
	★	谨记奥卡姆剃刀原理：若无必要，勿增实体。
	★	当不确定是否需要某个接口时，就不要提供此接口。
		1.	你想要添加的通用性可能永远不会用到。
		2.	如果某天用到了想要添加的通用性，那时你可能已经掌握了更多API的设计知识，并可能有了与最初设想方案不同的解决方案。
		3.	如果你确实需要添加新功能，那么简单的API比复杂的API更容易添加新功能。
	★	应该保证API尽量简单：类及类中的公有成员暴露得越少越好。
		这样做的好处是API会更易于理解，更易于用户记住API模型，而且更易于调试。
	★	疑惑之时，果断弃之！精简API中公有的类和函数。
	★	继承十分强大，但仍要意识到其潜在的隐患：
		1.	对基类看似无害的修改可能会给客户带来不利的影响。
		2.	客户可能会以你根本无法预料的方式使用API。
		3.	客户可能采用不正确的或易于出错的方式扩展API。
		4.	重写函数可能破坏类的内部完整性。
	★	C++中使用虚函数时还要注意以下常见问题：
		1.	虚函数的调用必须在运行时查询虚函数表决定，而非虚函数的调用在编译时就能确定。
		2.	使用虚函数一般需要维护指向虚函数表的指针，进而增加了对象的大小。
		3.	添加、重排或移除虚函数会破坏二进制兼容性。
		4.	不是所有的虚函数都能内联，因而将虚函数声明为内联是没有任何意义的。
		5.	重载虚函数是需要技巧的。更好的方式是避免重载虚函数。
	★	应该将虚函数声明为私有的，并且仅在派生类需要调用虚函数的基类实现时才将其声明为受保护的派生类。
		因此，接口应当是非虚的，同时在适当的情况下使用模板方法设计模式。
	★	避免将函数声明为可以重写的函数（虚的），除非你有合理且迫切的需求。
	★	API应该通过易用接口来呈现基本功能，同时将高级功能隐藏在另一个独立的层次中。
	★	基于最小化的核心API，以独立的模块或库的形式构建便捷API。
	★	使用枚举类型代替布尔类型，提高代码的可读性。
	★	避免编写拥有多个相同类型参数的函数。
	★	使用一致的函数命名和参数顺序。
	★	正交的API意味着函数没有副作用。
		1.	减少冗余。
		2.	增加独立性。
	★	大部分的C++错误都是由于误用指针或引用所导致的：
		1.	对NULL解引用。
		2.	二次释放。
		3.	访问非法内存区域。
		4.	混用内存分配器。
		5.	数组释放不正确。
		6.	内存泄露。
	★	这些特定的问题可通过使用托管指针避免：
		1.	共享指针。
		2.	弱指针。
		3.	作用域指针。
	★	客户需要的指针的生命周期比对象的生命周期更长时，就应该返回智能指针。
		如果由对象持有指针的所有权，那么可以返回一个标准指针。
	★	当需要客户销毁指针时，使用智能指针返回动态申请的对象。
	★	将资源的申请与释放当作对象的构造和析构。
	★	不要将平台相关的#if和#ifdef语句放在公共的API中，因为这些语句暴露了实现细节，并使API因平台而异。
	★	耦合：软件组件之间相互连接的强度的度量，即系统中每个组件对其他组件的依赖程序。
	★	内聚：单个软件组件内的各种方法相互关联或聚合强度的度量。
	★	优秀的API表现为松耦合和高内聚。
	★	评估组件之间的耦合度可以采用下面几种不同的度量方式：
		1.	尺度。
		2.	可见度。
		3.	密切度。
		4.	灵活度。
	★	与成员函数相比，使用非成员、非友元的方法能降低耦合度。
	★	有时，使用数据冗余降低类之间的耦合是合理的。
	★	管理器类可以通过封装几个低层次类来降低耦合。
	★	回调、观察者和通知需要注意的一些共通问题：
		1.	重入。
		2.	生命周期管理。
		3.	事件顺序。
	★	优秀的API设计应该是稳定的且具有前瞻性。在当前语境中，稳定不一定意味着API不会改变，
		而是应该将接口版本化，并且在版本升级时保证身后兼容。
	★	优秀的API设计也应该有很好的文档支持，以便用户获取API的功能、行为、最佳实践以及错误条件的明确信息。
		最终，应该为API的实现编写可扩展的自动化测试程序，确保新的变更不会破坏现有用例。
第3章 模式
	★	对高质量API设计而言至关重要的设计模式：
		1.	Pimpl惯用法：该技巧支持在公有接口中完全隐藏内部细节。
		2.	单例和工厂方法：如果要确保只创建一个对象实例，那么单例模式很有用。
							工厂方法提供了创建对象实例的通用方法，它是隐藏派生类实现细节的好方法。
		3.	代理、适配器和外观：这几种结构型模式提供了在现有的不兼容接口或遗留接口上封装API的各种途径。
		4.	观察者：该行为模式可以用来减少类之间的直接依赖。
					它通过一个类（观察者）在另一个类（主体）中注册通知的方式，使得概念上不相关的类相互通信。
	★	使用Pimpl惯用法将实现细节从公有头文件中分离出来。
	★	使用Pimpl惯用法时，应采用私有内嵌实现类。只有在.cpp文件中其他类或自由函数必须访问Impl成员时，才应采用公有内嵌类。
	★	两个注意事项：
		1.	不能在实现类中隐藏私有虚方法。它们必须出现在公有类中，以保证任何派生类都能够覆盖它们。
		2.	虽然可以将公有类传递给需要使用它的实现类的方法，但必要时可以在实现类中增加指回公有类的指针，以便Impl类调用公有方法。
	★	复制语义：
		1.	禁止复制类。
		2.	显式定义复制语义。
	★	注意Pimpl类的复制语义，可以使用智能指针管理指向impl对象的指针的初始化和销毁。
	★	Pimpl惯用法的优点：
		1.	信息隐藏。
		2.	降低耦合。
		3.	加速编译。
		4.	更好的二进制兼容性。
		5.	惰性分配。
	★	Pimpl的缺点：
		1.	必须为你创建的每个对象分配并释放实现对象。
		2.	即访问所有私有成员都需要增加开如Impl->的前缀，增加的抽象层次使得实现代码更加难以阅读和调试。
		3.	编译器将不再能够捕获const方法中对成员变量的修改。
	★	单例设计模式用来确保一个类仅存一个实例。该模式变提供对此唯一实例的全局访问点。
		可以认为单例是一种更加优雅的全局变量。
	★	单例的一些优点：
		1.	确保一个类只创建一个实例。
		2.	为对象分配和销毁提供控制。
		3.	支持线程安全地访问对象的全局状态。
		4.	避免污染全局命名空间。
	★	单例是一种更加优雅地维护全局状态的方式，但始终应该考虑清楚是否需要全局状态。
	★	将构造函数、析构函数、复制构造函数以及赋值操作符声明为私有（或受保护的—），可以实现单例模式。
	★	不同编译单元中的非局部静态对象的初始化顺序是未定义的。
	★	单例销毁顺序问题的几种解决方案：
		1.	单例销毁后必要时将其恢复。
		2.	延长某个单例的寿命，使其比其他单例生存期更久。
		3.	不销毁单例。
	★	依赖注入使采用了单例模式的代码更易于测试。
	★	单一状态模式允许创建类的多个实例，这些实例使用相同的静态数据。
	★	单一状态模式的优点：
		1.	允许创建多个实例。
		2.	由于不需要特殊的GetInstance()方法，所以无需用户特别配置。
		3.	使用静态变量可以呈现出定义明确的创建和销毁语义。
	★	如果不需要惰性初始化全局数据，或者想让类的唯一性透明化，可以考虑使用单一状态代替单件。
	★	单例模式有一些替代方案，包括依赖注入、单一状态模式以及使用会话上下文。
	★	工厂模式是一个创建型的设计模式。它允许创建对象时不指定要创建的对象的具体类型。
	★	工厂方法是构造函数的一般化。
	★	构造函数的限制：
		1.	没有返回值。
		2.	命名限制。
		3.	静态绑定创建。
		4.	不允许虚构造函数。
	★	使用工厂方法提供更强大的类构造语义并隐藏子类的细节。
	★	创建包装器API的潜在副作用是影响性能，这主要因为额外增加的一级间接寻址以及存储包装层次状态带来的开销。
	★	结构化设计模式可以处理接口包装任务。
	★	代理设计模式为另一个类提供了一对一的转发接口。也就是说，代理类和原始类有相同的接口。
	★	代理的缺点是需要再次暴露原始对象的函数。
	★	代理的另一个方案是增加代理和原始API共享的虚接口，这样做是为了更好地保持这两个API的同步，这么做的前提是你能够修改原始API。
	★	代理提供了一个接口，此接口将函数调用转发到具有同样形式的另一个接口。
	★	代理模式的案例：
		1.	实现原始对象的惰性实例。
		2.	实现对原始对象的访问控制。
		3.	支持调试或“演习”模式。
		4.	保证原始类线程安全。
		5.	支持资源共享。
		6.	应对原始类将来被修改的情况。
	★	适配器设计模式将一个类的接口转换成一个兼容的但不相同的接口。
	★	适配器设计模式与代理模式相似之处是，适配器设计模式也是一个单一组件包装器，但适配器类和原始类的接口可以不相同。
	★	适配器将一个接口转换为一个兼容的但不相同的接口。
	★	适配器模式的优点：
		1.	强制API始终保持一致性。
		2.	包装API的依赖库。
		3.	转换数据类型。
		4.	为API暴露一个不同的调用约定。
	★	外观模式能够为一组类提供简化的接口。
	★	外观模式和适配器模式的区别是，外观模式简化了类的结构，而适配器模式仍然保持相同的类结构。
	★	外观模式为一组类提供了简化的接口。在封装外观模式中，底层类不再可访问。
	★	外观模式的用途：
		1.	隐藏遗留代码。
		2.	创建便捷API。
		3.	支持简化功能或者替代功能的API。
	★	观察者支持组件解耦且避免了循环依赖。
	★	MVC支持应用程序的功能模块化，并具有以下优点：
		1.	模型和视图组件的隔离，就可以实现多个用户界面，并且使这些界面能够重用公共的业务逻辑核心。
		2.	避免了因多份UI实现而构建多份重复的底层模型代码的问题。
		3.	模型和视图代码的解耦简化了为核心业务逻辑代码编写单元测试的工作。
		4.	组件的模块化允许核心逻辑开发者和GUI开发者并行工作，且互不影响。
	★	MVC架构模式促使核心业务逻辑与用户界面分离。它还隔离了控制器逻辑，控制器逻辑会引起模型的改变并更新视图。
	★	控制器和视图都依赖于模型，但是模型代码既不依赖控制器代码，也不依赖视图代码。
	★	观察者模式是“发布/订阅”范式的一个具体实例。这些技术定义了对象之间一对多的依赖，
		使得发布者对象能够将它的状态变化通知给所有的订阅对象，而又不直接依赖订阅对象。
第4章 设计