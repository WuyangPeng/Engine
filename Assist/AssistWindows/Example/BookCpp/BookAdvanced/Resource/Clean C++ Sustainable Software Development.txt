C++ 代码整洁之道：C++17可持续软件开发模式实践（Clean C++: Sustainable Software Development）

官方网站：
https://de.linkedin.com/in/steproth 、 https://roth-soft.de/ 、
https://www.clean-cpp.com/ 、https://github.com/clean-cpp/book-samples。

★★★ 
作者：Stephan Roth

联系作者：
stephan@clean-cpp.com

关于作者
关于技术审校
致谢
第1章 简介
	★ 如何去做和做到同样重要。
	1.1 软件熵
		★ 一个封装系统的总混乱度不会减少，只能保持不变或增加。
		★ 不要容忍“破窗”出现在你的代码中——及时地改正它们。
	1.2 整洁的代码
		★ 整洁的代码是容易被任何团队的成员理解和维护的。
		★ 整洁代码是软件持续发展的基础，能够在没有欠下大量技术债务的情况下保证软件运行很长的一段时间。
		★ 整洁的代码能够节省金钱。
	1.3 为什么使用C++
	1.4 C++11—新时代的开始
	1.5 适合本书的读者
	1.6 本书使用的约定
		1.6.1 扩展阅读
		1.6.2 说明、提示和警告
		1.6.3 示例代码
		1.6.4 编码风格
	1.7 相关网站和代码库
	1.8 UML图
第2章 构建安全体系
	2.1 测试的必要性
	2.2 测试入门
	2.3 单元测试
		★	没有测试的“重构”不能称之为重构，它仅仅是到处移动垃圾代码。
		★	单元测试的优点：
			1.	在软件部署运行以后修复bug的代价，比在单元测试阶段修复bug的代价要高得多。
			2.	单元测试能够给出关于整个代码库的即时反馈。
			3.	单元测试让开发人员有足够的信心重构代码，而不必担心因重构而带来的错误。
			4.	高覆盖率的单元测试，可以有效防止陷入耗时和让人手足无措的代码调试中，可以大大降低长时间使用调试器调试的问题。
			5.	单元测试是一种可以被执行的文档，因为单元测试精确地展现了代码是如何被设计和使用的。
			6.	单元测试可以很容易地检测回归测试的代码。
			7.	单元测试可以促进实现整洁且良好的接口，可以帮助开发人员避免文件间不必要的依赖关系。
			8.	单元测试能够促进开发。
	2.4 关于QA
		★	尽管你的公司可能有一个单独的QA小组来测试软件，但开发组的目标应该是QA没有发现任何缺陷。
	2.5 良好的单元测试原则
		2.5.1 单元测试的代码的质量
			★	高质量地要求产品代码，同样高质量地要求单元测试代码。
		2.5.2 单元测试的命名
			★	如果单元测试失败，开发人员希望立即知道以下信息：
				1.	测试单元的名称是什么？谁的单元测试失败了？
				2.	单元测试测试了什么？单元测试的环境是怎么样的？
				3.	预期的单元测试结果是什么？单元测试失败的实际测试结果又是什么？
			★	一个直观的且易理解的名称应该包含以下三点：
				1.	单元测试的前置条件。
				2.	被单元测试测试的部分。
				3.	单元测试预期的测试结果。
		2.5.3 单元测试的独立性
			★	每个单元测试和其他的单元测试都必须是独立的。
		2.5.4 一个测试一个断言
		2.5.5 单元测试环境的独立初始化
			★	在一个干净整洁的单元测试运行完成后，与该单元测试相关的所有状态都必须消失。
		2.5.6 不对getters和setters做单元测试
			★	不要为类的简单的访问器和设置器编写单元测试。
		2.5.7 不对第三方代码做单元测试
			★	不使用那些没有自己的单元测试和质量可疑的库或框架，这是一种明智的架构选择。
		2.5.8 不对外部系统做单元测试
			★	测试你自己的代码，而不是他们的代码。
		2.5.9 如何处理数据库的访问
			★	能不使用数据库进行单元测试，就不使用数据库进行单元测试。
		2.5.10 不要混淆测试代码和产品代码
		2.5.11 测试必须快速执行
			★	测试必须快速执行！
		2.5.12 测试替身
			★	要测试的单元与其他模块或外部系统的依赖性应该被所谓的测试替身替换，测试替身也被称为伪对象或假模型。
第3章 原则
	3.1 什么是原则
		★	原则是一种规则、信仰或者指引你的观念，原则通常与价值观或价值体系直接联系。
	3.2 保持简单和直接原则（KISS）
		★	任何事物都应该尽可能简单，而不是稍微简单一点。
		★	简单到只要能正常工作就好。
		★	只添加那些使事情整体变得更简单的复杂性的东西。
	3.3 不需要原则（YAGNI）
		★	总是在你真正需要的时候再实现它们，而不是在你只是预见到你需要它们的时候实现它们。
		★	在你确定真的有必要的时候再写代码，那时再重构仍然来得及。
	3.4 避免复制原则（DRY）
		★	复制粘贴是一个设计错误。
		★	在一个系统内部，任何一个知识点都必须有一个单一的，明确的、权威的陈述。
	3.5 信息隐藏原则
		★	一段代码调用另处一段代码，那么，调用者不应该知道被调用者的内部实现。
			否则，调用者就有可能通过修改被调用者的内部实现而完成某个功能，而不是强制性地要求调用者修改自己的代码。
		★	信息隐藏有很多优点：
			1.	限制了模块变更的范围。
			2.	如果需要修复缺陷，对其他模块的影响最小。
			3.	显著提高了模块的可复用性。
			4.	模块具有更好的可测试性。
		★	封装有助于但不能保证信息隐藏。
	3.6 高内聚原则
		★	任何软件实体应该具有很高的内聚性。
	3.7 松耦合原则
	3.8 小心优化原则
	3.9 最少惊讶原则（PLA）
	3.10 童子军原则
第4章 C++代码整洁的基本规范
	4.1 良好的命名
		4.1.1 名称应该自解释
		4.1.2 使用域中的名称
		4.1.3 选择适当抽象层次的名称
		4.1.4 避免冗余的名称
		4.1.5 避免晦涩难懂的缩写
		4.1.6 避免匈牙利命名和命名前缀
		4.1.7 避免相同的名称用于不同的目的
	4.2 注释
		4.2.1 让写代码像讲故事一样
		4.2.2 不要为易懂的代码写注释
		4.2.3 不要通过注释禁用代码
		4.2.4 不要写块注释
		4.2.5 特殊情况的注释是有用的
	4.3 函数
		4.3.1 只做一件事情
		4.3.2 让函数尽可能小
		4.3.3 函数命名
		4.3.4 使用容易理解的名称
		4.3.5 函数的参数和返回值
	4.4 C++工程中的C风格代码
		4.4.1 使用C++的string和stream替代C风格的char*
		4.4.2 避免使用printf()、sprintf()和gets()等
		4.4.3 使用标准库的容器而不是C风格的数组
		4.4.4 用C++类型转换代替C风格的强制转换
		4.4.5 避免使用宏
第5章 现代C++的不错概念
	5.1 资源管理
		5.1.1 资源申请即初始化
		5.1.2 智能指针
		5.1.3 避免显式的new和delete
		5.1.4 管理特有资源
	5.2 Move语义
		5.2.1 什么是Move语义
		5.2.2 左值和右值的关系
		5.2.3 右值引用
		5.2.4 不要滥用Move
		5.2.5 零原则
	5.3 编译器是你的搭档
		5.3.1 自动类型推导
		5.3.2 编译时计算
		5.3.3 模板变量
	5.4 不允许未定义的行为
	5.5 Type-Rich编程
	5.6 了解你使用的库
		5.6.1 熟练使用
		5.6.2 熟练使用Boost
		5.6.3 应该了解的一些库
	5.7 恰当的异常和错误处理机制
		5.7.1 防患于未然
		5.7.2 异常即异常—字面上的意思
		5.7.3 如果不能恢复则尽快退出
		5.7.4 用户自定义异常
		5.7.5 值类型抛出，常量引用类型捕获
		5.7.6 注意catch的正确顺序
第6章 面向对象
	6.1 面向对象思想
	6.2 抽象—解决复杂问题的关键因素
	6.3 类的设计原则
		6.3.1 让类尽可能小
		6.3.2 单一职责原则（SRP）
		6.3.3 开闭原则（OCP）
		6.3.4 里氏替换原则(LSP)
		6.3.5 接口隔离原则（ISP）
		6.3.6 无环依赖原则
		6.3.7 依赖倒置原则（DIP）
		6.3.8 不要和陌生人说话（迪米特法则）
		6.3.9 避免“贫血类”
		6.3.10 只说不问
		6.3.11 避免类的静态成员
第7章 函数式编程
	7.1 什么是函数式编程
		7.1.1 什么是函数
		7.1.2 pure函数和impure函数
	7.2 现代C++中的函数式编程
		7.2.1 C++模板函数编程
		7.2.2 仿函数
		7.2.3 绑定和函数包装
		7.2.4 Lambda表达式
		7.2.5 通用Lambda表达式（C++14）
	7.3 高阶函数
	7.4 整洁的函数式编程代码
第8章 测试驱动开发
	8.1 普通的旧单元测试的缺点
	8.2 测试驱动开发作为颠覆者
		8.2.1 TDD的流程
		8.2.2 TDD的一个小例子：Code Kata
	8.3 TDD的优势
	8.4 什么时候不应该使用TDD
第9章 设计模式和习惯用法
	9.1 设计原则与设计模式
	9.2 常见的设计模式及应用场景
		9.2.1 依赖注入模式
		9.2.2 Adapter模式
		9.2.3 Strategy模式
		9.2.4 Command模式
		9.2.5 Command处理器模式
		9.2.6 Composite模式
		9.2.7 Observer模式
		9.2.8 Factory模式
		9.2.9 Facade模式
		9.2.10 Money Class模式
		9.2.11 特例模式
	9.3 什么是习惯用法
附录A UML简要指南