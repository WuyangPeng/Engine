算法（Algorithms）

官方网站：
https://algs4.cs.princeton.edu/home/ 、https://github.com/kevin-wayne/algs4/、 http://www.awl.com/cseng/titles/0-201-35088-2 （已失效）。

第4版
★
作者：Robert Sedgewick、Kevin Wayne

第3版
算法I-IV（C++实现）（Algorithms in C++ Parts 1-4）
★
作者：Robert Sedgewick

知识点 
1.	算法基础知识。

前言
	范围
	课程中的用法
	实际应用的算法 
	程序设计语言
	致谢
	C++顾问的前言
	有关练习的注释 
第一部分 基本原理
	第1章 简介
		1.1 算法
		1.2 示例：连通问题
		1.3 合并—查找算法
		1.4 前景展望
		1.5 总结
	第2章 算法分析原理
		2.1 实现和经验分析
		2.2 算法分析
		2.3 函数的增长
		2.4 大O符号
		2.5 递归基础知识
		2.6 算法分析举例
		2.7 保证、预测和限制
	第一部分参考资料
第二部分 数据结构
	第3章 基本数据结构
		3.1 构建组件
		3.2 数组
		3.3 链表
		3.4 基本的链表处理
		3.5 链表的内存分配
		3.6 字符串
		3.7 复合数据结构
	第4章 抽象数据类型
		4.1 抽象对象和对象集合
		4.2 下推栈ADT
		4.3 栈ADT客户示例
		4.4 栈ADT的实现
		4.5 创建一个新ADT
		4.6 FIFO队列和广义队列
		4.7 复制和索引项
		4.8 一级ADT
		4.9 基于应用的ADT范例
		4.10 前景展望
	第5章 递归与树
		5.1 递归算法
		5.2 分治法
		5.3 动态编程
		5.4 树
		5.5 二叉树的数学性质
		5.6 树遍历
		5.7 递归二叉树算法
		5.8 图遍历
		5.9 前景展望
	第二部分参考资料
第三部分 排序算法
	第6章 基本排序方法
		6.1 游戏规则
		6.2 选择排序
		6.3 插入排序
		6.4 冒泡排序
		6.5 基本排序方法的执行特性
		6.6 Shell排序法
		6.7 对其他类型的文件进行排序
		6.8 索引和指针排序
		6.9 链表排序
		6.10 关键字索引统计
	第7章 快速排序
		7.1 基本算法
		7.2 快速排序算法的性能特性
		7.3 栈大小
		7.4 小的子文件
		7.5 利用三个元素的中间元素来划分
		7.6 重复值
		7.7 字符串和向量
		7.8 选择
	第8章 归并及归并排序
		8.1 二路归并
		8.2 抽象的合适归并算法
		8.3 自顶向下的归并排序
		8.4 对基本排序方法进行改进
		8.5 自底向上的归并排序
		8.6 执行典型的归并排序算法 
		8.7 使用链表执行归并排序
		8.8 再次讨论递归过程
	第9章 优先队列与堆排序
		9.1 基本的实现方法
		9.2 堆的数据结构
		9.3 基于堆的算法 
		9.4 堆排序
		9.5 优先队列抽象数据类型
		9.6 索引元素的优先队列
		9.7 二项式队列
	第10章 基数排序
		10.1 比特、字节、字
		10.2 二进制快速排序
		10.3 MSD基数排序
		10.4 三路基数快速排序
		10.5 LSD基数排序
		10.6 基数排序的特性
		10.7 运行时间低于线性的排序
	第11章 特殊用途的排序方法
		11.1 巴彻尔奇偶归并排序
		11.2 排序网络
		11.3 外部排序
		11.4 “排序 归并”的实现
		11.5 并行“排序 归并”
	第三部分参考资料
第四部分 搜索算法
	第12章 符号表和二叉搜索树
		12.1 符号表抽象数据类型
		12.2 关键字索引检索
		12.3 顺序搜索
		12.4 二叉搜索
		12.5 二叉搜索树
		12.6 BST的性能特性
		12.7 符号表的索引实现
		12.8 在BST的根进行的插入
		12.9 其他ADT函数的BST实现
	第13章 平衡树
		13.1 随机化BST
		13.2 发散BST
		13.3 自上而下2-3-4树
		13.4 红黑树
		13.5 跳跃表
		13.6 性能特性
	第14章 散列
		14.1 散列函数
		14.2 链地址法
		14.3 线性探测
		14.4 双重散列
		14.5 动态散列表
		14.6 综述
	第15章 基数检索
		15.1 数字搜索树
		15.2 线索
		15.3 帕氏线索
		15.4 多叉线索和TST
		15.5 文本字符索引算法 
	第16章 外部排序
		16.1 游戏规则
		16.2 索引顺序存取
		16.3 B树
		16.4 可扩充散列
		16.5 综述
	第四部分参考资料

第3版
算法V（C++实现）
★
作者：Robert Sedgewick

知识点 
1.	算法基础知识。 

前言
	算法
	本书范围
	教学使用
	实用算法 
	编程语言
	致谢
C++顾问所撰写的前言
关于练习的说明 
第1章 图的属性和类型
	1.1	术语
	1.2 图的ADT
	1.3 邻接矩阵表示
	1.4 邻接表表示
	1.5 变化、扩展和开销
	1.6 图生成器
	1.7 简单路径、欧拉路径和汉密尔路径
	1.8 图处理问题
第2章 图搜索
	2.1 探索迷宫
	2.2 深度优先搜索
	2.3 图搜索ADT函数
	2.4 DFS森林的属性
	2.5 DFS算法
	2.6 可分离性和重连通性
	2.7 广度优先搜索
	2.8 广义图搜索
	2.9 图算法分析
第3章 有向图和无环有向图
	3.1 术语和游戏规则
	3.2 有向图中的DFS剖析
	3.3 可达性和传递闭包
	3.4 等价关系和偏序
	3.5 无环有向图
	3.6 拓扑排序
	3.7 DAG的可达性
	3.8 有向图中的强分量
	3.9 再述传递闭包
	3.10 展望
第4章 最小生成树
	4.1 表示
	4.2 MST算法的基本原理
	4.3 Prim算法和优先级优先搜索
	4.4 Kruskal算法
	4.5 Boruvka算法
	4.6 比较与改进
	4.7 欧儿里得MST
第5章 最短路径
	5.1 基本原则
	5.2 Dijkstra算法
	5.3 全源最短路径
	5.4 无环网中的最短路径
	5.5 欧几里得网
	5.6 归约
	5.7 负权值
	5.8 展望
第6章 网络流
	6.1 流网络
	6.2 扩充路径最大流算法 
	6.3 预流-压入最大流算法 
	6.4 最大流归约
	6.5 最小成本流
	6.6 网络单纯形算法 
	6.7 最小成本流归约
	6.8 展望

知识点 
1.	算法基础知识。

前言
	独特之处
	本书网站
	作为教材
	背景介绍
	致谢
第1章 基础
	1.1 基础编程模型
		1.1.1 Java程序的基本结构
		1.1.2 原始数据类型与表达式
		1.1.3 语句
		1.1.4 简便记法
		1.1.5 数组
		1.1.6 静态方法
		1.1.7 API
		1.1.8 字符串
		1.1.9 输入输出
		1.1.10 二分查找
		1.1.11 展望
	1.2 数据抽象
		1.2.1 使用抽象数据类型
		1.2.2 抽象数据类型举例
		1.2.3 抽象数据类型的实现
		1.2.4 更多抽象数据类型的实现
		1.2.5 数据类型的设计
	1.3 背包、队列和栈
		1.3.1 API
		1.3.2 集合类数据类型的实现
		1.3.3 链表
		1.3.4 综述
	1.4 算法分析
		1.4.1 科学方法
		1.4.2 观察
		1.4.3 数学模型
		1.4.4 增长数量级的分类
		1.4.5 设计更快的算法
		1.4.6 倍率实验
		1.4.7 注意事项
		1.4.8 处理对于输入的依赖
		1.4.9 内存
		1.4.10 展望
	1.5 案例研究：union-find算法
		1.5.1 动态连通性
		1.5.2 实现
		1.5.3 展望
第2章 排序
	2.1 初级排序算法
		2.1.1 游戏规则
		2.1.2 选择排序
		2.1.3 插入排序
		2.1.4 排序算法的可视化
		2.1.5 比较两种排序算法
		2.1.6 希尔排序
	2.2 归并排序
		2.2.1 原地归并的抽象方法
		2.2.2 自顶向下的归并排序
		2.2.3 自底向上的归并排序
		2.2.4 排序算法的复杂度
	2.3 快速排序
		2.3.1 基本算法
		2.3.2 性能特点
		2.3.3 算法改进
	2.4 优先队列
		2.4.1 API
		2.4.2 初级实现
		2.4.3 堆的定义
		2.4.4 堆的算法
		2.4.5 堆排序
	2.5 应用
		2.5.1 将各种数据排序
		2.5.2 我应该使用哪种排序算法
		2.5.3 问题的归约
		2.5.4 排序应用一览
第3章　查找
	3.1　符号表
		3.1.1　API
		3.1.2　有序符号表
		3.1.3　用例举例
		3.1.4　无序链表中的顺序查找
		3.1.5　有序数组中的二分查找
		3.1.6　对二分查找的分析
		3.1.7　预览
	3.2　二叉查找树
		3.2.1　基本实现
		3.2.2　分析
		3.2.3　有序性相关的方法与删除操作
	3.3　平衡查找树
		3.3.1　2-3查找树
		3.3.2　红黑二叉查找树
		3.3.3　实现
		3.3.4　删除操作
		3.3.5　红黑树的性质
	3.4　散列表
		3.4.1　散列函数
		3.4.2　基于拉链法的散列表
		3.4.3　基于线性探测法的散列表
		3.4.4　调整数组大小
		3.4.5　内存使用
	3.5　应用
		3.5.1　我应该使用符号表的哪种实现
		3.5.2　集合的API
		3.5.3　字典类用例
		3.5.4　索引类用例
		3.5.5　稀疏向量
第4章 图
	4.1 无向图
		4.1.1 术语表
		4.1.2 表示无向图的数据类型
		4.1.3 深度优先搜索
		4.1.4 寻找路径
		4.1.5 广度优先搜索
		4.1.6 连通分量
		4.1.7 符号图
		4.1.8 总结
	4.2 有向图
		4.2.1 术语
		4.2.2 有向图的数据类型
		4.2.3 有向图中的可达性
		4.2.4 环和有向无环图
		4.2.5 有向图中的强连通性
		4.2.6 总结
	4.3 最小生成树
		4.3.1 原理
		4.3.2 加权无向图的数据类型
		4.3.3 最小生成树的API和测试用例
		4.3.4 Prim算法
		4.3.5 Prim算法的即时实现
		4.3.6 Kruskal算法
		4.3.7 展望
	4.4 最短路径
		4.4.1 最短路径的性质
		4.4.2 加权有向图的数据结构
		4.4.3 最短路径算法的理论基础
		4.4.4 Dijkstra算法
		4.4.5 无环加权有向图中的最短路径算法
		4.4.6 一般加权有向图中的最短路径问题
		4.4.7 展望
第5章 字符串
	5.1 字符串排序
		5.1.1 键索引计数法
		5.1.2 低位优先的字符串排序
		5.1.3 高位优先的字符串排序
		5.1.4 三向字符串快速排序
		5.1.5 字符串排序算法的选择
	5.2 单词查找树
		5.2.1 单词查找树
		5.2.2 单词查找树的性质
		5.2.3 三向单词查找树
		5.2.4 三向单词查找树的性质
		5.2.5 应该使用字符串符号表的哪种实现
	5.3 子字符串查找
		5.3.1 历史简介
		5.3.2 暴力子字符串查找算法
		5.3.3 Knuth-Morris-Pratt子字符串查找算法
		5.3.4 Boyer-Moore字符串查找算法
		5.3.5 Rabin-Karp指纹字符串查找算法
		5.3.6 总结
	5.4 正则表达式
		5.4.1 使用正则表达式描述模式
		5.4.2 缩略写法
		5.4.3 正则表达式的实际应用
		5.4.4 非确定有限状态自动机
		5.4.5 模拟NFA的运行
		5.4.6 构造与正则表达式对应的
	5.5 数据压缩
		5.5.1 游戏规则
		5.5.2 读写二进制数据
		5.5.3 局限
		5.5.4 热身运动：基因组
		5.5.5 游程编码
		5.5.6 霍夫曼压缩
第6章 背景