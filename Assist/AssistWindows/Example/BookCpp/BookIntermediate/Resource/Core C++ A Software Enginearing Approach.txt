C++ 精髓——软件工程方法（Core C++:A Software Enginearing Approach）

官方网站：
ftp://ftp.prenhall.com/pub/ptr/c++programming.w-050/corec++ （已失效）。

○
作者：Victor Shtern

联系作者：
shtern@bu.edu

知识点 
1.	C++	基础知识。 

前言
	本书与其他C++书籍的区别
	本书的读者对象
	本书的内容组织
	本书中使用的约定
	访问源代码的方式 
	意见反馈
第一部分 C++程序设计简介
	第1章  面向对象方法的优点
		1.1 软件危机的起因
		1.2 解决方案1：摆脱程序员
		1.3 解决方案2：改进管理技术 
			1.3.1 瀑布模型方法
			1.3.2 快速原型方法
		1.4 解决方案3：设计一种复杂而完善的语言
		1.5 面向对象方法的含义和优点
			1.5.1 设计人员的工作
			1.5.2 设计质量：内聚性
			1.5.3 设计质量：耦合度
			1.5.4 设计质量：将数据与函数绑定在一起
			1.5.5 设计质量：信息隐藏和封装
			1.5.6 设计问题：命名冲突
			1.5.7 设计问题：对象初始化
			1.5.8 对象的实质
			1.5.9 使用对象的优点
		1.6 C++程序设计语言的特征
			1.6.1 C语言的目标：性能、可读性、美观和可移植性
			1.6.2 C++语言的目标：与C语言身后兼容的类
		1.7 小结
	第2章  快速入门：C++简介
		2.1 基本程序结构
		2.2 预处理程序指令
		2.3 注释
		2.4 声明和定义
		2.5 语句和表达式
		2.6 函数和函数调用
		2.7 类
		2.8 程序开发工具的使用
		2.9 小结
	第3章  C++数据和表达式的使用
		3.1 值及其类型
		3.2 整数类型
			3.2.1 整数类型修饰符
			3.2.2 字符 
			3.2.3 布尔值
		3.3 浮点类型
		3.4 C++表达式的使用
			3.4.1 高优先级运算符
			3.4.2 算术运算符
			3.4.3 移位运算符
			3.4.4 按位逻辑运算符
			3.4.5 关系和相等运算符
			3.4.6 逻辑运算符
			3.4.7 赋值运算符
			3.4.8 条件运算符
			3.4.9 逗号运算符
		3.5 混合型表达式：隐藏的危险
		3.6 小结
	第4章  C++控制流
		4.1 语句和表达式
		4.2 条件语句
			4.2.1 条件语句的标准形式
			4.2.2 条件语句中的常见错误
			4.2.3 嵌套条件语句及其优化
		4.3 循环
			4.3.1 while循环
			4.3.2 do-while循环
			4.3.3 for循环
		4.4 C++转移语句
			4.4.1 break语句
			4.4.2 continue语句
			4.4.3 goto语句
			4.4.4 return和exit转移
			4.4.5 switch语句
		4.5 小结
	第5章  程序员定义数据类型的聚集
		5.1 同种类聚集的数组
			5.1.1 作为值向量的数组
			5.1.2 C++数组的定义
			5.1.3 数组上的操作
			5.1.4 下标正确性的检查
			5.1.5 多维数组
			5.1.6 字符数组的定义
			5.1.7 字符数组上的操作
			5.1.8 字符串函数和内存讹用
			5.1.9 二维字符数组
			5.1.10 插入算法中的数组溢出
			5.1.11 数组类型的定义
		5.2 不同种类聚集的结构
			5.2.1 程序员定义类型的结构定义
			5.2.2 创建和初始化结构变量
			5.2.3 层次结构及其分量
			5.2.4 结构变量上的操作
			5.2.5 在多文件程序中定义的结构
		5.3 联合、枚举和位域
			5.3.1 联合
			5.3.2 枚举
			5.3.3 位域
		5.4 小结
	第6章  内存管理：栈和堆
		6.1 作为合作工具的名字用域
			6.1.1 C++词法作用域
			6.1.2 同一作用域中的名字冲突
			6.1.3 在独立的作用域中使用相同的名字
			6.1.4 在嵌套的作用域中使用相同的名字
			6.1.5 循环变量的作用域
		6.2 内存管理：存储类别
			6.2.1 自动变量
			6.2.2 外部变量
			6.2.3 静态变量
		6.3 内存管理：堆的使用
			6.3.1 作为类型变量的C++指针
			6.3.2 堆的内存分配 
			6.3.3 数组和指针
			6.3.4 动态数组
			6.3.5 动态结构
		6.4 磁盘文件的输入和输出
			6.4.1 输出到文件
			6.4.2 从文件输入
			6.4.3 输入/输出文件对象
		6.5 小结
第二部分 用C++进行面向对象的程序设计
	第7章  使用C++函数编程
		7.1 作为模块化工具的C++函数
			7.1.1 函数声明 
			7.1.2 函数定义
			7.1.3 函数调用
		7.2 参数的提升和类型转换
		7.3 C++中函数的参数传递
			7.3.1 按值调用
			7.3.2 按指针调用
			7.3.3 C++中的参数传递：按引用调用 
			7.3.4 结构
			7.3.5 数组
			7.3.6 类型转换的进一步讨论
			7.3.7 从函数返回值
		7.4 内联函数
		7.5 有缺少值的参数
		7.6 函数名重载
		7.7 小结
	第8章  使用函数的面向对象程序设计
		8.1 内聚性
		8.2 耦合度
			8.2.1 隐匿耦合度
			8.2.2 显式耦合度
			8.2.3 如何降低耦合度
		8.3 数据封装
		8.4 信息隐藏
		8.5 一个有关封装的大型例子
		8.6 用函数实现封装的不足
		8.7 小结 
	第9章  作为模块单元的C++类
		9.1 基本的类语法
			9.1.1 绑定数据与操作
			9.1.2 消除名字冲突
			9.1.3 在类之外实现成员函数
			9.1.4 不同存储方式的类对象的定义
		9.2 对类成员的控制访问
		9.3 对象实例的初始化
			9.3.1 作为成员函数的构造函数
			9.3.2 缺省构造函数
			9.3.3 拷贝构造函数
			9.3.4 转换构造函数
			9.3.5 析构函数
			9.3.6 构造函数和析构函数的调用时间
			9.3.7 类作用域和嵌套作用域中的名字覆盖
			9.3.8 用运算符和函数调用的内存管理
		9.4 在客户代码中使用返回的对象
			9.4.1 返回指针和引用 
			9.4.2 返回对象
		9.5 关于const关键字的讨论
		9.6 静态类成员 
			9.6.1 用全局变量作为类特性
			9.6.2 关键字static的第四种含义
			9.6.3 静态数据成员的初始化
			9.6.4 静态成员函数
		9.7 小结
	第10章  运算符重载：另一种好设计思想
		10.1 运算符重载
		10.2 运算符重载的限制
			10.2.1 不可重载的运算符
			10.2.2 返回类型的限制
			10.2.3 参数个数的限制
			10.2.4 运算符优先级的限制
		10.3 把重载运算符作为类成员 
			10.3.1 用类成员取代全局函数
			10.3.2 在链式操作中使用类成员 
			10.3.3 使用const关键字
		10.4 案例分析：有理数
		10.5 混合参数类型
		10.6 友元函数
		10.7 小结
	第11章  构造函数和析构函数：潜在的问题
		11.1 对按值传递对象的深入讨论
		11.2 非数值类的运算符重载
			11.2.1 String类
			11.2.2 堆内存的动态管理
			11.2.3 保护客户代码中的对象堆数据
			11.2.4 重载的串接运算符
			11.2.5 防止内存泄漏
			11.2.6 保护程序的完整性
			11.2.7 如何由此及彼
		11.3 对拷贝构造函数的深入讨论
			11.3.1 完整性问题的补救措施
			11.3.2 拷贝语义和值语义
			11.3.3 程序员定义的拷贝构造函数
			11.3.4 按值返回
			11.3.5 拷贝构造函数的有效局限性
		11.4 赋值运算符的重载
			11.4.1 系统提供的赋值运算符的问题
			11.4.2 重载的赋值：内存泄漏
			11.4.3 重载的赋值：自我赋值
			11.4.4 重载的赋值：链表达式
			11.4.5 程序性能的考虑
			11.4.6 第一种补救措施：更多的重载
			11.4.7 第二种补救措施：按引用返回
		11.5 实用性的考虑：实现什么函数
		11.6 小结
第三部分 使用聚集和继承的面向对象程序设计
	第12章  复合类的优缺点
		12.1 用类对象作为数据成员
			12.1.1 C++类复合的语法
			12.1.2 访问类数据成员的数据成员
			12.1.3 访问方法参数的数据成员
		12.2 复合对象的初始化
			12.2.1 使用组件的缺省构造函数
			12.2.2 使用成员的初始化列表
		12.3 具有特殊属性的数据成员
			12.3.1 常量数据成员
			12.3.2 引用数据成员
			12.3.3 用对象作为其类自身的数据成员
			12.3.4 用静态数据成员作为其类自身的数据成员
		12.4 容器类
			12.4.1 嵌套类
			12.4.2 友元类
		12.5 小结
	第13章  如何处理相似类
		13.1 相似类的处理
			13.1.1 把子类的特征合并到一个类中
			13.1.2 把保持程序完整性的任务推向服务器
			13.1.3 为每种服务器对象建立单独的类
			13.1.4 使用C++的继承去链接相关类
		13.2 C++继承的语法
			13.2.1 基类的不同派生模式
			13.2.2 定义和使用基类对象和派生类对象
		13.3 对基类和派生类服务的访问
		13.4 对派生类的对象的基类成员的访问
			13.4.1 公共继承
			13.4.2 受保护继承
			13.4.3 私有继承
			13.4.4 调整对派生类中基类成员的访问
			13.4.5 缺省继承模式
		13.5 在继承下的作用域规则和名字解析
			13.5.1 名字重载与名字隐藏
			13.5.2 派生类所隐藏的基类方法的调用 
			13.5.3 使用继承改进程序
		13.6 派生类的构造函数和析构函数
			13.6.1 在派生类构造函数中的初始化列表
			13.6.2 继承中的析构函数
		13.7 小结
	第14章  在继承和复合之间进行选择
		14.1 选择代码重用的方法
			14.1.1 类之间的客户——服务器关系的例子
			14.1.2 运用智力的重用：重做
			14.1.3 借助服务重用
			14.1.4 通过继承的代码重用
			14.1.5 以重新定义函数的方式继承
			14.1.6 继承和复合的优缺点
		14.2 统一建模语言
			14.2.1 使用UML的目的
			14.2.2 UML基础：类的表示
			14.2.3 UML基础：关系的表示
			14.2.4 UML基础：聚集和泛化的表示
			14.2.5 UML基础：多重性的表示
		14.3 案例分析：一种租赁商店
		14.4 类的可见性和任务划分
			14.4.1 类的可见性及类之间的系统
			14.4.2 将任务推向服务器类
			14.4.3 使用继承
		14.5 小结
第四部分 C++的高级应用
	第15章  虚函数和继承的其他高级应用
		15.1 非相关类之间的转换
			15.1.1 强类型与弱类型
			15.1.2 转换构造函数
			15.1.3 指针或引用之间的转换
			15.1.4 转换运算符
		15.2 通过继承相关的类之间的转换
			15.2.1 安全转换与不安全转换
			15.2.2 对象的指针与引用的转换
			15.2.3 指针与引用参数的转换
		15.3 虚函数
			15.3.1 动态绑定：传统方法
			13.3.2 动态绑定：面向对象的方法
			15.3.3 动态绑定：使用虚函数
			15.3.4 动态绑定与静态绑定
			15.3.5 纯虚函数
			15.3.6 虚函数：析构函数
		15.4 多继承：多个基类
			15.4.1 多继承：访问规则
			15.4.2 类之间的转换
			15.4.3 多继承：构造函数和析构函数
			15.4.4 多继承：二义性
			15.4.5 多继承：有向图
			15.4.6 多继承：有用吗
		15.5 小结
	第16章  运算符重载的高级应用
		16.1 运算符重载简介
		16.2 一元运算符
			16.2.1 ++和--运算符
			16.2.2 后缀重载运算符
			16.2.3 转换运算符
		16.3 下标和函数调用运算符
			16.3.1 下标运算符
			16.3.2 函数调用运算符
		16.4 输入/输出运算符
			16.4.1 重载运算符>>
			16.4.2 重载运算符<<
		16.5 小结
	第17章  模板：另一个设计工具
		17.1 类设计重用的一个简单例子
		17.2 模板类定义的语法 
			17.2.1 模板类说明
			17.2.2 模板实例化
			17.2.3 模板函数的实现
			17.2.4 嵌套模板
		17.3 多参数的模板类
			17.3.1 多类型参数
			17.3.2 带有常量表达式参数的模板
		17.4 模板类实例之间的关系
			17.4.1 作为友元的模板类
			17.4.2 嵌套模板类
			17.4.3 带静态成员的模板
		17.5 模板的规则说明
		17.6 模板函数
		17.7 小结
	第18章  带异常处理的程序设计
		18.1 异常处理的一个简单例子
		18.2 C++异常的语法
			18.2.1 抛出异常
			18.2.2 捕获异常
			18.2.3 声明异常
			18.2.4 重新抛出异常
		18.3 类对象的异常
			18.3.1 抛出、声明与捕获对象的语法
			18.3.2 使用带异常处理的继承
			18.3.3 标准异常库
		18.4 类型转换运算符
			18.4.1 staci_cast运算符
			18.4.2 reinterpret_cast运算符
			18.4.3 const_cast运算符
			18.4.4 dynamic_cast运算符
			18.4.5 typpeid运算符
		18.5 小结
	第19章  总结
		19.1 作为传统程序设计语言的C++
			19.1.1 C++内部数据类型
			19.1.2 C++表达式
			19.1.3 C++控制流
		19.2 作为模块化语言的C++
			19.2.1 C++聚集类型之一：数组
			19.2.2 C++聚集类型之二：结构、联合和枚举类型
			19.2.3 作为模块化工具的C++函数
			19.2.4 C++函数的参数传递
			19.2.5 C++中的作用域与存储类别
		19.3 作为面向对象语言的C++
			19.3.1 C++类
			19.3.2 构造函数、析构函数和重载运算符
			19.3.3 类复合与继承
			19.3.4 虚函数与抽象类
			19.3.5 模板
			19.3.6 异常
		19.4 C++及其竞争对手
			19.4.1 C++与传统的语言
			19.4.2 C++与Visual Basic
			19.4.3 C++与C
			19.4.4 C++与Java
		19.5 小结