Effective Java 
 （第3版）

官方网站：
http://joshbloch.com/effectivejava、 https://github.com/jbloch/effective-java-3e-source-code。

★★
作者：Joshua Bloch
其他书籍：《Java 并发编程实战》、《Java 解惑》。

知识点 
1.	Java 基础知识。

代码
1.	chapter2（第2章 创建和销毁对象）

要点

第1章 引言
	★	基本的原则：
		1.	清晰性和简洁性最为重要：组件的用户永远也不应该被其行为所迷惑。
		2.	组件要尽可能小，但又不能太小。
		3.	代码应该被重用，而不是被拷贝。
		4.	组件之间的依赖性应该尽可能地降到最小。
		5.	错误应该尽早被检测出来，最好是在编译时就发现并解决。
第2章 创建和销毁对象
	第1条 用静态工厂方法代替构造器
		★	类可以提供一个公有的静态工厂方法，它只是一个返回类的实例的静态方法。
		★	静态工厂方法与构造器不同的优势在于：
			1.	它们有名称。
			2.	不必在每次调用它们的时候都创建一个新对象。
			3.	它们可以返回原返回类型的任何子类型的对象。
			4.	所返回的对象的类可以随着每次调用而发生变化，这取决于静态工厂方法的参数值。
			5.	方法返回的对象所属的类，在编写包含该静态工厂方法的类时可以不存在。
		★	这使得不可变类可以使用预先构建好的实例，或者将构建好的实例缓存起来，进行重复利用，从而避免创建不必要的重复对象。
		★	当类需要多个带有相同签名的构造器时，就用静态工厂方法代替构造器，并且仔细地选择名称以便突出静态工厂方法之间的区别。
		★	服务提供者框架是指这样一个系统：多个服务提供者实现一个服务，系统为服务提供者的客户端提供多个实现，并把它们从多个实现中解耦出来。
		★	静态工厂方法的主要缺点在：
			1.	子类如果不含公有的或者受保护的构造器，就不能被子类化。
			2.	程序员很难发现它们。
		★	静态工厂方法和公有构造器都各有用处，我们需要理解它们各自的长处。
			静态工厂经常更合适，切忌第一反应就是提供公有的构造器，不先考虑静态工厂。
	第2条 遇到多个构造器参数时要考虑使用构建器
		★	重叠构造器模式可行，但是当有许多参数的时候，客户端代码会很难缩写，并且仍然较难以阅读。		
		★	如果类的构造器或者静态工厂中具有多个参数，设计这种类时，Builde模式就是一种不错的选择，特别是当大多数参数都是可选或者类型相同的时候。
			与使用重叠构造器模式相比，使用Builder模式的客户端代码将更易于阅读和编写，构建器也比JavaBeans更加安全。
	第3条 用私有构造器或者枚举类型强化Singleton属性	
		★	使类成为Singleton会使它的害户端测试变得十分困难，因为不可能给Singleton替换模拟实现，除非实现一个充当其类型的接口。
		★	享有特权的客户端可以借助Access bleObject.setAccessible方法，通过反射机制调用私有构造器。
			如果需要抵御这种攻击，可以修改构造器，让它在被要求创建第二个实例的时候抛出异常。
		★	单元素枚举类型经常成为实现Singleton的最佳方法。
	第4条 通过私有构造器强化不可实例化的能力
		★	由于只有当类不包含显式的构造器时，编译器才会生成缺省的构造器，因此只要让这个类包含一个私有构造器，它就不能被实例化。
	第5条 优先考虑依赖注人来引用资源
		★	静态工具类和Singleton类不适合于需要引用底层资源的类。
		★	这里需要的是能够支持类的多个实例 ，每一个实例都使用客户端指定的资源。满足该需求的最简单的模式是，当创建一个新的实例时，就将该资源传到构造器中。这是依赖注入的一种形式。
  		★	不要用Singleton和静态工具类来实现依赖一个或多个底层资源的类，且该资源的行为会影响到该类的行为；
			也不要直接用这个类来创建这些资源。而应该将这些资源或者工厂传给构造器，通过它们来创建类。
			这个实践就被称作依赖注入，它极大地提升了类的灵活性、可重用性和可测试性。
	第6条 避免创建不必要的对象
		★	有些对象创建的成本比其他对象要高得多，如果重复地需要这类“昂贵的对象”，建议将它缓存起来重用。 
		★	自动装箱使得基本类型和装箱基本类型之间的差别变得模糊起来，但是并没有完全消除。
		★	要优先使用基本类型而不是装箱基本类型，要当心无意识的自动装箱。
		★	由于小对象的构造器只做很少量的显式工作，所以小对象的创建和回收动作是非常廉价的。
	第7条 消除过期的对象引用
		★	清空对象引用应该是一种例外，而不是一种规范行为。
		★	只要类是自己管理内存，程序员就应该警惕内存泄漏问题。
		★	内存泄漏的另一个常见来源是缓存。
		★	内存泄漏的第三个常见来源是监昕器和其他回调。
		★	确保回调立即被当作垃圾回收的最佳方法是只保存它们的弱引用。
	第8条 避免使用终结方法和清除方法
		★	终结方法通常是不可预测的，也是很危险的，一般情况下是不必要的。
		★	清除方法没有终结方法那么危险，但仍然是不可预测、运行缓慢，一般情况下也是不必要的。
		★	终结方法和清除方法的缺点在于不能保证会被及时执行。
		★	注重时间的任务不应该由终结方法或者清除方法来完成。
		★	永远不应该依赖终结方法或者清除方法来更新重要的持久状态。
		★	使用终结方法的另一个问题是：如果忽略在终结过程中被抛出来的未被捕获的异常，该对象的终结过程也会终止。
		★	使用终结方法和清除方法有一个非常严重的性能损失。
		★	终结方法有一个严重的安全问题：它们为终结方法攻击打开了类的大门。
		★	从构造器抛出的异常，应该足以防止对象继续存在；有了终结方法的存在，这一点就做不到了。
		★	为了防止非final类受到终结方法攻击，要编写一个空的final的finalize方法。
		★	终结方法和清除方法有两种合法用途：
			1.	终结方法或者清除方法可以充当“安全网”。
			2.	与对象的本地对等体有关。终止非关键的本地资源。
	第9条 try-with-resources优先于try-finally
		★	当Java 7引人try-with-resources语句时，所有这些问题一下子就全部解决了。
			要使用这个构造的资源，必须先实现AutoCloseable接口，其中包含了单个返回void的close方法。
		★	在处理必须关闭的资源时，始终要优先考虑用try-with-resource，而不是用try-finally。
			这样得到的代码将更加简洁、清晰，产生的异常也更有价值。
第3章 对于所有对象都通用的方法