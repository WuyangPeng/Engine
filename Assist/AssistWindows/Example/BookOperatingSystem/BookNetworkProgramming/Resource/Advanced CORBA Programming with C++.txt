基于C++ CORBA高级编程 （Advanced CORBA Programming with C++）

○
作者： Michi Henning、Steve Vinoski

知识点 
1.	网络基础知识。

前言
	预备知识
	本书范围
第1章 导论
	1.1 简介
	1.2 本书内容的组织
	1.3 CORBA版本问题
	1.4 源代码示例
	1.5 有关软件供应商
	1.6 如何与作者联系
第1部分 CORBA简介
	第2章 CORBA概述
		2.1 简介
		2.2 对象管理组
		2.3 概念和术语
		2.4 CORBA特性
			2.4.1 一般请求流
			2.4.2 OMG接口定义语言
			2.4.3 语言映射
			2.4.4 操作调用和调度软件
			2.4.5 对象适配器
			2.4.6 ORB间协议
		2.5 请求调用
			2.5.1 对象引用语义
			2.5.2 引用的获取
			2.5.3 对象引用的内容
			2.5.4 引用和代理
		2.6 CORBA应用程序的一般开发过程
		2.7 本章小结
	第3章 一个最小的CORBA应用程序
		3.1 本章概述
		3.2 编写和编译一个IDL定义
		3.3 编写和编译一个服务器程序
		3.4 编写和编译一个客户端程序
		3.5 运行客户机和服务器程序
		3.6 本章小结
第2部分 CORBA的核心
	第4章 OMG接口定义语言
		4.1 本章概述
		4.2 简介
		4.3 编译
			4.3.1 单个的客户机和服务器程序开发环境
			4.3.2 客户机和服务器程序的不同开发环境
		4.4 源文件
			4.4.1 文件的命名
			4.4.2 文件格式 
			4.4.3 预处理
			4.4.4 定义的顺序
		4.5 词法规则
			4.5.1 注释
			4.5.2 关键字
			4.5.3 标识符
		4.6 基本的IDL类型
			4.6.1 整型
			4.6.2 浮点类型
			4.6.3 字符
			4.6.4 字符串
			4.6.5 布尔量
			4.6.6 八位字节
			4.6.7 any类型
		4.7 用户定义类型
			4.7.1 命名类型
			4.7.2 枚举
			4.7.3 结构
			4.7.4 联合
			4.7.5 数组
			4.7.6 序列
			4.7.7 序列与数组
			4.7.8 递归类型
			4.7.9 常量定义和字面值
			4.7.10 常量表达式
		4.8 接口和操作
			4.8.1 接口语法
			4.8.2 接口语义和对象引用
			4.8.3 接口通信模型
			4.8.4 操作定义
		4.9 用户异常
			4.9.1 异常设计问题
		4.10 系统异常
		4.11 系统异常或用户异常
		4.12 单向操作
		4.13 上下文
		4.14 属性
		4.15 模块
		4.16 前向声明 
		4.17 继承
			4.17.1 从类型object中隐含的继承
			4.17.2 空接口
			4.17.3 接口与实现的继承
			4.17.4 继承的重定义规则
			4.17.5 继承的限定
			4.17.6 多重继承
			4.17.7 多重继承的限定
		4.18 名称和作用域
			4.18.1 命名作用域
			4.18.2 区分大小写
			4.18.3 在嵌套作用域中的名称
			4.18.4 名称查找规则
		4.19 仓库标识符和pragma指令
			4.19.1 IDL的仓库ID格式 
			4.19.2 prefix的附注
			4.19.3 版本附注
			4.19.4 使用ID附注来控制仓库的ID格式
		4.20 标准的include文件
		4.21 最新的IDL扩展
			4.21.1 宽位字符和字符串
			4.21.2 64位整型
			4.21.3 扩展的浮点类
			4.21.4 定点十进制类型
			4.21.5 转义标识符
		4.22 本章小结
	第5章 一个气温控制系统的IDL
		5.1 本章概述
		5.2 气温控制系统
			5.2.1 温度计
			5.2.2 恒温器
			5.2.3 监测站
		5.3 气温控制系统的IDL
			5.3.1 温度计的IDL
			5.3.2 恒温计的IDL
			5.3.3 控制器的IDL
		5.4 完事的程序
	第6章 基本的IDL到C++的映射
		6.1 本章概述
		6.2 简介
		6.3 标识符的映射
		6.4 模块的映射
		6.5 CORBA模块
		6.6 基本类型的映射
			6.6.1 64位整型和long double类型
			6.6.2 基本类型的重载
			6.6.3 可映射成char的类型
			6.6.4 wchar的映射
			6.6.5 Boolean映射
			6.6.6 字符串和宽位字符串映射
		6.7 常量的映射
		6.8 枚举类型的映射 
		6.9 变长度的类型与_var类型
			6.9.1 _var类型的使用
			6.9.2 变长度类型的内存管理
		6.10 String_var封装类
			6.10.1 使用String_var的缺陷
			6.10.2 将字符串作为传递参数以读取字符串
			6.10.3 将字符串作为传递参数以更改字符串
			6.10.4 隐式类型转换产生的问题
			6.10.5 取得对字符串的所有权
			6.10.6 流运算符
		6.11 宽位字符串的映射
		6.12 定点娄类型的映射
			6.12.1 构造函数
			6.12.2 存取函数
			6.12.3 转换运算符
			6.12.4 截断与舍入
			6.12.5 算术运算符
			6.12.6 流运算符
		6.13 结构的映射
			6.13.1 定长度结构的映射
			6.13.2 变长度结构的映射
			6.13.3 结构的内存管理
			6.13.4 包含结构成员的结构
		6.14 序列的映射
			6.14.1 无界序列的映射
			6.14.2 有界序列的映射
			6.14.3 序列使用中的一些限制
			6.14.4 序列的使用规则
		6.15 数组的映射
		6.16 联合的映射
			6.16.1 联合的初始化和赋值
			6.16.2 联合的成员与鉴别器的访问
			6.16.3 没有default语句的联合
			6.16.4 包含复杂成员的联合
			6.16.5 使用联合的规则
		6.17 递归结构和递归联合的映射
		6.18 类型定义的映射
		6.19 用户定义类型和_var类
			6.19.1 用于结构、联合和序列的var类
			6.19.2 _var类的简单使用
			6.19.3 使用_var类的一些缺陷
			6.19.4 定长度的结构、联合和序列与变长度的结构、联合和序列之间的区别
			6.19.5 数组的_var类型
		6.20 本章小结
	第7章 客户端的C++映射
		7.1 本章概述
		7.2 简介
		7.3 接口的映射
		7.4 对象引用类型
		7.5 对象引用的生命周期
			7.5.1 删除引用
			7.5.2 引用拷贝
			7.5.3 引用计数值的范围
			7.5.4 空引用 
		7.6 _ptr引用的语义
			7.6.1 代理与_ptr引用的映射
			7.6.2 继承与拓展
			7.6.3 紧缩转换
			7.6.4 类型安全的紧缩
			7.6.5 非法使用ptr引用 
		7.7 伪对象
		7.8 ORB的初始化
		7.9 初始引用
			7.9.1 将字符串转换成引用 
			7.9.2 将引用转换成字符串
		7.10 字符串化引用 
			7.10.1 初始的字符串化引用 
			7.10.2 字符串化引用的长度
			7.10.3 字符串化引用的互用性
			7.10.4 字符串化引用的规则
		7.11 对象的伪接口
			7.11.1 is-a操作
			7.11.2 non_existent操作
			7.11.3 _is_equivalent操作
			7.11.4 _hash操作
			7.11.5 Object操作映射小结
		7.12 _var引用
			7.12.1 _var引用的映射
			7.12.2 _var引用与拓展
			7.12.3 同时使用_var和_ptr引用
			7.12.4 嵌套在用户定义类型中的引用 
			7.12.5 _var类型的效率
		7.13 操作与属性的映射
			7.13.1 操作的映射
			7.13.2 属性的映射
		7.14 参数传递规则
			7.14.1 定长度类型与变长度类型
			7.14.2 生成的_out类型
			7.14.3 简单类型的参数传递
			7.14.4 复杂的定长度类型的参数传递
			7.14.5 包含定长度元素的数组的参数传递
			7.14.6 变长度参数的内存管理
			7.14.7 字符串和宽位字符串的参数传递
			7.14.8 复杂变长度类型和Any类型的参数传递
			7.14.9 包含变长度元素数组的参数传递
			7.14.10 对象引用的参数传递
			7.14.11 参数传递规则的小结
			7.14.12 使用_var类型来传递参数
			7.14.13 释放out参数和使用_out类型的目的
			7.14.14 参数的只读性质
			7.14.15 参数传递的陷阱
		7.15 异常映射
			7.15.1 系统异常的映射
			7.15.2 系统异常的语义
			7.15.3 用户异常的映射
			7.15.4 异常说明
			7.15.5 异常和out参数
			7.15.6 ostream插入符
			7.15.7 不支持异常的编译器的映射
		7.16 上下文的映射
		7.17 本章小结
	第8章 开发气温控制系统的客户程序
		8.1 本章概述
		8.2 简介
		8.3 客户程序的总体结构
		8.4 包含文件
		8.5 辅助函数
			8.5.1 显示装置的具体内容
			8.5.2 打印出错异常信息
		8.6 main函数
			8.6.1 初始化
			8.6.2 与服务器程序的交互
		8.7 完整的客户程序代码
		8.8 本章小结
	第9章 服务器端C++映射
		9.1 本章概述
		9.2 简介
		9.3 接口的映射
		9.4 伺服类
		9.5 对象的实体
		9.6 服务器程序的main函数
		9.7 参数传递规则
			9.7.1 简单类型的参数传递
			9.7.2 复杂的定长度类型的参数传递
			9.7.3 包含定长度元素数组的参数传递
			9.7.4 字符串和宽位字符串的参数传递
			9.7.5 复杂的变长度类型和any类型的参数传递
			9.7.6 包含变长元素数组的参数传递
			9.7.7 对象引用的参数传递
		9.8 引发异常
			9.8.1 异常发送的具体细节
			9.8.2 发送CORBA系统异常
			9.8.3 管理出现异常的内存
		9.9 Tie类
			9.9.1 tie类的具体细节
			9.9.2 tie伺服程序的具体化
			9.9.3 tie类的评价
		9.10 本章小结
	第10章 开发气温控制系统的服务器程序
		10.1 本章概述
		10.2 简介
		10.3 仪器控制协议的API
			10.3.1 添加和删除装置
			10.3.2 读取属性值
			10.3.3 写属性值
		10.4 设计温度计的伺服类
		10.5 实现温度计的伺服类
			10.5.1 Thermometer_impl的辅助函数
			10.5.2 Thermometer_impl的IDL操作
			10.5.3 Thermometer_impl的构造函数和析构函数
		10.6 设计恒温器的伺服类
		10.7 实现Thermostat的伺服类
			10.7.1 Thermostat_impl的辅助函数
			10.7.2 Thermostat_impl的IDL操作
			10.7.3 Thermostat_impl的构造函数和析构函数
		10.8 设计控制器的伺服类
		10.9 实现控制器的伺服类
			10.9.1 Controller_impl辅助函数
			10.9.2 实现list操作
			10.9.3 实现change操作
			10.9.4 实现find操作
		10.10 实现服务器程序的main函数
		10.11 完整的服务器程序代码
			10.11.1 server.hh头文件
			10.11.2 server.cc实现文件
		10.12 本章小结
	第11章 可移植的对象适配器
		11.1 本章概述
		11.2 简介
		11.3 POA基本原理 
			11.3.1 基本的请求调度
			11.3.2 关键的POA实体
		11.4 POA策略
			11.4.1 CORBA对象生存期范围
			11.4.2 对象标识符
			11.4.3 对象到伺服程序之间的映射
			11.4.4 隐式激活
			11.4.5 请求与伺服程序之间的匹配
			11.4.6 ObjectId到伺服程序的关联
			11.4.7 请求到线程的分配
			11.4.8 策略工厂操作
		11.5 POA创建
		11.6 Servant IDL类型
			11.6.1 CCS::Thermometer伺服程序
		11.7 对象创建和激活
			11.7.1 对象创建
			11.7.2 伺服程序注册 
			11.7.3 伺服程序管理器
			11.7.4 默认的伺服程序
			11.7.5 伺服程序内存管理
			11.7.6 请求处理
		11.8 引用ObjectId和伺服程序
		11.9 对象失效
		11.10 请求流控制
		11.11 ORB事件处理
			11.11.1 阻塞事件处理
			11.11.2 非阻塞事件处理
			11.11.3 应用程序停止运行
		11.12 POA激活
		11.13 POA析构
		11.14 应用POA策略
			11.14.1 多线程问题
			11.14.2 ObjectId赋值
			11.14.3 激活 
			11.14.4 时空折衷
			11.14.5 关于生命范围的考虑
		11.15 本章小结
	第12章 对象生命周期
		12.1 本章概述
		12.2 简介
		12.3 对象工厂
			12.3.1 工厂设计选项
			12.3.2 用C++实现工厂
		12.4 撤消、拷贝以及移动对象
			12.4.1 撤消对象
			12.4.2 拷贝对象
			12.4.3 移动对象
			12.4.4 通用工厂
		12.5 对生命周期服务的评论
			12.5.1 设计的通则
			12.5.2 发布日期
			12.5.3 使用move操作的问题
			12.5.4 接口的粒度
			12.5.5 在什么情况下使用生命周期服务
		12.6 Evictor模式
			12.6.1 基本的收回策略
			12.6.2 维护LRU顺序
			12.6.3 使用伺服程序定位器实现收回模型
			12.6.4 对使用伺服程序定位器的收回模型的评价
			12.6.5 使用伺服程序激活器来实现收回模型
			12.6.6 对使用伺服程序激活器的收回模型的评价
			12.6.7 与汇集管理器操作的交互
		12.7 伺服程序的无用存储单元回收
			12.7.1 客户机意外行为的处理
			12.7.2 通过关机进行无用存储单元回收
			12.7.3 使用收回模型进行无用存储单元回收
			12.7.4 使用超时进行无用存储单元回收
			12.7.5 显示保持激活
			12.7.6 每个对象逆向保持激活
			12.7.7 每个客户逆向保持激活
			12.7.8 检测客户的断连
			12.7.9 分布式引用计数
			12.7.10 选择方案小结
		12.8 CORBA对象的无用存储单元回收
			12.8.1 太平洋问题
			12.8.2 引用完整性
			12.8.3 无用存储单元回收的未来
		12.9 本章小结
第3部分 CORBA机理
	第13章 GIOP,IIOP和IOR
		13.1 本章概述
		13.2 GIOP概述
			13.2.1 传输假设
		13.3 公共数据表示
			13.3.1 CDR数据对齐
		13.4 GIOP消息格式
			13.4.1 Request消息格式
			13.4.2 Reply消息格式
			13.4.3 其他消息格式
		13.5 GIOP连接管理
		13.6 检测无序的关闭
		13.7 IIOP综述
		13.8 IOR的结构
		13.9 双向IIOP
		13.10 本章小结
	第14章 实现仓库和绑定
		14.1 本章概述
		14.2 绑定模式
		14.3 直接绑定
			14.3.1 暂态引用的直接绑定
			14.3.2 持久引用的直接绑定
		14.4 通过实现仓库的间接绑定
			14.4.1 实现仓库的标准一致性
			14.4.2 实现仓库结构
			14.4.3 定位域
			14.4.4 服务器程序和实现仓库之间的相互影响
			14.4.5 通过实现仓库的绑定
			14.4.6 绑定优化
		14.5 迁移、可靠性、性能和可扩展性
			14.5.1 小定位域
			14.5.2 大定位域
			14.5.3 冗余的实现仓库
			14.5.4 对象迁移的粒度
			14.5.5 跨定位域边界的迁移
		14.6 激活模式
		14.7 竞争状态
			14.7.1 激活期间的竞争状态
			14.7.2 关闭期间的竞争状态
			14.7.3 服务器程序关闭和重新绑定
		14.8 安全性考虑
			14.8.1 服务器程序的权限
			14.8.2 远程仓库访问
			14.8.3 通过防火墙的IIOP
		14.9 本章小结
第4部分 动态CORBA
	第15章 any类型的C++映射
		15.1 本章概述
		15.2 简介
		15.3 any类型C++映射
			15.3.1 构造函数、析构函数和赋值
			15.3.2 基本类型
			15.3.3 重载不可区分的类型
			15.3.4 无界的字符串的插入和提取
			15.3.5 有界的字符串的插入和提取
			15.3.6 宽位字符串的插入和提取
			15.3.7 定点类型的插入和提取
			15.3.8 用户定义类型
			15.3.9 插入和提取Any
			15.3.10 插入和提取异常
		15.4 类型定义中易出现的问题
		15.5 本章小结
	第16章 类型代码
		16.1 本章概述
		16.2 简介
		16.3 TypeCode伪对象
			16.3.1 适用于所有类型代码的类型和操作
			16.3.2 类型代码参数
			16.3.3 作为值的类型代码
		16.4 TypeCode伪对象的C++映射
		16.5 类型代码比较
			16.5.1 TypeCode::equal的语义
			16.5.2 TypeCode::equivalent的语义
			16.5.3 为什么让类型代码中的名称是可选项
			16.5.4 类型代码比较的可移植性
			16.5.5 从any类型提取的语义
			16.5.6 结构上的等价
			16.5.7 get_compact_tupecode操作
		16.6 类型代码常量 
			16.6.1 内置类型的常量
			16.6.2 自定义类型的常量
		16.7 any类型的类型代码比较 
			16.7.1 控制在Any类型中插入的别名信息
			16.7.2 检验从Any类型中提取的别名信息
		16.8 动态创建类型代码
			16.8.1 用于类型代码创建的IDL
			16.8.2 类型代码创建的C++映射
		16.9 本章小结
	第17章 DynAny类型
		17.1 本章概述
		17.2 简介
		17.3 DynAny接口
			17.3.1 局部约束
			17.3.2 用于DynAny的IDL
			17.3.3 用于DynEnum的IDL
			17.3.4 用于DynStruct的IDL
			17.3.5 用于DynUnion的IDL
			17.3.6 用于DynSequence的IDL
			17.3.7 用于DynArray的IDL
			17.3.8 用于DynFixed的IDL
		17.4 DynAny伪对象的C++映射
			17.4.1 简单类型的DynAny应用
			17.4.2 使用DynEnum
			17.4.3 使用DynStruct
			17.4.4 使用DynUnion
			17.4.5 使用DynSequence
		17.5 用于通用显示的DynAny
		17.6 获得类型信息
			17.6.1 从OMG接口仓库获得类型信息
			17.6.2 从转换表中获得类型信息
			17.6.3 从表达式获得类型信息
		17.7 本章小结
第5部分 CORBA服务
	第18章 OMG命名服务
		18.1 本章概述
		18.2 简介
		18.3 基本概念
		18.4 命名服务IDL的结构
		18.5 名称的语义
			18.5.1 名称结构
			18.5.2 名称的表达
			18.5.3 kind字段的作用
			18.5.4 不支持宽位字符串
			18.5.5 名称的等价性
			18.5.6 绝对与相对名称
			18.5.7 名称解析
		18.6 命名上下文的IDL
			18.6.1 命名服务中的异常
			18.6.2 上下文的生命周期
			18.6.3 获得初始命名上下文
			18.6.4 创建一个绑定
			18.6.5 建立一个命名图
			18.6.6 重绑定
			18.6.7 取消绑定
			18.6.8 正确地撤消上下文
			18.6.9 解析名称
		18.7 迭代器
			18.7.1 使用迭代器的必要性
			18.7.2 拉迭代器
			18.7.3 推迭代器
			18.7.4 命名服务迭代器
		18.8 命名服务中容易出错的地方
		18.9 名称库
		18.10 命名服务工具
		18.11 怎样公告对象
		18.12 公告的时机
		18.13 联邦化命名
			18.13.1 完全连接的联邦化结构
			18.13.2 层次化的联邦结构
			18.13.3 混合结构
		18.14 给气温控制系统增加命名
			18.14.1 通用的辅助函数
			18.14.2 更新气温控制系统的服务器程序
			18.14.3 更新气温控制系统的客户程序
		18.15 本章小结
	第19章 OMG交易服务
		19.1 本章概述
		19.2 简介
		19.3 交易的概念和术语 
			19.3.1 基本的交易概念
			19.3.2 服务类型和IDL接口类型
			19.3.3 服务请求
			19.3.4 约束表达式
			19.3.5 联邦
			19.3.6 动态属性
			19.3.7 代理提供源
			19.3.8 优先权
			19.3.9 策略
		19.4 IDL概述
		19.5 服务类型仓库
			19.5.1 属性
			19.5.2 服务类型的继承
			19.5.3 服务类型仓库的IDL
			19.5.4 在C++内使用服务类型仓库
		19.6 交易接口
			19.6.1 主要接口
			19.6.2 抽象基接口
			19.6.3 迭代器
			19.6.4 公共类型
		19.7 导出服务提供源
			19.7.1 export操作的IDL定义
			19.7.2 导出服务提供源的C++代码
			19.7.3 附加属性
		19.8 收回服务提供源
		19.9 改变服务提供源
		19.10 交易程序约束语言
			19.10.1 字面值
			19.10.2 标识符
			19.10.3 比较运算符
			19.10.4 算术运算符
			19.10.5 布尔运算符
			19.10.6 集合成员
			19.10.7 子串的匹配
			19.10.8 存在性测试
			19.10.9 优先权
			19.10.10 约束语言的示例程序
		19.11 导入服务提供源
			19.11.1 Lookup接口的IDL
			19.11.2 编制一个简单的查询程序
			19.11.3 OfferInterator接口
			19.11.4 控制query返回的细节
			19.11.5 使用优先权
			19.11.6 导入策略
		19.12 成批收回
		19.13 Admin接口
			19.13.1 设定配置值
			19.13.2 检索服务提供源ID
		19.14 检测服务提供源
		19.15 导出动态属性
		19.16 交易程序联邦
			19.16.1 链接和联邦的策略
			19.16.2 请求标识符
			19.16.3 指定一个起始的交易
			19.16.4 Link接口
			19.16.5 定位交易程序的Register接口
			19.16.6 联邦和导入策略
		19.17 交易程序工具
		19.18 交易程序的体系结构
		19.19 如何发布公告
		19.20 避免重复服务提供源
		19.21 向气温控制系统添加交易
			19.21.1 为控制器创建服务类型
			19.21.2 为控制器导出服务提供源
			19.21.3 向控制器导入引用 
		19.22 本章小结
	第20章 OMG事件服务
		20.1 本章概述
		20.2 简介
		20.3 分布式回调
			20.3.1 回调的示例
			20.3.2 回调出现的问题
			20.3.3 分布式回调的评价
		20.4 事件服务基础
			20.4.1 经典的推模型
			20.4.2 经典的拉模型
			20.4.3 混合推/位模型
			20.4.4 混合拉/推模型
			20.4.5 混合事件模型
		20.5 事件服务接口
			20.5.1 推模型接口
			20.5.2 拉模型接口
			20.5.3 事件通道接口
			20.5.4 事件通道的联邦
		20.6 实现使用者和提供者
			20.6.1 获得一个EventChannel引用
			20.6.2 实现一个推提供者
			20.6.3 实现一个推使用者
			20.6.4 实现一个拉提供者
			20.6.5 实现一个拉使用者
		20.7 选择一个事件模型
			20.7.1 事件通道的实现
			20.7.2 推模型浅析
			20.7.3 拉模型浅析
		20.8 事件服务的局限性
			20.8.1 多个提供者
			20.8.2 可靠性的缺陷
			20.8.3 筛选性的缺陷
			20.8.4 工厂的缺陷
			20.8.5 异步消息传送
		20.9 本章小结
第6部分 功能强大的CORBA
	第21章 多线程应用程序
		21.1 本章概述 
		21.2 简介
		21.3 多线程编程的动机
			21.3.1 请求的排队
			21.3.2 事件处理
			21.3.3 单线程服务器程序的评价
			21.3.4 多线程编程的优点
		21.4 多线程服务器程序的基础
			21.4.1 ORB底层的多线程问题
			21.4.2 POA多线程问题
			21.4.3 伺服程序的多线程问题
			21.4.4 第三方库问题
			21.4.5 ORB事件处理的多线程问题
		21.5 多线程策略
		21.6 实现多线程服务器程序
			21.6.1 CCS生命周期操作的复习
			21.6.2 总体的应用程序问题
			21.6.3 并发性问题
			21.6.4 Controller_impl伺服类
			21.6.5 创建操作的实现
			21.6.6 Devicelocator_impl伺服程序定位器
			21.6.7 实现preinvoke
			21.6.8 实现温度计的伺服程序
			21.6.9 多线程收回器的评价
		21.7 伺服程序激活器和收回器模式
		21.8 本章小结
	第22章 性能、可扩展性和可维护性
		22.1 本章概述
		22.2 简介
		22.3 减少消息开销
			22.3.1 基本IIOP性能限制
			22.3.2 粗操作
			22.3.3 粗略对象模型
			22.3.4 客户端调整缓冲存取
		22.4 优化服务器程序的实现
			22.4.1 线程化服务器程序
			22.4.2 为每个对象服先单独的伺服程序
			22.4.3 伺服程序的定位器和激活器
			22.4.4 收回器模式
			22.4.5 默认伺服程序
			22.4.6 定制对象引用
			22.4.7 服务器端调整缓存
		22.5 联邦服务
		22.6 改进物理设计
		22.7 本章小结
附录A ICP模拟器的源代码
附录B CORBA资源