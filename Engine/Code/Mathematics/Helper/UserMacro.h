///	Copyright (c) 2010-2023
///	Threading Core Render Engine
///
///	作者：彭武阳，彭晔恩，彭晔泽
///	联系作者：94458936@qq.com
///
///	标准：std:c++20
///	版本：0.9.1.6 (2023/10/26 09:50)

#ifndef MATHEMATICS_HELPER_USER_MACRO_H
#define MATHEMATICS_HELPER_USER_MACRO_H

#include "CoreTools/Helper/UserMacro.h"

#define MATHEMATICS_ClOSE_BEGIN (0x01)

#define CLOSE_USE_EXPORT_TEMPLATE (MATHEMATICS_ClOSE_BEGIN)
#define CLOSE_USE_MATHEMATICS_TEMPLATE_TEST (MATHEMATICS_ClOSE_BEGIN << 1)  // 默认关闭
#define CLOSE_USE_ASSERT_ON_RATIONAL_CONVERT_NAN (MATHEMATICS_ClOSE_BEGIN << 2)
#define CLOSE_USE_ASSERT_ON_BARYCENTRIC2_DEGENERATE (MATHEMATICS_ClOSE_BEGIN << 3)
#define CLOSE_USE_ASSERT_ON_BARYCENTRIC3_DEGENERATE (MATHEMATICS_ClOSE_BEGIN << 4)
#define CLOSE_USE_NORMALIZE_EPSILON (MATHEMATICS_ClOSE_BEGIN << 5)
#define CLOSE_USE_MATHEMATICS_PRECISION (MATHEMATICS_ClOSE_BEGIN << 6)
#define CLOSE_USE_ROW_MAJOR (MATHEMATICS_ClOSE_BEGIN << 7)
#define CLOSE_USE_MATRIX_VECTOR (MATHEMATICS_ClOSE_BEGIN << 8)
#define CLOSE_USE_ASSERT_ON_QUADRATIC_FIELDS_NUMBER_MISMATCHED_D (MATHEMATICS_ClOSE_BEGIN << 9)
#define CLOSE_USE_DISCARD_FMA (MATHEMATICS_ClOSE_BEGIN << 10)  // 默认关闭
#define CLOSE_USE_THROW_ON_CONVERT_FROM_INFINITY_OR_NAN (MATHEMATICS_ClOSE_BEGIN << 11)
#define CLOSE_USE_BINARY_SCIENTIFIC_SHOW_DOUBLE (MATHEMATICS_ClOSE_BEGIN << 12)
#define CLOSE_USE_THROW_ON_LCP_SOLVER_ERRORS (MATHEMATICS_ClOSE_BEGIN << 13)
#define CLOSE_USE_APPROXIMATION_QUERY_VALIDATE_INDICES (MATHEMATICS_ClOSE_BEGIN << 14)

#define MATHEMATICS_ClOSE_END CLOSE_USE_APPROXIMATION_QUERY_VALIDATE_INDICES

#define CLOSE_MATHEMATICS_MAX (((MATHEMATICS_ClOSE_END) << 1) - 1)

// 编译测试（默认为0B0000'0100'0000'0010，最大值为0B0111'1111'1111'1111）
#define COMPILE_MATHEMATICS_CLOSE 0B0000'0100'0000'0000

static_assert(0 <= COMPILE_MATHEMATICS_CLOSE, "COMPILE_MATHEMATICS_CLOSE Must be greater than or equal 0.");
static_assert(COMPILE_MATHEMATICS_CLOSE <= CLOSE_MATHEMATICS_MAX, "COMPILE_MATHEMATICS_CLOSE Must be less than or equal CLOSE_MATHEMATICS_MAX.");

#if !defined(COMPILE_MATHEMATICS_CLOSE) || (COMPILE_MATHEMATICS_CLOSE & CLOSE_USE_EXPORT_TEMPLATE) != CLOSE_USE_EXPORT_TEMPLATE

    #ifndef BUILDING_STATIC

        #define MATHEMATICS_EXPORT_TEMPLATE static_cast<void>(0)

    #endif  // BUILDING_STATIC

#endif  // !defined(COMPILE_MATHEMATICS_CLOSE) || (COMPILE_MATHEMATICS_CLOSE & CLOSE_USE_EXPORT_TEMPLATE) != CLOSE_USE_EXPORT_TEMPLATE

#ifdef MATHEMATICS_EXPORT_TEMPLATE

    #define MATHEMATICS_TEMPLATE_DEFAULT_DECLARE MATHEMATICS_DEFAULT_DECLARE
    #define MATHEMATICS_TEMPLATE_HIDDEN_DECLARE MATHEMATICS_HIDDEN_DECLARE

#else  // !MATHEMATICS_EXPORT_TEMPLATE

    #define MATHEMATICS_TEMPLATE_DEFAULT_DECLARE
    #define MATHEMATICS_TEMPLATE_HIDDEN_DECLARE

#endif  // MATHEMATICS_EXPORT_TEMPLATE

#if !defined(COMPILE_MATHEMATICS_CLOSE) || (COMPILE_MATHEMATICS_CLOSE & CLOSE_USE_MATHEMATICS_TEMPLATE_TEST) != CLOSE_USE_MATHEMATICS_TEMPLATE_TEST

    #ifndef BUILDING_STATIC

        #define MATHEMATICS_TEMPLATE_TEST static_cast<void>(0)

    #endif  // BUILDING_STATIC

#endif  // !defined(COMPILE_MATHEMATICS_CLOSE) || (COMPILE_MATHEMATICS_CLOSE & CLOSE_USE_MATHEMATICS_TEMPLATE_TEST) != CLOSE_USE_MATHEMATICS_TEMPLATE_TEST

// 如果希望Rational类在构造函数传递浮点无穷大或NaN时断言，请启用此定义。
#if !defined(COMPILE_MATHEMATICS_CLOSE) || (COMPILE_MATHEMATICS_CLOSE & CLOSE_USE_ASSERT_ON_BARYCENTRIC2_DEGENERATE) != CLOSE_USE_ASSERT_ON_RATIONAL_CONVERT_NAN

    #define MATHEMATICS_ASSERT_ON_RATIONAL_CONVERT_NAN static_cast<void>(0)

#endif  // !defined(COMPILE_MATHEMATICS_CLOSE) || (COMPILE_MATHEMATICS_CLOSE & CLOSE_USE_ASSERT_ON_RATIONAL_CONVERT_NAN) != CLOSE_USE_ASSERT_ON_RATIONAL_CONVERT_NAN

// 如果希望Vector2<Real>::GetBarycentrics在输入退化三角形时断言，请启用此定义。
#if !defined(COMPILE_MATHEMATICS_CLOSE) || (COMPILE_MATHEMATICS_CLOSE & CLOSE_USE_ASSERT_ON_BARYCENTRIC2_DEGENERATE) != CLOSE_USE_ASSERT_ON_BARYCENTRIC2_DEGENERATE

    #define MATHEMATICS_ASSERT_ON_BARYCENTRIC2_DEGENERATE static_cast<void>(0)

#endif  // !defined(COMPILE_MATHEMATICS_CLOSE) || (COMPILE_MATHEMATICS_CLOSE & CLOSE_USE_ASSERT_ON_BARYCENTRIC2_DEGENERATE) != CLOSE_USE_ASSERT_ON_BARYCENTRIC2_DEGENERATE

// 如果希望Vector3<Real>::GetBarycentrics在输入退化四面体时断言，请启用此定义。
#if !defined(COMPILE_MATHEMATICS_CLOSE) || (COMPILE_MATHEMATICS_CLOSE & CLOSE_USE_ASSERT_ON_BARYCENTRIC3_DEGENERATE) != CLOSE_USE_ASSERT_ON_BARYCENTRIC3_DEGENERATE

    #define MATHEMATICS_ASSERT_ON_BARYCENTRIC3_DEGENERATE static_cast<void>(0)

#endif  // !defined(COMPILE_MATHEMATICS_CLOSE) || (COMPILE_MATHEMATICS_CLOSE & CLOSE_USE_ASSERT_ON_BARYCENTRIC3_DEGENERATE) != CLOSE_USE_ASSERT_ON_BARYCENTRIC3_DEGENERATE

#if !defined(COMPILE_MATHEMATICS_CLOSE) || (COMPILE_MATHEMATICS_CLOSE & CLOSE_USE_NORMALIZE_EPSILON) != CLOSE_USE_NORMALIZE_EPSILON

    // 启用时，Normalize计算时不使用参数epsilon，而直接使用Math::epsilon。
    #define MATHEMATICS_NORMALIZE_EPSILON static_cast<void>(0)

#endif  // !defined(COMPILE_MATHEMATICS_CLOSE) || (COMPILE_MATHEMATICS_CLOSE & CLOSE_USE_NORMALIZE_EPSILON) != CLOSE_USE_NORMALIZE_EPSILON

#if !defined(COMPILE_MATHEMATICS_CLOSE) || (COMPILE_MATHEMATICS_CLOSE & CLOSE_USE_MATHEMATICS_PRECISION) != CLOSE_USE_MATHEMATICS_PRECISION

    // 启用精度更高的算法。
    #define MATHEMATICS_PRECISION 2

#endif  // !defined(COMPILE_MATHEMATICS_CLOSE) || (COMPILE_MATHEMATICS_CLOSE & CLOSE_USE_MATHEMATICS_PRECISION) != CLOSE_USE_MATHEMATICS_PRECISION

#if !defined(COMPILE_MATHEMATICS_CLOSE) || (COMPILE_MATHEMATICS_CLOSE & CLOSE_USE_ROW_MAJOR) != CLOSE_USE_ROW_MAJOR

    // 启用此宏矩阵按行主顺序存储。如果需要列主序矩阵，请关闭此预处理器符号。
    #define MATHEMATICS_USE_ROW_MAJOR static_cast<void>(0)

#endif  // !defined(COMPILE_MATHEMATICS_CLOSE) || (COMPILE_MATHEMATICS_CLOSE & CLOSE_USE_ROW_MAJOR) != CLOSE_USE_ROW_MAJOR

#if !defined(COMPILE_MATHEMATICS_CLOSE) || (COMPILE_MATHEMATICS_CLOSE & CLOSE_USE_MATRIX_VECTOR) != CLOSE_USE_MATRIX_VECTOR

    // 启用此宏矩阵M对向量V的作用是M*V。如果希望操作为V*M，请关闭此预处理器符号。
    #define MATHEMATICS_USE_MATRIX_VECTOR static_cast<void>(0)

#endif  // !defined(COMPILE_MATHEMATICS_CLOSE) || (COMPILE_MATHEMATICS_CLOSE & CLOSE_USE_MATRIX_VECTOR) != CLOSE_USE_MATRIX_VECTOR

#if !defined(COMPILE_MATHEMATICS_CLOSE) || (COMPILE_MATHEMATICS_CLOSE & CLOSE_USE_ASSERT_ON_QUADRATIC_FIELDS_NUMBER_MISMATCHED_D) != CLOSE_USE_ASSERT_ON_QUADRATIC_FIELDS_NUMBER_MISMATCHED_D

    // 如果希望日志记录系统在对不共享相同值d的两个二次元素执行算术运算时捕获，请启用此宏。
    #define MATHEMATICS_USE_ASSERT_ON_QUADRATIC_FIELDS_NUMBER_MISMATCHED_D static_cast<void>(0)

#endif  // !defined(COMPILE_MATHEMATICS_CLOSE) || (COMPILE_MATHEMATICS_CLOSE & CLOSE_USE_ASSERT_ON_QUADRATIC_FIELDS_NUMBER_MISMATCHED_D) != CLOSE_USE_ASSERT_ON_QUADRATIC_FIELDS_NUMBER_MISMATCHED_D

#if !defined(COMPILE_MATHEMATICS_CLOSE) || (COMPILE_MATHEMATICS_CLOSE & CLOSE_USE_DISCARD_FMA) != CLOSE_USE_DISCARD_FMA

    #define MATHEMATICS_DISCARD_FMA static_cast<void>(0)

#endif  // !defined(COMPILE_MATHEMATICS_CLOSE) || (COMPILE_MATHEMATICS_CLOSE & CLOSE_USE_DISCARD_FMA) != CLOSE_USE_DISCARD_FMA

#if !defined(COMPILE_MATHEMATICS_CLOSE) || (COMPILE_MATHEMATICS_CLOSE & CLOSE_USE_THROW_ON_CONVERT_FROM_INFINITY_OR_NAN) != CLOSE_USE_THROW_ON_CONVERT_FROM_INFINITY_OR_NAN

    /// 当无穷大或NaN是浮点输入时，启用此选项可在ConvertFrom中引发异常。
    /// BinaryScientificNumber没有这些数字的表示法。
    #define MATHEMATICS_THROW_ON_CONVERT_FROM_INFINITY_OR_NAN static_cast<void>(0)

#endif  // !defined(COMPILE_MATHEMATICS_CLOSE) || (COMPILE_MATHEMATICS_CLOSE & CLOSE_USE_THROW_ON_CONVERT_FROM_INFINITY_OR_NAN) != CLOSE_USE_THROW_ON_CONVERT_FROM_INFINITY_OR_NAN

#ifdef _DEBUG

    #if !defined(COMPILE_MATHEMATICS_CLOSE) || (COMPILE_MATHEMATICS_CLOSE & CLOSE_USE_BINARY_SCIENTIFIC_SHOW_DOUBLE) != CLOSE_USE_BINARY_SCIENTIFIC_SHOW_DOUBLE

        /// 支持调试使用精确有理运算的算法。
        /// 每个BinaryScientificNumber和BinaryScientificRational都有一个双精度成员，该成员在启用条件定义时公开。
        /// 请注意，这可能非常缓慢，因为每当通过算术运算创建新对象时，都会转换为双倍精度。
        /// 作为一种更快的选择，您可以在算法中添加临时代码，将特定有理数显式转换为双精度。
        #define MATHEMATICS_BINARY_SCIENTIFIC_SHOW_DOUBLE static_cast<void>(0)

    #endif  // !defined(COMPILE_MATHEMATICS_CLOSE) || (COMPILE_MATHEMATICS_CLOSE & CLOSE_USE_BINARY_SCIENTIFIC_SHOW_DOUBLE) != CLOSE_USE_BINARY_SCIENTIFIC_SHOW_DOUBLE

#endif  // _DEBUG

#if !defined(COMPILE_MATHEMATICS_CLOSE) || (COMPILE_MATHEMATICS_CLOSE & CLOSE_USE_THROW_ON_LCP_SOLVER_ERRORS) != CLOSE_USE_THROW_ON_LCP_SOLVER_ERRORS

    /// 如果您希望代码引发算法无法收敛的异常，请暴露以下预处理器符号。
    /// 您可以选择捕获异常并根据需要进行处理。
    /// 如果你不公开预处理器符号，你可以传递一个Result对象，检查算法是否未能收敛。
    /// 同样，你可以随意处理。
    #define MATHEMATICS_THROW_ON_LCP_SOLVER_ERRORS static_cast<void>(0)

#endif  // !defined(COMPILE_MATHEMATICS_CLOSE) || (COMPILE_MATHEMATICS_CLOSE & CLOSE_USE_THROW_ON_LCP_SOLVER_ERRORS) != CLOSE_USE_THROW_ON_LCP_SOLVER_ERRORS

#if !defined(COMPILE_MATHEMATICS_CLOSE) || (COMPILE_MATHEMATICS_CLOSE & CLOSE_USE_APPROXIMATION_QUERY_VALIDATE_INDICES) != CLOSE_USE_APPROXIMATION_QUERY_VALIDATE_INDICES

    /// 如果希望代码验证拟合函数的传入索引是否有效，请显示此定义。
    #define MATHEMATICS_APPROXIMATION_QUERY_VALIDATE_INDICES static_cast<void>(0)

#endif  // !defined(COMPILE_MATHEMATICS_CLOSE) || (COMPILE_MATHEMATICS_CLOSE & CLOSE_USE_APPROXIMATION_QUERY_VALIDATE_INDICES) != CLOSE_USE_APPROXIMATION_QUERY_VALIDATE_INDICES

namespace Mathematics
{
#ifdef MATHEMATICS_BINARY_SCIENTIFIC_SHOW_DOUBLE

    constexpr bool isBinaryScientificShowDouble = true;

#else  // !MATHEMATICS_BINARY_SCIENTIFIC_SHOW_DOUBLE

    constexpr bool isBinaryScientificShowDouble = false;

#endif  // MATHEMATICS_BINARY_SCIENTIFIC_SHOW_DOUBLE

#ifdef MATHEMATICS_APPROXIMATION_QUERY_VALIDATE_INDICES

    constexpr bool isApproximationQueryValidateIndices = true;

#else  // !MATHEMATICS_APPROXIMATION_QUERY_VALIDATE_INDICES

    constexpr bool isApproximationQueryValidateIndices = false;

#endif  // MATHEMATICS_APPROXIMATION_QUERY_VALIDATE_INDICES
}

// 是否编译为静态库
#ifdef BUILDING_STATIC

    #define BUILDING_MATHEMATICS_STATIC static_cast<void>(0)

#endif  // BUILDING_STATIC

#define BIT_HACKS_BETTER static_cast<void>(0)
#define ALGEBRA_BETTER static_cast<void>(0)

#endif  // MATHEMATICS_HELPER_USER_MACRO_H
