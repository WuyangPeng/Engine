深入理解计算机系统（Computer Systems:A Programmer's Perspective）
（第3版）

官方网站：
http://csapp.cs.cmu.edu/

★
作者：  Randal E.Bryant、David R.O'Hallaron

前言
	读者应具备的背景知识
	如何阅读此书
	本书概述
	本版新增内容
	本书的起源
	写给指导教师们：可以基于本书的课程
	写给指导教师们：经过课堂验证的实验练习
	第3版的致谢
	第2版的致谢
	第1版的致谢
关于作者
第1章　计算机系统漫游
	1.1　信息就是位+上下文
	1.2　程序被其他程序翻译成不同的格式
	1.3　了解编译系统如何工作是大有益处的
	1.4　处理器读并解释储存在内存中的指令
　		1.4.1　系统的硬件组成
　		1.4.2　运行hello程序
	1.5　高速缓存至关重要
	1.6　存储设备形成层次结构
	1.7　操作系统管理硬件
　		1.7.1　进程
　		1.7.2　线程
　		1.7.3　虚拟内存
　		1.7.4　文件
	1.8　系统之间利用网络通信
	1.9　重要主题
　		1.9.1　Amdahl定律
　		1.9.2　并发和并行
　		1.9.3　计算机系统中抽象的重要性
	1.10　小结
	参考文献说明
	练习题答案
第一部分 程序结构和执行
	第2章　信息的表示和处理
		2.1　信息存储
			2.1.1　十六进制表示法
			2.1.2　字数据大小
			2.1.3　寻址和字节顺序
			2.1.4　表示字符串
			2.1.5　表示代码
			2.1.6　布尔代数简介
			2.1.7　C语言中的位级运算
			2.1.8　C语言中的逻辑运算
			2.1.9　C语言中的移位运算
　		2.2　整数表示
			2.2.1　整型数据类型
			2.2.2　无符号数的编码
			2.2.3　补码编码
			2.2.4　有符号数和无符号数之间的转换
			2.2.5　C语言中的有符号数与无符号数
			2.2.6　扩展一个数字的位表示
			2.2.7　截断数字
			2.2.8　关于有符号数与无符号数的建议
　		2.3　整数运算
			2.3.1　无符号加法
			2.3.2　补码加法
			2.3.3　补码的非
			2.3.4　无符号乘法
			2.3.5　补码乘法
			2.3.6　乘以常数
			2.3.7　除以2的幂
			2.3.8　关于整数运算的后思考
　		2.4　浮点数
			2.4.1　二进制小数
			2.4.2　IEEE浮点表示		 
			2.4.3　数字示例
			2.4.4　舍入
			2.4.5　浮点运算
			2.4.6　C语言中的浮点数
　		2.5　小结
　		参考文献说明
　		家庭作业
　		练习题答案
	第3章　程序的机器级表示
		3.1　历史观点
		3.2　程序编码
			3.2.1　机器级代码
			3.2.2　代码示例
			3.2.3　关于格式的注解
		3.3　数据格式
		3.4　访问信息
			3.4.1　操作数指示符
			3.4.2　数据传送指令
			3.4.3　数据传送示例
			3.4.4　压入和弹出栈数据
		3.5　算术和逻辑操作
			3.5.1　加载有效地址
			3.5.2　一元和二元操作
			3.5.3　移位操作
			3.5.4　讨论
			3.5.5　特殊的算术操作
		3.6　控制
			3.6.1　条件码
			3.6.2　访问条件码
			3.6.3　跳转指令
			3.6.4　跳转指令的编码
			3.6.5　用条件控制来实现条件分支
			3.6.6　用条件传送来实现条件分支
			3.6.7　循环
			3.6.8　switch语句
		3.7　过程
			3.7.1　运行时栈
			3.7.2　转移控制
			3.7.3　数据传送
			3.7.4　栈上的局部存储
			3.7.5　寄存器中的局部存储空间
			3.7.6　递归过程
		3.8　数组分配和访问
			3.8.1　基本原则
			3.8.2　指针运算
			3.8.3　嵌套的数组
			3.8.4　定长数组
			3.8.5　变长数组
		3.9　异质的数据结构
			3.9.1　结构
			3.9.2　联合
			3.9.3　数据对齐
		3.10　在机器级程序中将控制与数据结合起来
			3.10.1　理解指针
			3.10.2　应用：使用GDB调试器
			3.10.3　内存越界引用和缓冲区溢出
			3.10.4　对抗缓冲区溢出攻击
			3.10.5　支持变长栈帧
		3.11　浮点代码
			3.11.1　浮点传送和转换操作
			3.11.2　过程中的浮点代码
			3.11.3　浮点运算操作
			3.11.4　定义和使用浮点常数
			3.11.5　在浮点代码中使用位级操作
			3.11.6　浮点比较操作
			3.11.7　对浮点代码的观察结论
		3.12　小结
　		参考文献说明
　		家庭作业
　		练习题答案
	第4章　处理器体系结构
		4.1　Y86-64指令集体系结构
　			4.1.1　程序员可见的状态
　			4.1.2　Y86-64指令
　			4.1.3　指令编码
　			4.1.4　Y86-64异常
　			4.1.5　Y86-64程序
　			4.1.6　一些Y86-64指令的详情
		4.2　逻辑设计和硬件控制语言HCL
　			4.2.1　逻辑门
　			4.2.2　组合电路和HCL布尔表达式
　			4.2.3　字级的组合电路和HCL整数表达式
　			4.2.4　集合关系
　			4.2.5　存储器和时钟
		4.3　Y86-64的顺序实现
　			4.3.1　将处理组织成阶段
　			4.3.2　SEQ硬件结构
　			4.3.3　SEQ的时序
　			4.3.4　SEQ阶段的实现
		4.4　流水线的通用原理
　			4.4.1　计算流水线
　			4.4.2　流水线操作的详细说明
　			4.4.3　流水线的局限性
　			4.4.4　带反馈的流水线系统
		4.5　Y86-64的流水线实现
　			4.5.1　SEQ ：重新安排计算阶段
　			4.5.2　插入流水线寄存器
　			4.5.3　对信号进行重新排列和标号
　			4.5.4　预测下一个PC
　			4.5.5　流水线冒险
　			4.5.6　异常处理
　			4.5.7　PIPE各阶段的实现
　			4.5.8　流水线控制逻辑
　			4.5.9　性能分析
　			4.5.10　未完成的工作
		4.6　小结
		参考文献说明
　		家庭作业
　		练习题答案
	第5章　优化程序性能
		5.1　优化编译器的能力和局限性
		5.2　表示程序性能
		5.3　程序示例
		5.4　消除循环的低效率
		5.5　减少过程调用
		5.6　消除不必要的内存引用
		5.7　理解现代处理器
　			5.7.1　整体操作
　			5.7.2　功能单元的性能
　			5.7.3　处理器操作的抽象模型
		5.8　循环展开
		5.9　提高并行性
　			5.9.1　多个累积变量
　			5.9.2　重新结合变换
		5.10　优化合并代码的结果小结
		5.11　一些限制因素
　			5.11.1　寄存器溢出
　			5.11.2　分支预测和预测错误处罚
		5.12　理解内存性能
　			5.12.1　加载的性能
　			5.12.2　存储的性能
		5.13　应用：性能提高技术
		5.14　确认和消除性能瓶颈
　			5.14.1　程序剖析
　			5.14.2　使用剖析程序来指导优化
		5.15　小结
　		参考文献说明
　		家庭作业
　		练习题答案
	第6章　存储器层次结构
		6.1　存储技术
　			6.1.1　随机访问存储器
　			6.1.2　磁盘存储
　			6.1.3　固态硬盘
　			6.1.4　存储技术趋势
		6.2　局部性
　			6.2.1　对程序数据引用的局部性
　			6.2.2　取指令的局部性
　			6.2.3　局部性小结
		6.3　存储器层次结构
　			6.3.1　存储器层次结构中的缓存
　			6.3.2　存储器层次结构概念小结
		6.4　高速缓存存储器
　			6.4.1　通用的高速缓存存储器组织结构
　			6.4.2　直接映射高速缓存
　			6.4.3　组相联高速缓存
　			6.4.4　全相联高速缓存
　			6.4.5　有关写的问题
　			6.4.6　一个真实的高速缓存层次结构的解剖
　			6.4.7　高速缓存参数的性能影响
		6.5　编写高速缓存友好的代码
		6.6　综合：高速缓存对程序性能的影响
　			6.6.1　存储器山
　			6.6.2　重新排列循环以提高空间局部性
　			6.6.3　在程序中利用局部性
		6.7　小结
　		参考文献说明
　		家庭作业
　		练习题答案
第二部分 在系统上运行程序
　	第7章　链接
		7.1　编译器驱动程序
		7.2　静态链接
		7.3　目标文件
		7.4　可重定位目标文件
		7.5　符号和符号表
		7.6　符号解析
　			7.6.1　链接器如何解析多重定义的全局符号
　			7.6.2　与静态库链接
　			7.6.3　链接器如何使用静态库来解析引用
		7.7　重定位
　			7.7.1　重定位条目
　			7.7.2　重定位符号引用
		7.8　可执行目标文件
		7.9　加载可执行目标文件
		7.10　动态链接共享库
		7.11　从应用程序中加载和链接共享库
		7.12　位置无关代码
		7.13　库打桩机制
　			7.13.1　编译时打桩
　			7.13.2　链接时打桩
　			7.13.3　运行时打桩
		7.14　处理目标文件的工具
		7.15　小结
　		参考文献说明
　		家庭作业
　		练习题答案
	第8章　异常控制流
		8.1　异常
　			8.1.1　异常处理
　			8.1.2　异常的类别
　			8.1.3　Linux/x86-64系统中的异常
		8.2　进程
　			8.2.1　逻辑控制流
　			8.2.2　并发流
　			8.2.3　私有地址空间
　			8.2.4　用户模式和内核模式
　			8.2.5　上下文切换
		8.3　系统调用错误处理
		8.4　进程控制
　			8.4.1　获取进程ID
　			8.4.2　创建和终止进程
　			8.4.3　回收子进程
　			8.4.4　让进程休眠
　			8.4.5　加载并运行程序
　			8.4.6　利用fork和execve运行程序
		8.5　信号
　			8.5.1　信号术语
　			8.5.2　发送信号
　			8.5.3　接收信号
　			8.5.4　阻塞和解除阻塞信号
　			8.5.5　编写信号处理程序
　			8.5.6　同步流以避免讨厌的并发错误
　			8.5.7　显式地等待信号
		8.6　非本地跳转
		8.7　操作进程的工具
		8.8　小结
　		参考文献说明
　		家庭作业
　		练习题答案
	第9章　虚拟内存
		9.1　物理和虚拟寻址
		9.2　地址空间
		9.3　虚拟内存作为缓存的工具
　			9.3.1　DRAM缓存的组织结构
　			9.3.2　页表
　			9.3.3　页命中
　			9.3.4　缺页
　			9.3.5　分配页面
　			9.3.6　又是局部性救了我们
		9.4　虚拟内存作为内存管理的工具
		9.5　虚拟内存作为内存保护的工具
		9.6　地址翻译
　			9.6.1　结合高速缓存和虚拟内存
　			9.6.2　利用TLB加速地址翻译
　			9.6.3　多级页表
　			9.6.4　综合：端到端的地址翻译
		9.7　案例研究：Intel Core i7/Linux内存系统
　			9.7.1　Core i7地址翻译
　			9.7.2　Linux虚拟内存系统
		9.8　内存映射
　			9.8.1　再看共享对象
　			9.8.2　再看fork函数
　			9.8.3　再看execve函数
　			9.8.4　使用mmap函数的用户级内存映射
		9.9　动态内存分配
　			9.9.1　malloc和free函数
　			9.9.2　为什么要使用动态内存分配
　			9.9.3　分配器的要求和目标
　			9.9.4　碎片
　			9.9.5　实现问题
　			9.9.6　隐式空闲链表
　			9.9.7　放置已分配的块
　			9.9.8　分割空闲块
　			9.9.9　获取额外的堆内存
　			9.9.10　合并空闲块
　			9.9.11　带边界标记的合并
　			9.9.12　综合：实现一个简单的分配器
　			9.9.13　显式空闲链表
　			9.9.14　分离的空闲链表
		9.10　垃圾收集
　			9.10.1　垃圾收集器的基本知识
　			9.10.2　Mark&Sweep垃圾收集器
　			9.10.3　C程序的保守Mark&Sweep
		9.11　C程序中常见的与内存有关的错误
　			9.11.1　间接引用坏指针
　			9.11.2　读未初始化的内存
　			9.11.3　允许栈缓冲区溢出
　			9.11.4　假设指针和它们指向的对象是相同大小的
　			9.11.5　造成错位错误
　			9.11.6　引用指针，而不是它所指向的对象
　			9.11.7　误解指针运算
　			9.11.8　引用不存在的变量
　			9.11.9　引用空闲堆块中的数据
　			9.11.10　引起内存泄漏
		9.12　小结
　		参考文献说明
　		家庭作业
　		练习题答案
第三部分 程序间的交互和通信
	第10章　系统级I/O	
		10.1　Unix I/O
		10.2　文件
		10.3　打开和关闭文件
		10.4　读和写文件
		10.5　用RIO包健壮地读写
　			10.5.1　RIO的无缓冲的输入输出函数
　			10.5.2　RIO的带缓冲的输入函数
		10.6　读取文件元数据
		10.7　读取目录内容
		10.8　共享文件
		10.9　I/O重定向
		10.10　标准I/O
		10.11　综合：我该使用哪些I/O函数？
		10.12　小结
　		参考文献说明
　		家庭作业
　		练习题答案
	第11章　网络编程
		11.1　客户端服务器编程模型
		11.2　网络
		11.3　全球IP因特网
　			11.3.1　IP地址
　			11.3.2　因特网域名
　			11.3.3　因特网连接
		11.4　套接字接口
　			11.4.1　套接字地址结构
　			11.4.2　socket函数
　			11.4.3　connect函数
　			11.4.4　bind函数
　			11.4.5　listen函数
　			11.4.6　accept函数
　			11.4.7　主机和服务的转换
　			11.4.8　套接字接口的辅助函数
　			11.4.9　echo客户端和服务器的示例
		11.5　Web服务器
　			11.5.1　Web基础
　			11.5.2　Web内容
　			11.5.3　HTTP事务
　			11.5.4　服务动态内容
		11.6　综合：TINY Web服务器
		11.7　小结
　		参考文献说明
　		家庭作业
　		练习题答案
	第12章　并发编程
		12.1　基于进程的并发编程
　			12.1.1　基于进程的并发服务器
　			12.1.2　进程的优劣
		12.2　基于I/O多路复用的并发编程
　			12.2.1　基于I/O多路复用的并发事件驱动服务器
　			12.2.2　I/O多路复用技术的优劣
		12.3　基于线程的并发编程
　			12.3.1　线程执行模型
　			12.3.2　Posix线程
　			12.3.3　创建线程
　			12.3.4　终止线程
　			12.3.5　回收已终止线程的资源
　			12.3.6　分离线程
　			12.3.7　初始化线程
　			12.3.8　基于线程的并发服务器
		12.4　多线程程序中的共享变量
　			12.4.1　线程内存模型
　			12.4.2　将变量映射到内存
　			12.4.3　共享变量
		12.5　用信号量同步线程
　			12.5.1　进度图
　			12.5.2　信号量
　			12.5.3　使用信号量来实现互斥
　			12.5.4　利用信号量来调度共享资源
　			12.5.5　综合：基于预线程化的并发服务器
		12.6　使用线程提高并行性
		12.7　其他并发问题
　			12.7.1　线程安全
　			12.7.2　可重入性
　			12.7.3　在线程化的程序中使用已存在的库函数
　			12.7.4　竞争
　			12.7.5　死锁
		12.8　小结
　		参考文献说明
　		家庭作业
　		练习题答案
附录A　错误处理