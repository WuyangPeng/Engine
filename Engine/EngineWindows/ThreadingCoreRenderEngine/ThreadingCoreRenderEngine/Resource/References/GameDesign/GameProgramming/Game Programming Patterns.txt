游戏编程模式（Game Programming Patterns）

官方网站：
http://gameprogrammingpatterns.com/ 、http://journal.stuffwithstuff.com/ 、
https://www.ptpress.com.cn/shopping/buy?bookId=bbf95882-dea0-43ad-b798-efd6546f9748

参考网站：
http://wiki.c2.com/?SingletonPattern

游戏循环：
https://gafferongames.com/post/fix_your_timestep/

编程语言：
http://www.lua.org/ 、https://github.com/wren-lang/wren

★★★
作者：Robert Nystrom

联系作者：
bob@gameprogrammingpatterns.com

知识点 
1.	游戏编程模式基础知识。
2.	设计模式基础知识。
3.	序列型模式基础知识。
4.	行为型模式基础知识。
5.	解耦型模式基础知识。

代码
1.	command.h（第2章 命令模式）
2.	flyweight.h（第3章 享元模式）
3.	observer.h（第4章 观察者模式）
4.	prototype.h（第5章 原型模式）
5.	singleton.h（第6章 单例模式）
6.	state.h（第7章 状态模式）
7.	double-buffer.h（第8章 双缓冲）
8.	game-loop.h（第9章 游戏循环）
9.	update-method.h（第10章 更新方法）
10.	bytecode.h（第11章 字节码）
11.	subclass-sandbox.h（第12章 子类沙盒）
12.	type-object.h（第13章 类型对象）
13.	component.h（第14章 组件模式）

要点
1.	一味追求可扩展性让无数开发者在一个“引擎”上花费数年却没有搞清楚引擎空间是用来做什么的。（1.2 有什么代价）
2.	要及时删除观察者。（4.5.2 不用担心，我们有GC）
3.	C++11保证一个局部静态变量的初始化只进行一次，哪怕是在多线程的情况下也是如此。（6.1.2 提供一个全局指针以访问唯一实例）

第1篇 概述
	第1章 架构、性能和游戏
		★	第一个关键部分是，架构意味变化。衡量一个设计好坏的方法就是看它应对变化的灵活性。
		★	将一款有趣的游戏做得高效要比将一款高性能的游戏做的有趣更简单些。
		★	保持代码的灵活性，直到设计稳定下来，然后去除一些抽象，以提高游戏的性能。
		★	一个有趣的地方是这些都是关于某种速度：
			1.	我们的长期开发速度。
			2.	游戏的执行速度。
			3.	我们短期内的开发速度。
		★	寻求平衡：
			1.	我们想获得一个良好的架构，这样在项目的生命周期中便会更容易理解代码。
			2.	我们希望获得快速的运行时性能。
			3.	我们希望快速完成今天的功能。
		★	要点：
			1.	抽象和解耦能够使得你的程序开发变得更快和更简单。
				但不要浪费时间来做这件事，除非你确信存在问题的代码需要这种灵活性。
			2.	在你的开发周期中要对性能进行思考和设计，但是要推迟那些降低灵活性的、底层的、详尽的优化，能晚则晚。
			3.	忙地探索你的游戏的设计空间，但是不要走得太快留下一个烂摊子给自己。毕竟你将不得不面对它。
			4.	如果你将要删除代码，那么不要浪费时间将它整理得很整洁。
第2篇 再探设计模式
	第2章 命令模式
		★	将一个请求封装成一个对象，从而允许你使用不同的请求、队列或日志将客户端参数化，同时支持请求操作的撤销与恢复。
		★	命令就是一个对象化的方法调用。
		★	将某种概念转化为一块数据、一个对象，或者你可以认为是传入函数的变量等。
		★	命令就是面向对象化的回调。
	第3章 享元模式
		★	类型对象通过把“类型”对象化，可以尽可能减少定义新类型的数量。
			而享元模式中产生的内存共享只是额外的奖励。而享元模式却更注重效率。
		★	享元模式通过将对象数据切分成两种类型来解决问题：
			1.	不属于单一实例对象并且能够被所有对象共享的数据。
			2.	其他数据便是外部状态，对于每一个实例它们都是唯一的。
		★	享元模式不仅具有面向对象的优点，而且不会因数量巨大而产生开销。
	第4章 观察者模式
		★	在对象间定义一种一对多的依赖关系，以便当某对象的状态改变时，
			与它存在依赖关系的所有对象都能收到通知并自动进行更新。
		★	被观察者对象拥有一个观察者对象的集合，而不是单个观察者。
		★	如果两个观察者观察同一个被观察对象，则它们不会因为注册顺序而受到影响。
			如果注册顺序对观察者有影响的话，那么这两个观察者便产生了耦合并可能带来不必要的麻烦。
		★	每一个被观察者对象被删除时，所有的观察者都自动取消注册自身。
		★	观察者模式非常适合一些不相关的模块之间的通信问题。它不适合单个紧凑的模块内部的通信。
		★	解决方案中最重要的两条标准：
			1.	非常简单。
			2.	运行良好。
	第5章 原型模式
		★	使用特定原型实例来创建特定种类的对象，并且通过拷贝原型来创建新的对象。
		★	原型模式其核心思想是一个对象可以生成与自身相似的其他对象。
		★	原型模式不仅克隆原型类，而且它也克隆了对象的状态。
	第6章 单例模式
		★	确保一个类只有一个实例，并为其提供一个全局访问入口。
		★	优点：
			1.	如果我们不使用它，就不会创建实例。
			2.	它在运行时初始化。
			3.	你可以继承单例，这是一个强大但是经常被忽视的特性。
		★	缺点：
			1.	它是一个全局变量。全局变量是有害的：
				（1）它们令代码晦涩难懂。
				（2）全局变量促进耦合。
				（3）它对并发不友好。
				（4）单例就是一个全局状态——它只是被封装到了类中而已。
			2.	它是个画蛇添足的解决方案。
			3.	延迟初始化剥离了你的控制。
		★	为实例提供便捷的访问方式：
			1.	传递进去。
			2.	在基类中获取它。
			3.	通过其他全局对象访问它。
			4.	通过服务定位器来访问。
	第7章 状态模式
		★	允许一个对象在其内部状态改变时改变自身的行为。对象看起来好像是在修改自身类。
		★	有限状态机其表达的是：
			1.	你拥有一组状态，并且可以在这组状态之间进行切换。
			2.	状态机同一时刻只能处于一种状态。
			3.	状态机会接收一组输入或者事件。
			4.	每一个状态有一组转换，每一个转换都关联着一个输入并指向一个状态。
		★	整个状态机可以分为：状态、输入和转换。
		★	策略模式、类型对象模式和状态模式的区别是主要在于目的不同：
			1.	策略模式的目标是将主类与它的部分行为进行解耦。
			2.	类型对象模式的目标是使得多个对象通过共享相同类型对象的引用来表现出相似性。
			3.	状态模式的目标是通过改变主对象代理的对象来改变主对象的行为。
		★	当你的问题满足以下几点要求时，有限状态机将会非常有用：
			1.	你有一个游戏实体，它的行为基于它的内部状态而改变。
			2.	这些状态被严格划分为相对数目较少的小集合。
			3.	游戏实体随着时间的变化会响应用户输入和一些游戏事件。
第3篇 序列型模式
	第8章 双缓冲
		★	定义一个缓冲区类来封装一个缓冲区：一块能被修改的状态区域。
			我们希望任何外部代码将对该缓冲区的修改都视为原子操作。
			此类中维护两个缓冲区实例：后台缓冲区和当前缓冲区。
		★	适用于双缓冲模式的条件：
			1.	我们需要维护一些被逐步改变着的状态量。
			2.	同个状态可能会在其被修改的同时被访问到。
			3.	我们希望避免访问状态的代码能看到具体的工作过程。
			4.	我们希望能够读取状态但不希望等待写入操作的完成。
		★	交换过程和分配一个指针的速度差不多。如果交换用去了比修改初始状态更多的时间，那这模式就毫无助益了。
		★	双缓冲模式解决的核心问题是对状态同时进行修改与访问的冲突。
		★	缓冲区如何交换：
			1.	交换缓冲区的指针或者引用。
			2.	在两个缓冲区之间进行数据的拷贝。
	第9章 游戏循环
		★	实现用户输入和处理器速度在游戏行进时间上的解耦。
		★	两个因素决定帧率：
			1.	循环每一帧要处理的信息量。
			2.	底层平台的速度。
		★	游戏循环模式的另一个要点：这一模式让游戏在一个与硬件无关的速度常量下运行。
		★	一个游戏循环会在游戏过程中持续地运转。每循环一次，它非阻塞地处理用户的输入，
			更新游戏状态，并渲染游戏，它跟踪流逝的时间并控制游戏的速率。
		★	问题归结：
			1.	每次更新游戏花去一个固定的时间值。
			2.	需要花些实际的时间来进行更新。
		★	确定性表示每次你运行程序，假如给予同样的输入，那么你将得到完全一致的输出、
		★	谁来控制游戏循环，你还是平台：
			1.	使用平台的事件循环。
			2.	使用游戏引擎的游戏循环。
			3.	自己编写游戏循环。
		★	非同步的固定时间步长：
			1.	简单。
			2.	游戏速度直接受硬件和游戏复杂度的影响。
		★	同步的固定时长：
			1.	简单。
			2.	省电。
			3.	游戏不会运行得很快。
			4.	游戏可能会跑得很慢。
		★	变时步长：
			1.	它能适应过快或过慢的硬件平台。
			2.	它使得游戏变得不确定且不稳定。物理和网络模块在变时步长下变得尤其困难。
		★	定时更新迭代，变时渲染。
			1.	它能适应过快或过慢的硬件平台。
			2.	它更复杂。
	第10章 更新方法
		★	通过对所有对象实例同时进行帧更新来模拟一系列相互的游戏对象。
		★	更新方法模式在如下情境最为适用：
			1. 你的游戏中含有一系列对象或系统需要同步地运转。
			2. 各个对象之间的行为几乎是相互独立的。
			3. 对象的行为与时间相关。
		★	优先使用组合而不是继承。
		★	update方法依存于何类中：
			1.	实体类中。
			2.	组件类中。
			3.	代理类中。
第4篇 行为型模式
	第11章 字节码
		★	通过将行为编码成虚拟机指令，而使其具备数据的灵活性。
		★	慢，大部分广泛使用的编程语言没有基于解释器模式也正因于此。
		★	采用机器码：
			1.	高密度。
			2.	线性。
			3.	底层。
			4.	迅速。
		★	指令集定义了一套可以执行的底层操作。一系列指令被编码为字节序列。
			虚拟机逐条执行指令栈上这些指令。通过组合指令，即可完成很多高级行为。
		★	使用情境：
			1.	编程语言太底层了，编写起来繁琐易错。
			2.	因编译时间太长或工具问题，导致迭代缓慢。
			3.	它的安全性太依赖编码者。
		★	字节码比本地码要慢，所以它并不适合用作性能要求极高的核心部分。
		★	要为虚拟机设计一个指令集。在真正考虑字节码之类的东西前，可以先把它们当成是API。
		★	指令如何访问堆栈：
			1.	基于栈的虚拟机。
			2.	基于寄存器的虚拟机。
		★	应该有哪些指令：
			1.	外部基本操作。
			2.	内部基本操作。
			3.	控制流。
		★	值应当如何表示：
			1.	单一数据类型。
			2.	标签的一个变体。
			3.	不带标签的联合体。
			4.	一个接口。
		★	如果你能坚持使用单一数据类型，那就这么做。否则，使用带标签的联合体。
			这是几乎所有编程语言的解析方式。
		★	如何生成字节码：
			1.	如果你定义了一种基于文本的语言。
			2.	如果你设计了一个图形化编辑工具。
	第12章 子类沙盒
		★	使用基类提供的操作集合来定义子类的行为。
		★	我们通过将基础操作提取到更高的层次来解决冗余代码问题。
		★	一个基类定义了一个抽象的沙盒方法和一些预定义的操作集合。通过将它们设置为受保护的状态以确保它们仅供子类使用。
			每个派生出的沙盒子类根据父类提供的操作来实现沙盒函数。
		★	沙盒模式适用于以下情况：
			1.	你有一个带有大量子类的基类。
			2.	基类能够提供所有子类可能需要执行的操作集合。
			3.	在子类之间有重叠的代码，你希望在它们之间更简便地共享代码。
			4.	你希望使用这些继承与程序其他代码之间的耦合最小化。
		★	设计决策：
			1.	需要提供什么操作。
			2.	是直接提供函数，还是由包含它们的对象提供。
			3.	基类如何获取所需的状态。
	第13章 类型对象
		★	通过创建一个类来支持新类型的灵活创建，其每个实例都代表一个不同的对象类型。
		★	定义一个类型对象类和一个持有类型对象类。每个类型对象的实例表示一个不同的逻辑类型。
			每个持有类型对象类的实例引用一个其类型的类型对象。
		★	使用情境：
			1.	你不知道将来会有什么类型。
			2.	你需要在不重新编译或修改代码的情况下，修改或添加新的类型。
		★	持有类型对象如何创建：
			1.	构造函数并传入类型对象。
			2.	在类型对象上调用“构造”函数。
第5篇 解耦型模式
	第14章 组件模式
		★	允许一个单一的实体跨越多个不同域而不会导致耦合。
		★	单一实体横跨了多个域。为了能够保持域之间的相互隔离，每个域的代码都独立地放在自己的组件中。
			实体本身则可以简化为这些组件的容器。
		★	使用情境：
			1.	你有一个涉及多个域的类，但是你希望让这些域保持相互解耦。
			2.	一个类越来越宏大，越来越难以开发。
			3.	你希望定义许多共享不同能力的对象，但采用继承的方法却无法令你精确地重用代码。
		★	组件模式通常能够提升性能和缓存的一致性。
		★	对象如何获得组件：
			1.	如果这个类创建了自己的组件。
			2.	如果由外部代码提供组件。
		★	组件之间如何传递信息：
			1.	通过修改容器对象的状态。
			2.	直接互相引用。
			3.	通过传递信息的方式。
	第15章 事件队列