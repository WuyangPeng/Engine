数据结构与算法分析——C++语言描述（Data Structures and Algorithm Analysis in C++）
（第4版）

官方网站：
http://www.cis.fiu.edu/~weiss 、http://cssupport.pearsoncmg.com/、 http://www.turingbook.com、www.aw.com/cssupport （已失效）

☆
作者：Mark Allen Weiss

知识点 
1.	算法基础知识。 

前言
	目的/目标
	处理方法
	第四版最重要的变化概述
	内容提要
	练习
	参考文献
	补充材料
	致谢
第1章 程序设计：综述
	1.1 本书讨论的内容 
	1.2 数学知识复习
		1.2.1 指数
		1.2.2 对数
		1.2.3 级数
		1.2.4 模运算
		1.2.5 证明方法
	1.3 递归简论
	1.4 C++类
		1.4.1 基本的class语法
		1.4.2 构造函数的附加语法和访问函数
		1.4.3 接口和实现的分离
		1.4.4 vector类和string类
	1.5 C++细节
		1.5.1 指针
		1.5.2 左值、右值和引用 
		1.5.3 参数传递
		1.5.4 返回值传递
		1.5.5 std::swap和std::move
		1.5.6 五大函数：析构函数，拷贝构造函数，移动构造函数，拷贝赋值operator=，移动赋值operator=
		1.5.7 C风格数组和字符串
	1.6 模板
		1.6.1 函数模板
		1.6.2 类模板
		1.6.3 Object、Comparable和一个例子
		1.6.4 函数对象
		1.6.5 类模板的分离式编译
	1.7 使用矩阵
		1.7.1 数据成员、构造函数和基本访问函数
		1.7.2 operator[]
		1.7.3 五大函数
	小结
	练习
	参考文献
第2章 算法分析
	2.1 数学基础
	2.2 模型
	2.3 要分析的问题
	2.4 运行时间计算
		2.4.1 一个简单的例子
		2.4.2 一般法则
		2.4.3 最大子序列和问题的求解
		2.4.4 运行时间中的对数
		2.4.5 最坏情形分析的局限性
	小结
	练习
	参考文献
第3章 表、栈和队列
	3.1 抽象数据类型
	3.2 表ADT
		3.2.1 表的简单数组实现
		3.2.2 简单链表
	3.3 STL中的vector和list
		3.3.1 迭代器
		3.3.2 例子：对表使用erase
		3.3.3 const_iterators
	3.4 vector的实现
	3.5 list的实现
	3.6 栈ADT
		3.6.1 栈模型
		3.6.2 栈的实现
		3.6.3 应用
	3.7 队列ADT
		3.7.1 队列模型
		3.7.2 队列的数组实现
		3.7.3 队列的应用
	小结
	练习
第4章 树
	4.1 预备知识
		4.1.1 树的实现
		4.1.2 树的遍历及应用
	4.2 二叉树
		4.2.1 实现
		4.2.2 一个例子——表达式树
	4.3 查找树ADT——二叉查找树
		4.3.1 contains
		4.3.2 findMin和findMax
		4.3.3 insert
		4.3.4 remove
		4.3.5 析构函数和拷贝构造函数
		4.3.6 平均情况分析
	4.4 AVL树
		4.4.1 单旋转
		4.4.2 双旋转
	4.5 伸展树
		4.5.1 一个简单的想法（不能直接使用）
		4.5.2 展开
	4.6 树的遍历
	4.7 B树
	4.8 标准库中的容器set和map
		4.8.1 集合容器set
		4.8.2 映射容器map
		4.8.3 set和map的实现
		4.8.4 使用多个map的示例
	小结
	练习
	参考文献
第5章 散列
	5.1 一般想法 
	5.2 散列函数
	5.3 分离链接法
	5.4 不用链表的散列表
		5.4.1 线性探测法
		5.4.2 平方探测法
		5.4.3 双散列
	5.5 再散列
	5.6 标准库中的散列表
	5.7 以最坏情形O(1)访问的散列表
		5.7.1 完美散列
		5.7.2 杜鹃散列
		5.7.3 跳房子散列
	5.8 通用散列
	5.9 可扩散列
	小结
	练习
	参考文献
第6章 优先队列（堆）
	6.1 模型
	6.2 一些简单的实现
	6.3 二叉堆
		6.3.1 结构性质
		6.3.2 堆序性质
		6.3.3 基本的堆操作
		6.3.4 其他的堆操作
	6.4 优先队列的应用
		6.4.1 选择问题
		6.4.2 事件模拟
	6.5 d堆
	6.6 左式堆
		6.6.1 左式堆的性质
		6.6.2 左式堆操作
	6.7 斜堆
	6.8 二项队列
		6.8.1 二项队列构建
		6.8.2 二项队列操作
		6.8.3 二项队列的实现
	6.9 标准库中的优先队列
	小结
	练习
	参考文献
第7章 排序
	7.1 预备知识
	7.2 插入排序
		7.2.1 算法
		7.2.2 插入排序的STL实现
		7.2.3 插入排序的分析
	7.3 一些简单排序算法的下界
	7.4 希尔排序
		7.4.1 希尔排序的最坏情形分析
	7.5 堆排序
		7.5.1 堆排序的分析
	7.6 归并排序
		7.6.1 归并排序的分析
	7.7 快速排序
		7.7.1 选取枢纽元
		7.7.2 分割策略
		7.7.3 小数组
		7.7.4 实际的快速排序例程
		7.7.5 快速排序的分析
		7.7.6 选择问题的线性期望时间算法 
	7.8 排序算法的一般下界
		7.8.1 决策树
	7.9 选择问题的决策树下界
	7.10 对手下界
	7.11 线性时间排序：桶式排序和基数排序
	7.12 外部排序
		7.12.1 为什么需要一些新的算法 
		7.12.2 外部排序模型
		7.12.3 简单算法 
		7.12.4 多路合并
		7.12.5 多相合并 
		7.12.6 替换选择
	小结
	练习
	参考文献
第8章 不相交集类
	8.1 等价关系
	8.2 动态等价性问题
	8.3 基本数据结构
	8.4 灵巧求并算法 
	8.5 路径压缩
	8.6 按秩求并和路径压缩的最坏情形	
		8.6.1 缓慢增长的函数
		8.6.2 通过递归分解进行的分析
		8.6.3 一个O(M logN)界
		8.6.4 一个O(Ma(M,N))界
	8.7 一个应用
	小结
	练习
	参考文献
第9章 图论算法
	9.1 若干定义
		9.1.1 图的表示
	9.2 拓扑排序
	9.3 最短路径算法
		9.3.1 无权最短路径
		9.3.2 Dijkstra算法 
		9.3.3 具有负边值的图
		9.3.4 无圈图
		9.3.5 所有顶点对间的最短路径
		9.3.6 最短路径的例
	9.4 网络流问题
		9.4.1 一个简单的最大流算法 
	9.5 最小生成树
		9.5.1 Prim算法 
		9.5.2 Krukal算法 
	9.6 深度优先搜索的应用
		9.6.1 无向图
		9.6.2 双连通性
		9.6.3 欧拉回路
		9.6.4 有向图
		9.6.5 查找强分支
	9.7 NP完全性介绍
		9.7.1 难与易
		9.7.2 NP类
		9.7.3 NP完全问题
	小结
	练习
	参考文献
第10章 算法设计技巧
	10.1 贪婪算法
		10.1.1 一个简单的调度问题
		10.1.2 哈夫曼编码
		10.1.3 近似装箱问题
	10.2 分治算法 
		10.2.1 分治算法的运行时间
		10.2.2 最近点问题
		10.2.3 选择问题
		10.2.4 一些算术问题的理论改进
	10.3 动态规划
		10.3.1 用表代替递归
		10.3.2 矩阵乘法的顺序安排
		10.3.3 最优二叉查找树
		10.3.4 所有点对最短路径
	10.4 随机化算法 
		10.4.1 随机数发生器
		10.4.2 跳跃表
		10.4.3 素性测试
	10.5 回溯算法 
		10.5.1 收费公路重建问题
		10.5.2 博弈
	小结
	练习
	参考文献
第11章 摊还分析
	11.1 一个无关的智力问题
	11.2 二项队列
	11.3 斜堆
	11.4 斐波那契堆
		11.4.1 切除左式堆中的节点
		11.4.2 二项队列的懒惰合并
		11.4.3 斐波那契堆操作
		11.4.4 时间界的证明
	11.5 伸展树
	小结
	练习
	参考文献
第12章 高级数据结构及其实现
	12.1 自顶向下伸展树
	12.2 红黑树
		12.2.1 自底向上的插入
		12.2.2 自顶向下红黑树
		12.2.3 自顶向下删除
	12.3 treap树
	12.4 后缀数组和后缀树
		12.4.1 后缀数组
		12.4.2 后缀树
		12.4.3 后缀数组和后缀树的线性时间构建
	12.5 k-d树
	12.6 配对堆
	小结
	练习
	参考文献
附录A 类模板的分离式编译