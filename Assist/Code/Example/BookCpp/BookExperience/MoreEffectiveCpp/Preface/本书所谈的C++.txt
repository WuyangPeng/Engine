本书所谈的C++

我在本书所谈、所用的C++，是ISO/ANSI 标准委员会於1997 年11 月完成的C++国际标准最後草案（Final Draft International Standard）。这暗示了我所使用的某些语言特性可能并不在你的编译器(s) 支援能力之列。别担心，我认为对你而言唯一所谓「新」特性，应该只有templates，而templates 如今几乎已是各家编译器的必备机能。我也运用exceptions，并大量集中於条款9~15。如果你的编译器(s) 未能支援exceptions，没什么大不了，这并不影响本书其他部份带给你的好处。但是，听我说，纵使你不需用到exceptions，亦应阅读条款9~15，因为那些条款（及其相关篇幅）检验了某些不论什么场合下你都应该了解的主题。

我承认，就算标准委员会授意某一语言特性或是赞同某一实务作法，并非就保证该语言特性已出现在目前的编译器上，或该实务作法已可应用於既有的开发环境上。一旦面对「标准委员会所议之理论」和「真正能够有效运作之实务」间的矛盾，我便两者都加以讨论，虽然我其实比较更重视实务。由於两者我都讨论，所以当你的编译器(s) 和C++ 标准不一致时，本书可以协助你，告诉你如何使用目前既有的架构来模拟编译器(s) 尚未支援的语言特性。而当你决定将一些原本绕道而行的解决办法以新支援的语言特性取代时，本书亦可引导你。

注意当我说到编译器(s) 时，我使用复数。不同的编译器对C++ 标准的满足程度各不相同，所以我鼓励你在至少两种编译器(s) 平台上发展程式码。这么做可以帮助你避免不经意地依赖某个编译器专属的语言延伸性质，或是误用某个编译器对标准规格的错误阐示。这也可以帮助你避免使用过度先进的编译器技术，例如独家厂商才做得出的某种语言新特性。如此特性往往实作不够精良（臭虫多，要不就是表现迟缓，或是两者兼具），而且C++ 社群往往对这些特性缺乏使用经验，无法给你应用上的忠告。雷霆万钧之势固然令人兴奋，但当你的目标是要产出可靠的码，恐怕还是步步为营（并且能够与人合作）得好。

本书用了两个你可能不甚熟悉的C++ 性质，它们都是晚近才加入C++ 标准之中。某些编译器支援它们，但如果你的编译器不支援，你可轻易以你所熟悉的其他性质来模拟它们。

第一个性质是型别bool，其值必为关键字true 或false。如果你的编译器尚未支援bool，有两个方法可以模拟它。第一个方法是使用一个global enum：
enum bool { false, true };
这允许你将参数为bool 或int 的不同函式加以多载化（overloading）。缺点是，内建的「比较运算子（comparison operators）」如==, <, >=, 等等仍旧传回ints。
所以以下程式码的行为不如我们所预期：
void f(int);
void f(bool);
int x, y;
...
f( x < y ); // 呼叫f(int)，但其实它应该呼叫f(bool)
一旦你改用真正支援bool 的编译器，这种enum 近似法可能会造成程式行为的改变。
另一种作法是利用typedef 来定义bool，并以常数物件做为true 和false：
typedef int bool;
const bool false = 0;
const bool true = 1;
这种手法相容於传统的C/C++ 语意。使用这种模拟法的程式，在移植到一个支援有bool 型别的编译器平台之後，行为并不会改变。缺点则是无法在函式多载化（overloading）时区分bool 和int。以上两种近似法都有道理，请选择最适合你的一种。

第二个新性质，其实是四个转型运算子：static_cast, const_cast, dynamic_cast,和reinterpret_cast。如果你不熟悉这些转型运算子，请翻到条款2 仔细阅读其中内容。它们不只比它们所取代的C 旧式转型做得更多，也更好。书中任何时候当我需要执行转型动作，我都使用新式的转型运算子。

C++ 拥有比语言本身更丰富的东西。是的，C++ 还有一个伟大的标准程式库（见条款E49）。我尽可能使用标准程式库所提供的string 型别来取代char* 指标，而且我也鼓励你这么做。string objects 并不比char*-based 字串难操作，它们的好处是可以免除你大部份的记忆体管理工作。而且如果发生exception 的话（见条款9 和10），string objects 比较没有memory leaks（记忆体遗失）的问题。实作良好的string 型别甚至可和对应的char* 比赛效率，而且可能会赢（条款29 会告诉你个中故事）。如果你不打算使用标准的string 型别，你当然会使用类似string 的其他classes，是吧？是的，用它，因为任何东西都比直接使用char* 来得好。

我将尽可能使用标准程式库提供的资料结构。这些资料结构来自Standard Template Library（"STL" ― 见条款35）。STL 包含bitsets, vectors, lists, queues,stacks, maps, sets, 以及更多东西，你应该尽量使用这些标准化的资料结构，不要情不自禁地想写一个自己的版本。你的编译器或许没有附STL 给你，但不要因为这样就不使用它。感谢Silicon Graphics 公司的热心，你可以从SGI STL 网站下载一份免费产品，它可以和多种编译器搭配。

如果你目前正在使用一个内含各种演算法和资料结构的程式库，而且用得相当愉快，那么就没有必要只为了「标准」两个字而改用STL。然而如果你在「使用STL」和「自行撰写同等功能的码」之间可以选择，你应该让自己倾向使用STL。记得程式码的重用性吗？STL（以及标准程式库的其他组件）之中有许多码是十分值得重复运用的。