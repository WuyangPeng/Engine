网络多人游戏架构与编程 （Multiplayer Game Programming）

官方网站：
https://github.com/MultiplayerBook。

★★★
作者：Joshua Glazer、Sanjay Madhav
其他书籍：Sanjay Madhav 《游戏编程算法与技巧》。

知识点 
1.	网络多人游戏编程基础知识。 
2.	网络多人游戏编程基础习题。
3.	网络拓扑的基础知识。
4.	延迟的基础知识。

代码
1.	Chapter3（第3章 伯克利套接字）
2.	Chapter4（第4章 对象序列化）
3.	RoboCat（第6章 网络拓扑和游戏案例）
4.	RoboCatClient（第6章 网络拓扑和游戏案例）
5.	RoboCatServer（第6章 网络拓扑和游戏案例）
6.	RoboCatRTS（第6章 网络拓扑和游戏案例）
7.	RoboCat（第8章 改进的延迟处理）
8.	RoboCatClient（第8章 改进的延迟处理）
9.	RoboCatServer（第8章 改进的延迟处理）

要点
1.	最好将IP包的数据限制在1300字节以内。（2.5.1.4 分片）
2.	通过以太网传输的末被分片的数据部分最多是1460字节，也被称为最大分段大小。（2.6.2.3 数据传输）
3.	限制每帧读取数据报数量很重要。（3.6.2 非阻塞I/O）

TODO
1.	第3章 伯克利套接字复习题7、8聊天服务器。
2.	第4章 对象序列化复习题7、8、9、10、11、12序列化函数。
3.	第5章 对象复制复习题4、6对象复制。
4.	第5章 对象复制复习题8、9远程方法调用。
5.	第6章 网络拓扑和游戏案例复习题5机器猫行动。
6.	第6章 网络拓扑和游戏案例复习题6机器猫RTS。
7.	第7章 延迟、抖动和可靠性复习题6、7、9。
8.	第8章 改进的延迟处理复习题9。

复习题
第1章 网络游戏概述
	1.	本地多人游戏和网络多人游戏的区别是什么？
		本地多人游戏与单人游戏的编程在很大程度上是相似的，唯一的典型差异是对多视点和多个输入设备的支持。
		网络多人游戏有两台或更多的计算机在一个活动的游戏传话中彼此连接。
	2.	本地网络连接的3种不同类型是什么？
		早期网络多人游戏、多用户网络游戏和局域网游戏。
	3.	将网络游戏的运行从局域网转换到互联网的主要考虑是什么？
		玩家通过一些大型网络将地理位置上有一定距离的计算机彼此连接起来。
	4.	MUD是什么？它发展为什么类型的游戏？
		多用户网络游戏，它发展成角色扮演类游戏。
	5.	MMO与标准在线游戏的区别是什么？
		大多数的多人在线游戏在每个游戏会话中仍然限制玩家的数量，然而，
		在MMO中，成百上千的玩家将同时出现在同一个游戏会话中。
	6.	在《星际围攻：部落》模型中，哪个系统来提供可靠性？
		事件管理器。
	7.	描述一下，当数据包丢失时，《星际围攻：部落》网络模型中的ghost管理器如何重建最小必要的传输。
		一旦ghost管理器决定了要传输哪些对象，它们的数据将会被添加到出站数据包中。
	8.	在《帝国时代》的点对点模型中，轮班计时器的目的是什么？每个节点传送什么信息到其他节点？
		轮班计时器的目的是什么：不同的玩家运行游戏采用不同的帧速率，同时不同玩家的网络连接质量也不一样。
		每个节点传送什么信息到其他节点：每个玩家的命令。
第2章 互联网
	1.	列出TCP/IP模型的5层并简要描述每一层。在一些模型中，哪一层被认为不是单独的一层？
		物理层：物理层提供信号传输的媒介。
		链路层：链路层提供互联主机之间的通信。
		网络层：网络层的数据链路层的硬件地址之上提供逻辑地址系统，允许不同数据链路层网络的主机之间的通信。
		传输层：传输层提供远处主机进程之间端到端的通信。
		应用层：包括DHCP协议、DNS协议和游戏代码。
		在一些模型中，物理层被认为不是单独的一层。
	2.	为什么使用ARP协议？它是如何工作的？
		链路层需要一些方法来找出IP地址所对应的MAC地址。
		当网络层需要使用链路层向一台主机发送数据包时，首先查询ARP对应表获取目录IP地址所以应的MAC地址。
		如果表中没有找到映射，那么ARP模块通过给链路层网络中所有可达的主机发送ARP报文，来获得对应MAC地址。
	3.	解释一下有多个网卡的主机（如路由器）是如何在不同子网之间路由数据包的。
		见2.5.1.3 子网和间接路由。
	4.	MTU代表什么？它是什么意思？以太网的MTU是什么？
		MTU代表一次传输中所能传递数据的最大容量，称为最大输出单元。
		以太网标准规定帧内封装的报文数据最大长度为1500字节。
	5.	解释一下包分片是如何工作的。假设数据链路层的MTU是400，
		举一个需要分成两帧的数据包头部的例子，分片后这两帧的头部是什么？
		见2.5.1.4 分片。
	6.	避免IP分片有什么好外？
		（1）增加了网络上发送的数据量。
		（2）如果一个分片数据包在传输中丢失了，那么接收方必须丢弃整个数据包。
	7.	不使用分片技术，发送尽可能大的数据包的好处是什么？
		（1）增加了网络上发送的数据量。
		（2）如果一个分片数据包在传输中丢失了，那么接收方必须丢弃整个数据包。
	8.	不可靠的数据传输和可靠的数据传输有什么区别？
		可靠的数据传输保证所有的数据都按序抵达接收方。
	9.	描述一下建立连接时TCP握手的流程。交换了什么重要的数据？
		见2.6.2.2 三次握手。
	10.	描述一下TCP是如何做到可靠数据传输的。
		见2.6.2.3 数据传输。
	11.	公开可路由的IP地址和本地可路由的IP地址的区别是什么？
		互联网上的公开路由器都没有如何到达本地IP地址的路由信息，
		所以多个本地网络内部使用相同的本地IP地址是没关系的。
	12.	NAT是什么？使用NAT有哪些好处，有哪些开销？
		见2.8 NAT。
	13.	解释一下客户端是如何使用NAT向公开可路由的服务器发送数据包并收到响应数据包的。
		见2.8 NAT。
	14.	STUN是什么？为什么需要STUN？它是如何工作的？
		见2.8 NAT的NAT 穿越。
第3章 伯克利套接字
	1.	POSIX兼容的socket库和Windows实现有哪些不同？
		Windows的socket库是Winsock2，有时使用WSA前缀，来标记它们为非标准函数。
	2.	socket可以访问TCP/IP模型的哪两层？
		网络层和传输层。
	3.	解释一下为什么TCP服务器要为每一个连接的客户端创建唯一的socket，是如何实现的？
		TCP需要三次握手启动客户端和服务器之间的连接。
	4.	解释一下如何将socket绑定一个端口，这意味着什么？
		（1） 当传入数据包的目的地址和socket绑定的地址及端口一致时，
			  告诉操作系统这个socket应该是传入数据包的目标接收者。
		（2） 为从socket发送出云的数据包创建网络层和传输层头部的时候，它指定了socket库使用的源地址和端口。
	5.	修改SocketAddress和SocketAddressFactory，让它们支持IPv6地址。
		见书籍代码SocketUtil.h。
	6.	修改SocketUtil，让它支持创建TCP socket。
		见书籍代码SocketUtil.h。
	7.	实现聊天服务器，它使用TCP允许一台主机连接并来回传递消息。
		TODO：未实现。
	8.	在聊天服务器上添加支持多个客户端的程序。在客户端使用非阻塞socket，服务器使用select函数。
		TODO：未实现。
	9.	解释一下如何调整TCP接收窗口的最大值。
		调用setsockopt，参数为SO_RCVBUF。
第4章 对象序列化
	1.	为什么简单使用memcpy将一个对象复制到字节缓冲区并给远程主机发送这个缓冲区是不安全的？
		因为数据结构的内部没有被详细说明，所以按二进制位复制是不安全的。
	2.	什么是字节序？为什么它是数据序列化时的一个问题？解释一下如何处理数据序列化中的字节序问题。
		字节在一个平台上的存储顺序被称为这个平台的字节序。
		并不是所有的CPU存储多字节数字都是按照一样的字节顺序。
		当使用流来传输数据时，一个比较好的策略是流本身决定字节序。
		然后，当写一个多字节数据类型时，如果平台的字节序与所选择的流字节序不匹配时，在写入流时数据的字节序将被颠倒。
	3.	描述一下如何高效地压缩稀疏数据结构。
		去除不需要通过网络发送的消息。一个寻找此类信息的好地方是任何稀疏的和不被完全填充的数据结构。
	4.	给出针对包含指针的对象的两种序列化方法。举例说明每种方法使用的场合。
		（1）内联或者嵌入。（只要这个数据完全由序列化的父对象拥有）
		（2）链接。（如果数据需要与其他对象共享或者被其他对象引用）
	5.	什么是熵编码？举一个如何使用它的基本示例。
		它利用数据的不确定性进行压缩。含有期望数据的数据包比含有非期望数据的数据包蕴含更少的信息或者熵。
	6.	解释一下，序列化浮点数时，如何使用定点数来节省带宽。
		这样数据就可以使用所必需的最少比特来发送。
	7.	彻底解释一下为什么本章实现的WriteBits函数只适用于小端字节序平台。同时实现一个适用于大端字节序平台的函数。
		TODO：未实现。
	8.	实现OutputMemorySteam::Write(const unordered_map<int,int>&)方法，将一个整数到整数的映射写入流中。
		TODO：未实现。
	9.	实现OutputMemorySteam::Read(unordered_map<int,int>&)方法。
		TODO：未实现。
	10.	模板化复习题9实现的OutputMemorySteam::Read，使其适用于template<tKey,tValue> unordered_map<tKey,tValue>。
		TODO：未实现。
	11.	为仿射变换矩阵实现高效的Read和Write方法，利用它的放缩通常为1的条件，如果不为1，通常至少是均匀的。
		TODO：未实现。
	12.	实现一个带有通用序列化方法的模块，这个序列化方法基于模板而不是虚函数。
		TODO：未实现。
第5章 对象复制
	1.	除了对象的复制数据，数据包中的复制对象状态应该包含哪三个关键值？
		网络标识符、类标识符、世界状态增量。
	2.	为什么网络代码依赖游戏代码是不可取的？
		（1） 每次添加一个新的可能被复制的游戏类，都必须在网络代码中增加函数。
			  这很容易被忘记，从而导致代码不同步。
		（2） 如果想要在新游戏中重新使用你的复制系统，需要完全重写这些函数。
	3.	解释一下，如何在网络代码不依赖游戏代码的情况下，在接收端支持复制对象的创建。
		使用对象创建注册表。
	4.	实现一个包含5个移动对象的简单游戏。通过以每秒15次的频率给远程主机发送世界状态数据包，来给远程主机复制这些对象。
		TODO：未实现。
	5.	考虑问题4中的这个游戏，当游戏对象数据增加时会出现什么问题？如何解决这个问题？
		它要求整个世界状态必须能够装入一个数据包中，使用世界状态增量。
	6.	实现一个系统，支持给远程主机发送一个对象部分属性的更新。
		TODO：未实现。
	7.	什么是RPC？什么是RMI？两者的区别是什么？
		RPC：远程过程调用。
		RMI：远程方法调用。可以在一个特定对象上调用一个方法，而不仅仅调用一个自由函数。
	8.	使用本章的框架，实现RPC的SetPlayerName(const string& inName)方法，告诉其他主机本地玩家的名字。
		TODO：未实现。
	9.	实现一个自定义数据包类型，使用合理有效的带宽复制玩家当前在键盘上按下的键。
		解释一下，如何将该实现融入到本章的复制框架中。
		TODO：未实现。
第6章 网络拓扑和游戏案例
	1.	在客户端——服务器模型中，客户端的职责是如何区别于服务器的？
		如果客户端发现自己的游戏状态与服务器的不同，那么它应该根据服务器的游戏状态更新自己的状态。
	2.	在客户端——服务器模型的游戏中，可能的最坏延迟是什么？与对等网络模型游戏中的最坏延迟相比怎样？
		客户端A的RTT的1/2，服务器的处理时间，加上客户端B的RTT的1/2。
		对等网络的延迟是RTT的1/2。
	3.	相比于客户端——服务器模型，对等网络需要的连接数是多少？
		n平方。
	4.	对等网络游戏中模拟游戏状态的一种方法是什么？
		输入共享模型。
	5.	当前的机器猫行动游戏实现中，创建移动时没有平均多个帧的输入状态。实现这个功能。
		TODO：未实现。
	6.	以什么方式可以改进机器猫RTS游戏的启动过程？实现这一改进。
		TODO：未实现。
第7章 延迟、抖动和可靠性
	1.	非网络延迟的5个过程是什么？
		（1） 输入采样延迟。
		（2） 渲染流水线延迟。
		（3） 多线程渲染流水线延迟。
		（4） 垂直同步。
		（5） 显示延迟。
		（6） 像素响应时间。
	2.	网络延迟的四种因素是什么？
		（1） 处理延迟。
		（2） 传输延迟。
		（3） 排队延迟。
		（4） 传播延迟。
	3.	给出一种方法来降低每种网络延迟。
		见7.1.2 网络延迟。
	4.	RTT表示什么？它是什么意思？
		RTT表示往返时间，指的是数据包从一台主机传输到别一台主机的时间，加上响应数据包返回的时间。
	5.	抖动是什么？导致抖动的原因有哪些？
		见7.2 抖动。
	6.	扩展DeliveryNotificationManager::ProcessSequenceNumber()，使其能正确处理序列号回绕到0的情况。
		TODO：未实现。
	7.	扩展DeliveryNotificationManager，使得在DeliveryNotificationManager决定哪些数据包过时被丢失之前，
		在同一帧接收的所有数据包都被缓存并排序。
		TODO：未实现。
	8.	解释一下，ReplicationManager如何使用DeliveryNotificationManager提供比TCP更好的可靠性，并为丢失的数据包发送最新数据。
		见7.6 对象复制的可靠性。
	9.	使用DeliveryNotificationManager和ReplicationManager实现一个两玩家的追拍游戏。
		模拟真实世界情况来看看你的设计对数据包丢失、延迟和抖动的包容度。
		TODO：未实现。
第8章 改进的延迟处理
	1.	术语“沉默的客户端”是什么意思？游戏使用沉默客户端的主要好处是什么？
		客户端给服务器发送输入，然后服务器运行模拟并返回给客户端显示。保守算法至少是正确的。
	2.	客户端插值的主要优势是什么？主要缺点是什么？
		优势就是帮助减少额外的延迟感。缺点：仍然不能让客户端状态更接近服务器实际发生的状态。
	3.	在沉默的客户端中，给用户展示的状态至少滞后服务器上运行的真实状态多久？
		100毫秒。
	4.	保守算法与乐观算法的区别是什么？针对每种算法分别举一个例子。
		见8.3.1 航位推测法。
	5.	航位推测用于什么时候？它是怎样预测对象位置的？
		见8.3.1 航位推测法。
	6.	当预测的状态发生错误时，给出三种纠正预测状态的方法。
		（1） 即时状态更新。
		（2） 插值。
		（3） 二阶状态调整。
	7.	解释系统如何实现让本地玩家对于自己的移动感觉不到延迟。
		见8.3.2 客户端移动预测和重放。
	8.	服务器端回退是解决什么问题？主要优势是什么？主要不足是什么？
		见8.4 服务器端回退。
	9.	通过加入即时投射线球，扩展机器猫行动游戏，并实现使用服务器端回退的命中检测。	
		TODO：未实现。
第9章 可扩展性
	1.	只使用距离确定对象相关性的缺点是什么？
		见9.1 对象范围和相关性。
	2.	静态区域是什么？它的潜在好处是什么？
		见9.1.1 静态区域。
	3.	视锥如何用于裁剪目的？如果只使用视锥来确定对象相关性会发生什么？
		见9.1.2 使用视锥。
	4.	潜在可见集是什么？该方法与静态区域方法的不同是什么？
		见9.1.3 其他可见性技术。
	5.	如果共享世界的游戏随着区域内人满为患的危机，那么该问题的一些可能的解决方案是什么？
		见9.2 服务器分区和9.3 实例化。
	6.	除了减少相关对象的数量，还有什么方法能降低网络游戏的带宽需求？
		见9.4 优先级和频率。
第10章 安全性
	1.	描述中间人攻击可能执行的两种不同方式。
		见10.1 数据包嗅探。
	2.	公钥加密算法是什么？如何使用公钥加密算法最小化中间人攻击的风险？
		在RSA系统中，公钥是基于非常大的半素数，即两个素数的乘积。私钥是基于该半素数的素数因数分解。
	3.	举例说明什么时候输入验证可能犯假阳性的错误，意思是输入验证认为用户使用了作弊，但实际上没有。
		可能由于延迟或者数据包丢失。
	4.	允许玩家拥有他们自己服务器的游戏如何验证从服务器发送过来的数据。
		使用输入验证。
	5.	为什么不使用软件作弊检测，锁步对等网络游戏中的地图作弊就不能被检测到？
		见10.3 软件作弊检测。
	6. 	简要描述维尔福反作弊系统如何打击正在作弊的玩家。
		见10.3.1 维尔福反作弊系统。
	7.	描述两种不同的保护服务器不被入侵的方法。
		见10.4.4 入侵。
第11章 真实世界的引擎
	1.	Unreal和Unity都只提供客户端-服务器拓扑的内置支持，而不支持对等网络拓扑。这是为什么？
		见第11章 真实世界的引擎。
	2.	在Unreal中，网络游戏中actor的不同角色是什么，它们的重要性是什么？
		见11.1.2 游戏对象和拓扑。
	3.	描述Unreal中远程过程调用的不同使用案例。
		见11.1.4 远程过程调用。
	4.	描述Unity中游戏对象和组件是怎样工作的。这样一个系统的优点和缺点是什么？
		见11.2 Unity。
	5.	Unity如何实现变量同步和远程过程调用？
		见11.2 Unity。
第12章 游戏服务

第1章 网络游戏概述
	★	数据类型：
		1.	非保障数据。
		2.	保障数据。
		3.	最近的状态数据。
		4.	最快保障数据。
第2章 互联网
	★	分组交换：它取消了电路一个时刻专用于一个传输的限制，提供更高的可用性。
		它的实现是将传输的信息拆分成小块，称为分组，基于一种叫作存储转发的技术将它们发送到共享的线路中。
	★	五层网络模型：物理层、链路层、网络层、传输层和应用层。每层的职责包括：
		1.	接收上一层数据。
		2.	通过添加头部，有时尾部，对数据进行封装。
		3.	接收下一层传输来的数据。
		4.	去掉报头，解封装传输来的数据包。
		5.	将数据转发到上一层做进一步处理。
	★	物理层：
		物理层为网络中的计算机或主机提供物理连接。信息传输所必需的是物理介质。
	★	链路层：
		它的任务是提供一种网络实体之间通信的方法。
		链路层必须提供一种方法，该方法可以实现源主机封装信息、通过物理层传输信息、
		目的主机接收封装好的信息并从中提取所需的信息。
	★	链路层的数据传输单元称为帧：实体之间通过链路层彼此发送帧数据。链路层的职责包括：
		1.	定义主机的唯一标识方法，方便帧数据对接收方进行编址。
		2.	定义帧的格式，包括目的地址的格式和所传输数据的格式。
		3.	定义帧的长短，以便确定上层每一次传输所能发送的数据大小。
		4.	定义一种将帧转换为电子信号的物理方法，以便数据可以通过物理层传输，并被接收方接收。
	★	帧的传输是不可靠的。
	★	链路层不做任何操作来确认帧是否抵达接收方或者保证如果帧没有抵达重新发送。
		因此，链路层的通信是不可靠的。任何需要可靠数据传输的上层协议都必须自己来实现这一点。
	★	对于每种被选择作为物理层实现的物理介质，都有对应的协议或协议族来提供链路层所需的服务。
	★	两个远距离的主机之间的网络连接不会仅仅使用一种物理介质和一种链路层协议。
	★	为了给每台主机一个唯一标识，以太网引入了介质访问控制地址的概念，也就是MAC地址。
	★	MAC地址中的前24比特叫作组织唯一标识符，是由IEEE给厂家分配的唯一代码。
		后24比特是由厂家自己分配的，来保证所生产的硬件是唯一标识的。
	★	以太网链路层帧的格式：
		（0-7）前导序列和帧开始标志：0x55 0x55 0x55 0x55 0x55 0x55 0x55 0xD5
		（8-13）目的地址：帧接收方的MAC地址。FF:FF:FF:FF:FF:FF称为广播地址。
				表示同时向局域网中的所有主机都发送该帧。
		（14-19）源地址。
		（20-21）帧长度/类型域：值小于等于1500，它表示帧长度。
								如果取值大于等于1536，它表示协议类型。
		（22-？）数据（46-1500字节）。帧内封装的报文数据。
									  通常这是一个网络层数据包，通过在链路层交付到适当的主机。
		帧检验序列：是由两个地址域、帧长度/类型域、数据域和其他填充信息生成的循环冗余检验值。
	★	链路层的不足：
		1.	烧在硬件中的MAC地址限制了硬件的灵活性。
		2.	链路层不支持将互联网划分成更小的局域网络。
		3.	链路层不支持使用不同的链路层协议进行主机之间的通信。
	★	IPv4数据包的结构：
		（0-3）版本号：对于IPv4，该取值为4。
		（4-7）包头长度：描述IP包头的长度，以32比特为单位。
						 因为在IP数据包的包头中有变长的可选部分，所以IP数据包的包头长度是可变的。
		（8-15）服务类型：用于从拥塞控制到差异化服务识别的各种目的。
		（16-31）IP数据包的包总长：以字节为单位计算IP数据包的长度，包括头部和数据。
		（32-63）片标识符（16比特）、片标记（3比特）、片偏移（13比特）。
		（64-71）生存时间，用于限制数据包转发的次数。
		（72-79）标识用于解释数据内容所用的协议。
		（80-95）用于IPv4头部正确性的检测。
		（96-127）源地址：数据包发送方的IP地址。
		（128-159）目标地址：既可以是数据包接收方的IP地址，也可以是发送给多台主机的特殊地址。
		（160-？）可选项。
	★	链路层协议需要一些方法来找出IP地址所对应的MAC地址：
		有一个链路层协议提供了这样一种方法，即地址解析协议（ARP）。
	★	ARP报文格式：
		（0-1）硬件类型：指明了链路层所使用的硬件接口类型，以太网的取值为1。
		（2-3）协议类型：指明了正在使用的网络层协议所对应的以太网类型值。IPv4是0x0800。
		（4）硬件地址长度：指明了以字节为单位的链路层硬件地址长度。
						   在大部分情况下，该取值为MAC地址长度，即6。
		（5）IP地址长度：指明了以字节为单位的网络层协议逻辑地址长度。
						 对于IPv4，该取值为IP地址的长度，即4。
		（6-7）操作类型，取值是1或者2，表示报文是信息请示还是响应。
		发送方硬件地址：长度可变，是报文发送方的硬件地址。
		发送方IP地址：长度可度，是报文发送方的网络层地址。
		目标硬件地址和目标IP地址：均为长度可变，是报文接收方的硬件地址和IP地址。
								  如果报文类型是请示，那么目标硬件地址是未知的，被接收方忽略。
	★	子网掩码：
		是一个32比特数，如果主机的IP地址与子网掩码做按位与运算得到结果相同，那么这些主机在同一个子网中。
	★	网络层的任务是实现远程网络上两台遥远主机之间的通信，而传输层的任务是实现这些主机上单独进程之间的通信。
	★	端口是16比特的无符号数，是一台特定主机的通信端点。
	★	端口号1024-49151称为用户端口或注册端口。
	★	端口号0到1023称为系统端口或预留端口。
	★	端口49152到65535称为动态端口。
	★	用户数据报协议（UDP）是一个轻量级的协议 ，封装数据并将其从一台主机的一个端口发送到另一台主机的一个端口。
		UDP数据报包含一个8字节的报头，后面跟着数据。
	★	UDP报头：
		1.	源端口号（16比特）标识数据发送方将UDP数据报发送出去的端口。
		2.	目标端口号（16比特）是数据报的目标端口。
		3.	数据报长度（16比特）指包括报头和数据部分在内的总字节数。
		4.	检验和（16比特）由UDP报头、数据部分和IP头的某些域计算得到。它是一个可选项。
	★	传输控制协议（TCP）是在两台主机之间创建持久性的连接，提供可靠数据流传输。
	★	TCP保证所有的数据都按序抵达招收方。
	★	应用层：
		1.	DHCP：动态主机配置协议通过允许主机在接入网络时请示自动配置信息来解决。
		2.	DNS：域名系统协议 能够将域名和子域名翻译为IP地址。
		3.	NAT：如果一个IP地址被称为公开可路由的，互联网上任意正确配置的路由器都可以给这个IP地址所在的主机发送数据包。
第3章 伯克利套接字
	★	伯克利套接字应用程序接口提供了进程与TCP/IP模型各个层之间通信的标准方法。
	★	创建类型为SOCK_STREAM的socket是告诉操作系统，socket需要有状态的连接。
		操作系统则分配必要的资源来支持可靠的、有序的数据流。
	★	SOCK_DGRAM提供不稳定的连接，仅需要分配最少的必需资源来发送和接收单独的数据报。
		socket不需要花费资源来保证数据可靠和有序。
	★	当关闭TCP socket时，很重要的一件事是保证所有发送的和接收的数据都已经传输和确认。
		最好先停止socket传输，等待所有的数据被确认，所有传入的数据被读取，再关闭socket。
	★	当实例化BSD socket结构体时，一种好的方法是使用memset将所有的成员清零。
		这将有利于阻止来自未初始化字段的跨平台错误，当一个平台使用的字段在另外一个平台不使用的时候会出现这种情况。
	★	通知操作系统socket将使用一个特定地址和传输层端口的过程称为绑定。
	★	UDP是无状态的、无连接的和不可靠的，所以每台主机只需要一个单独的socket来发送和接收数据。
	★	TCP是可靠的，需要发送数据之前，在两台主机之间建立连接。
		此外，必须维护和存储状态以重新发送丢失的数据包。
	★	每帧轮询非阻塞socket是在不阻塞线程的情况下检查传入数据的一种简单直接的方式。
	★	总结：
		1.	伯克利套接字是最常用的实现网络中数据传输的架构。虽然库的接口在不同平台上存在差异，但是核心思想是一样的。
		2.	核心的地址数据类型是sockaddr，它可以表示多种网络层协议的地址。
			在需要指定目的地址或源地址的任何时候都可以使用它。
		3.	UDP socket是无连接的、无状态的。通过socket函数创建，使用sendto函数发送数据报。
			要想从UDP socket接收UDP数据包，必须首先使用bind函数保留一个操作系统的端口，然后使用recvfrom取回传入的数据。
		4.	TCP socket是有状态的，在传输数据之前必须建立连接。调用connect初始化一个连接。
			调用listen监听传入的连接。当一个连接到达监听socket，调用accept创建一个新socket作为连接的本地端点。
			使用send从连接的socket发送数据，使用recv接收数据。
		5.	socket操作可以阻塞调用线程，为实时应用带来了问题。
			为了避免这个问题，可以在非实时的线程上实现潜在阻塞的调用，
			或者设置socket为非阻塞模式，或者使用select函数。
		6.	使用setsockopt配置socket选项来定制socket行为。
			一旦完成创建和配置，socket提供通信的路径，使得网络游戏成为可能。
第4章 对象序列化
	★	序列化是一种将对象从内存中的随机访问格式转换为比特流格式的行为。
	★	流指的是一种数据结构，封装了一组有序的数据元素，并允许用户对其进行数据读写。
	★	一个流是其他数据结构或计算资源的接口。
		1.	文件输出流可以封装一个已经打开准备写的文件，提供顺序存储不同类型的数据到磁盘的简单方法。
		2.	网络流可以封装一个socket，提供send()和recv()函数的封装，专门用于与用户相关的特定数据类型。
	★	内存流封装了内存的缓冲区，通常是动态分配在堆栈上的缓冲区。
	★	输出内存流有顺序写入缓冲区的方法，同时提供对缓冲区本身进行读取访问的访问器。
	★	你不会每次数据包到达时都为流分配内存，因为内存分配很慢。
		而是你有一个预分配的最大尺寸的流，每当数据包到达，你会直接接收到该分配的缓冲区，
		然后从流中读完并处理数据，再设置mHead为，这样当下一个数据包到达时，流已经准备好接收。
	★	字节在一个平台的存储顺序被称为这个平台的字节序。
		1.	小端字节序的平台存储多字节数字是将低序字节存储在起始地址（低位编址）。
		2.	大端字节序将高序字节存储在起始地址（高位编址）。
	★	熵编码是信息论的一个主题，它复用数据的不确定性进行数据压缩。
	★	根据信息论，含有期望数据的数据包比含有非期望数据的数据包蕴含更少的信息或者熵。
		代码在发送期望数据时应当比发送非期望数据需要更少的比特数。
	★	定点数是一个数，看起来像整数，但实际上会将其进行缩放和加减来表示一个浮点数。
	★	总结：
		1.	序列化是将复杂的数据结构拆解成线性字节数组的过程，可以通过网络发送给另外一台主机。
			流，序列化的主要场所，使得序列化复杂数据结构成为可能，包括引用其他数据结构并在反序列化之后重新链接这些引用。
		2.	有许多技术来实现高效的数据序列化。
			（1） 稀疏数据结构可以被序列化为更紧凑的形式。
			（2） 成员变量的频繁取值可以通过熵编码无损压缩。
			（3） 几何数据结构或者其他类似的受约束数据结构可以通过使用这些限制被无损压缩，仅仅发送重构该数据结构所必需的数据。
			（4） 当可以接受略微有损的压缩时，可以根据已知的范围和所需精度将浮点数转换成定点数。
		3.	一个数据结构的Read和Write方法可以缩减为一个Serialize方法，根据所操作的流来区分读还是写。
		4.	使用这些工具，可以将你需要的任何东西打包成一个对象，并发送给远程主机。
第5章 对象复制
	★	通过在每台主机上构建一个世界状态并交换任何所需要的信息来保持主机之间状态的一致性。
	★	有多种不同方法来创建和实施远程主机之间世界状态的一致性。一种常见的方法是有一台服务器给所有相连的客户端发送世界状态。
	★	从一台主机向另一台主机传输对象状态的行为称为复制：
		1.	标记数据包为包含对象状态的数据包。
		2.	唯一标识复制对象。
		3.	指明被复制对象的类型。
	★	最好是游戏代码依赖网络代码，但是网络代码应该几乎不依赖游戏代码。
	★	减少游戏代码和网络代码之间耦合的一种清晰的方式是使用对象创建注册表将对象识别和创建例程从复制系统中抽象出来。
	★	一个对象创建注册表是将一个类标识符映射到一个函数，该函数创建一个特定类的对象。
	★	对每个对象重复执行以下步骤：
		1.	写对象的网络标识符。
		2.	写对象的类标识符。
		3.	写对象的序列化数据。
	★	因为世界状态由对象状态组成，所以世界状态增量包含需要改变的每个对象的对象状态增量。
	★	每个对象状态增量表示以下三种复制行为中的一种：
		1.	创建游戏对象。
		2.	更新游戏对象。
		3.	销毁游戏对象。
	★	总结：
		1.	对象复制不仅仅涉及从一台主机向另外一台主机发送序列化数据。
			（1） 应用层协议必须定义所有可能的数据包类型。
			（2） 网络模块应该标记数据包为包含对象数据的数据包。
			（3） 每个对象需要一个唯一的标识符。
			（4） 如果接收者不存在这个对象，可以基于正确的类创建对象。
			（5） 网络代码不依赖游戏类，所以使用某种形式的间接映射来向网络模拟注册类和创建函数。
		2.	小规模的游戏可以通过在输出数据包中装入世界中的每个对象来实现主机之间共享一个世界。
			大规模的游戏没办法将所有对象的复制数据装入一个数据包，所以必须使用一个协议来支持世界状态增量的传输。
		3.	游戏需要复制的不仅仅是主机之间的对象状态数据。经常需要在彼此主机上触发过程过程调用。
第6章 网络拓扑和游戏案例
	★	网络拓扑决定了网络中计算机之间是如何连接的。
	★	在客户端——服务器拓扑结构中，一个游戏实例被指定为服务器，其他所有的游戏实例被指定为客户端。
		每个客户端只能和服务器通信，同时服务器负责与所有客户端通信。
	★	导致这种延迟的一个重要原因是往返时间，即数据包从发送端到目的主机，
		再从目的主机到发送端总共经历的时间。
	★	专用服务器的另外一种替代方案是监听服务器。
		在这个设置中，服务器也是游戏本身的积极参与者。
	★	监听服务器方案的一个优点是降低部署成本，因为不需要在数据中心租用服务器，
		相反地，玩家可以使用自己的计算机既作为服务器也作为客户端。
	★	监听服务器的不足是作为监听服务器的计算机性能必须足够高，而且需要足够快的网络连接以应付服务器的额外负载。
	★	监听服务器方案有时被错误地称为对等网络连接，但是一个更准确的说法是对等托管。
	★	一个使用监听服务器的游戏实现一种主机迁移的概念，意思是如果监听服务器断开，客户端中的一个被晋升为新的服务器。
	★	在对等网络拓扑中，每个单独的参与者都与其他所有的参与者连接。
	★	在对等游戏中更常见的做法是每个对等体共享所有动作，每个对等体都模拟这些动作的执行。
		这种模式有时也被称为输入共享模型。
第7章 延迟、抖动和可靠性
	★	非网络延迟：
		1.	输入采样延迟。
		2.	渲染流水线延迟。
		3.	多线程渲染流水线延迟。
		4.	垂直同步。
		5.	显示延迟。
		6.	像素响应时间。
	★	网络延迟：
		1.	处理延迟。
		2.	传输延迟。
		3.	排队延迟。
		4.	传播延迟。
	★	往返时间RTT指的是数据包从一台主机传输到别一台主机的时间，加上响应数据包返回的时间。
	★	数据包丢失有这么多原因：
		1.	不可靠的物理介质。
		2.	不可靠的链路层。
		3.	不可靠的网络层。
	★	减少数据包丢失的最简单方法是保证服务器有快速、稳定的互联网连接，并离客户端尽可能近。
	★	TCP的主要优点是：它提供了一个经得起时间考验、鲁棒的、稳定的可靠性实现。
	★	TCP的主要缺点是，它发达的所有东西必须被可靠发送并按序处理。
		1.	低优先级数据的丢失干扰高优先级数据的接收。
		2.	两个单独的可靠有序数据流相互干扰。
		3.	过时游戏状态的重传。
	★	可靠性的首要要求是，有能力知道数据包是否到达目的地。
第8章 改进的延迟处理
	★	服务器唯一拥有真实的正确游戏状态的主机。
	★	服务器是唯一运行最重要模拟的主机。
	★	运行在服务器上的真实模拟通常比远程玩家感觉到的真实模拟早半个往返时间。
	★	客户端给服务器发送输入，然后服务器运行模拟并返回给客户端显示。
		这些游戏中的客户端被称为沉默的终端，因为它们并不需要对模拟有任何了解，
		所以这种网络方法被称为保守算法。
	★	来自服务器不频繁的状态更新带来的跳跃结果让玩家感觉他们的游戏运行速度比实际慢。
		缓解这个问题的一种方法是通过客户端插值。
	★	客户端可以接收略旧的状态，并在显示给玩家之前推测近似的最新状态。这种推测技术通常称为客户端预测。
	★	航位推测法是基于实体继续做当前正在做的事情这一假设，进行实体行为预测的过程。
	★	航位模拟被认为是不保守的算法，称为乐观算法。
	★  当客户端检测到它的本地模拟发生错误时，有三种方式来弥补：
		1.	即时状态更新。
		2.	插值。
		3.	二阶状态调整。
	★	服务器端回退
		1.	远程玩家使用客户端插值，而不是航位推测。
		2.	使用本地客户端移动预测和移动重放。
		3.	发送给服务器的每个移动数据包中保存客户端视角。
		4.	在服务器端，存储每个相关对象最近几帧的位置。
第9章 可扩展性
	★	对象范围或相关性：对于一个特定的客户端，一个对象在范围内或相关是指应该通知客户端关于该对象的更新信息。
	★	减少相关对象数量的一种方法是将世界划分为一些静态区域。
		只有和玩家在同一个静态区域的对象才被认为是相关的。
	★	静态区域对于共享世界的游戏是可行的，但是它通常不用于动作游戏：
		1.	大部分动作游戏的战斗区域比MMO游戏中看到的区域小得多。
		2.	大部分动作游戏的速度意味着穿越区域边界引起的延迟是不能接受的。
	★	一种解决方案是同时使用视锥和基于距离的系统。
	★	服务器分区或分片是指同时运行多个服务器进程的概念。
	★	服务器减慢了游戏的时间步长，这种慢动作模式称为时间膨胀，允许服务器将所有玩家保持连接状态，否则无法保持这么多连接。
	★	在实例化中，一个共享的游戏同时支持多个不同的实例。
第10章 安全性
	★	一些消费级路由器为了实现服务质量，采用深度包检测。服务质量系统需要读取数据包来确定其包含什么内容。
	★	数据包嗅探是一个术语，用于表示以非正常网络操作目的读取数据包数据。
	★	你的游戏需要发送对外界保密的敏感数据，那么推荐使用经过验证的加密系统。
		你会希望使用公钥加密算法，一种适合于传输案例信息的加密算法。
	★	在RSA系统中，公钥是基于非常大的半素数，即两个素数的乘积。私钥是基于该半素数的素数因数分解。
	★	输入验证是努力保证没有玩家执行的动作是无效的。
	★	一般情况下，一个正确的方法是更保守地直接拒绝无效输入。
	★	软件作弊检测中，作为游戏进程的一部分或者游戏进程外的软件主动监测游戏的完整性。
	★	分布式拒绝服务攻击的目的是让服务器不能成功地完成请求，最终导致服务器不可达或者对于合法用户不可用。
第11章 真实世界的引擎
	★	服务器可以以两种不同的模式运行：专用服务器和监听服务器。
	★	三种角色：
		1.	权威。
		2.	模拟代理。
		3.	自治代理。
	★	服务器函数是在客户端上调用并在服务器上执行的函数。
	★	客户端函数与服务器函数相反。当服务器调用客户端函数时，这个过程调用被发送给拥有所讨论的actor的客户端。
	★	多播函数将被发送到多个游戏实例。
第12章 游戏服务