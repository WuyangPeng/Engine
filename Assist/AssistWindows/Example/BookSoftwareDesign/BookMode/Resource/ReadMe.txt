书・软件设计・模式 模块 

1.  设计模式解析（Design Patterns Explained）
（第2版）

官方网站：
http://www.netobjectives.com/dpexplained （已失效） 、https://portal.netobjectives.com/pages/books/design-patterns-explained/

★★★
作者：  Alan Shalloway、James R.Trott

前言
	从面向对象到模式再到真正的面向对象
	从人工智能到模式再到真正的面向对象
	本书约定
	第一人称
	便于浏览
	示例代码
	策略和原则
	展现广度，形成认识
	反馈
	第2版的新内容
	致谢
第一部分 面向对象软件开发简介
	第1章  面向对象范型
		1.1 概览
		1.2 面向对象范型之前：功能分解
		1.3 需求问题
		1.4 应对变化：使用功能分解
		1.5 应对需求变量
		1.6 面向对象范型
		1.7 面向对象程序设计实践
		1.8 特殊对象方法
		1.9 小结
		复习题
			简答题
			阐述题
			观点与应用题
	第2章  UML
		2.1 概览
		2.2 什么是UML
		2.3 为什么使用UML
		2.4 类图
		2.5 交互图
		2.6 小结
		复习题
			简答题
			阐述题
			观点与应用题
第二部分 传统面向对象设计的局限
	第3章  对代码灵活性要求很高的问题
		3.1 概览
		3.2 提取CAD/CAM系统的信息
		3.3 了解专业术语
		3.4 问题描述
		3.5 挑战及其解决方案
		3.6 小结
		复习题
			简答题
			阐述题
			观点与应用题
	第4章  标准的面向对象解决方案
		4.1 概览
		4.2 作为特例来解决
		4.3 小结
		复习题
			简答题
			阐述题
			观点与应用题
第三部分 设计模式
	第5章  设计模式简介
		5.1 概览
		5.2 设计模式源自建筑学和人类学
		5.3 从建筑模式到软件设计模式
		5.4 为什么学习设计模式
		5.5 学习设计模式的其他好处
		5.6 小结
		复习题
			简答题
			阐述题
			观点与应用题
	第6章  Facade模式
		6.1 概览
		6.2 Facade模式简介
		6.3 学习Facade模式
		6.4 实践注记：Facade模式
		6.5 Facade模式与CAD/CAM问题的联系
		6.6 小结
		复习题
			简答题
			阐述题
			观点与应用题
	第7章  Adapter模式
		7.1 概览
		7.2 Adapter模式简介
		7.3 学习Apapter模式
		7.4 实践注记：Apapter模式
		7.5 Adapter模式与CAD/CAM问题的联系
		7.6 小结
		复习题
			简答题
			阐述题
			观点与应用题
	第8章  开拓视野
		8.1 概览
		8.2 对象：传统看法与新看法
		8.3 封装：传统看法与新看法
		8.4 发现变化并将其封装
		8.5 共性和可变性分析与抽象类
		8.6 敏捷编程的品质
		8.7 小结
		复习题
			简答题
			阐述题
			观点与应用题
	第9章  Strategy模式
		9.1 概览
		9.2 处理新需求的一种途径
		9.3 国际电子商务系统案例研究：最初的需求
		9.4 处理新的需求
		9.5 Strategy模式
		9.6 实践注记：使用Strategy模式
		9.7 小结
		复习题
			简答题
			阐述题
			观点与应用题
	第10章  Bridge模式
		10.1 概览
		10.2 Bridge模式简介
		10.3 学习Bridge模式：示例
		10.4 对使用设计模式的观察
		10.5 学习Bridge模式：通过将它推演出来
		10.6 Bridge模式回顾
		10.7 实践注记：使用Bridge模式
		10.8 小结
		复习题
			简答题
			阐述题
			观点与应用题
	第11章  Abstract Factory模式
		11.1 概览
		11.2 Abstract Factory模式简介
		11.3 学习Abstract Factory模式：示例
		11.4 学习Abstract Factory模式：实现该模式
		11.5 实践注记：Abstract Factory模式
		11.6 将Abstract Factory模式与CAD/CAM问题联系起来
		11.7 小结
		复习题
			简答题
			阐述题
			观点与应用题
第四部分 组合起来：用模式思考
	第12章  专家设计之道
		12.1 概览
		12.2 添加特征的创建方式
		12.3 小结
		复习题
			简答题
			阐述题
			观点与应用题
	第13章  用模式解决CAD/CAM问题
		13.1 概览
		13.2 对CAD/CAM问题的回顾
		13.3 用模式思考
		13.4 用模式思考：步骤1
		13.5 用模式思考：步骤2a
		13.6 用模式思考：步骤2b
		13.7 用模式思考：步骤2c
		13.8 用模式思考：重复步骤2a和2b（Facade模式）
		13.9 用模式思考：重复步骤2a和2b（Adapter模式）
		13.10 用模式思考：重复步骤2a和2b（Abstract Factory模式）
		13.11 用模式思考：步骤3
		13.12 与原解决方案的比较
		13.13 小结
		复习题
			简答题
			阐述题
			观点与应用题
第五部分 迈向新的设计方式
	第14章  设计模式的原则和策略
		14.1 概览
		14.2 开闭原则
		14.3 从背景设计原则
		14.4 封装变化原则
		14.5 抽象类与接口
		14.6 理性怀疑原则
		14.7 小结
		复习题
			简答题
			阐述题
			观点与应用题
	第15章  共性与可变性分析
		15.1 概览
		15.2 共性和可变性分析与应用程序设计
		15.3 用CVA解决CAD/CAM问题
		15.4 小结
		复习题
			简答题
			阐述题
			观点与应用题
	第16章  分析矩阵
		16.1 概览
		16.2 现实世界：充满变化
		16.3 国际电子商务系统案例研究：应对变化
		16.4 实践注记
		16.5 小结
		复习题
			简答题
			阐述题
			观点与应用题
	第17章  Decorator模式
		17.1 概览
		17.2 更多细节
		17.3 Decorator模式 
		17.4 将Decorator模式应用到我们的案例研究
		17.5 另一个例子：输入/输出
		17.6 实践注记：使用Decorator模式 
		17.7 Decorator模式的本质
		17.8 小结
		复习题
			简答题
			阐述题
			观点与应用题
第六部分 其他重要模式
	第18章  Observer模式
		18.1 概览
		18.2 模式的分类
		18.3 国际电子商务案例的更多需求
		18.4 Observer模式
		18.5 将Observer模式应用到我们的案例研究
		18.6 实践注记：使用Observer模式
		18.7 小结
		复习题
			简答题
			阐述题
			观点与应用题
	第19章  Template Method模式
		19.1 概览
		19.2 案例研究的更多需求
		19.3 Template Method模式
		19.4 将Template Method模式应用到我们的案例研究
		19.5 使用Template Method模式减少冗余
		19.6 实践注记：使用Template Method模式
		19.7 小结
		复习题
			简答题
			阐述题
第七部分 各种工厂模式
	第20章  来自设计模式的教益：各种工厂模式
		20.1 概览
		20.2 工厂
		20.3 再谈背景
		20.4 工厂遵循我们的准则
		20.5 限制变化的影响 
		20.6 对工厂的另一种思考方式 
		20.7 工厂的不同角色
		20.8 实践注记
		20.9 小结
		复习题
			简答题
			阐述题
			观点与应用题
	第21章  Singleton模式和Double-Checked Locking模式
		21.1 概览
		21.2 Singleton模式简介
		21.3 将Singleton模式应用到我们的案例研究
		21.4 一种变体：Double-Checked Locking模式
		21.5 反思
		21.6 实践注记：使用Singleton模式和Double-Checked Locking模式
		21.7 小结
		复习题
			简答题
			阐述题
			观点与应用题
	第22章  Object Pool模式
		22.1 概览
		22.2 一个需要对对象进行管理的问题
		22.3 Object Pool模式
		22.4 观察：工厂的作用不仅是实例化
		22.5 小结
		复习题
			简答题
			阐述题
			观点与应用题
	第23章  Factory Method模式
		23.1 概览
		23.2 案例研究的更多需求
		23.3 Factory Method模式
		23.4 Factory Method模式与面向对象语言
		23.5 实践注记：使用Factory Method模式
		23.6 小结
		复习题
			简答题
			阐述题
			观点与应用题
	第24章  工厂模式的总结
		24.1 概览
		24.2 软件开发过程中的步骤
		24.3 工厂与极限编程实践殊途同归
		24.4 系统的扩展性
第八部分 终点与起点
	第25章  设计模式回顾：总结和新起点
		25.1 概览
		25.2 面向对象原则的总结
		25.3 设计模式如何封装实现
		25.4 共性和可变化分析与设计模式
		25.5 按责任分解问题域
		25.6 模式和从背景设计 
		25.7 模式内部的关联
		25.8 设计模式与敏捷编程实践
		25.9 实践注记
		25.10 小结
		复习题
			简答题
			阐述题
			观点与应用题
	第26章  参考书目
		26.1 本书配套网站
		26.2 推荐阅读
		26.3 针对Java程序员的推荐读物
		26.4 针对C++程序员的推荐读物
		26.5 针对COBOL程序员的推荐读物
		26.6 极限编程的推荐读物
		26.7 程序设计的一般性推荐读物
		26.8 个人推荐

2.设计模式：可复用面向对象软件的基础  （Design Patterns:Elements of Reusable Object-Oriented Software）

官方网站：
http://st-www.cs.uiuc.edu/users/patterns/DPBook/DPBook.html （已失效）

★★★
作者：Erich Gamma、Richard Helm、Ralph Johnson、John Vlissides  

前言
第1章  引言
	1.1 什么是设计模式
	1.2 Smalltalk MVC中的设计模式
	1.3 描述设计模式
	1.4 设计模式的编目
	1.5 组织编目
	1.6 设计模式怎样解决设计问题
		1.6.1 寻找合适的对象
		1.6.2 决定对象的粒度
		1.6.3 指定对象接口
		1.6.4 描述对象的实现
		1.6.5 运用复用机制
		1.6.6 关联运行时刻和编译时刻的结构
		1.6.7 设计应支持变化 
	1.7 怎么选择设计模式
	1.8 怎样使用设计模式
第2章  实例研究：设计一个文档编辑器
	2.1 设计问题
	2.2 文档结构
		2.2.1 递归组合
		2.2.2 图元
		2.2.3 组合模式
	2.3 格式化
		2.3.1 封装格式化算法
		2.3.2 Compositor和Composition
		2.3.3 策略模式
	2.4 修饰用户界面
		2.4.1 透明围栏
		2.4.2 MonoGlyph
		2.4.3 Decorator模式
	2.5 支持多种视感标准
		2.5.1 对象创建的抽象
		2.5.2 工厂类和产品类
		2.5.3 Abstract Factory模式
	2.6 支持多种窗口系统
		2.6.1 我们是否可以使用Abstract Factory模式
		2.6.2 封装实现依赖关系
		2.6.3 Window和WindowImp
		2.6.4 Bridge模式
	2.7 用户操作
		2.7.1 封装一个请求
		2.7.2 Command类及其子类
		2.7.3 撤消和重做
		2.7.4 命令历史记录
		2.7.5 Command模式
	2.8 拼写检查和断字处理
		2.8.1 访问分散的信息
		2.8.2 封装访问和遍历
		2.8.3 Iterator类及其子类
		2.8.4 Iterator模式
		2.8.5 遍历和遍历过程中的动作
		2.8.6 封装分析
		2.8.7 Visitor类及其子类
		2.8.8 Visitor模式
第3章  创建型模式
	3.1 ABSTRACT FACTORY（抽象工厂）――对象创建型模式
	3.2 BUILDER（生成器）――对象创建型模式
	3.3 FACTORY METHOD（工厂方法）――对象创建型模式
	3.4 PROTOTYPE（原型）――对象创建型模式
	3.5 SINGLETON（单件）――对象创建型模式
	3.6 创建型模式的讨论
第4章  结构型模式
	4.1 ADAPTER（适配器）――类对象结构型模式
	4.2 BRIDGE（桥接）――对象结构型模式
	4.3 COMPOSITE（组成）――对象结构型模式
	4.4 DECORATOR（装饰）――对象结构型模式
	4.5 FACADE（外观）――对象结构型模式
	4.6 FLYWEIGHT（享元）――对象结构型模式
	4.7 PROXY（代理）――对象结构型模式
	4.8 结构型模式的讨论
		4.8.1 Adapter与Bridge
		4.8.2 Composite、Decorator与Proxy
第5章  行为模式
	5.1 CHAIN OF RESPONSIBILITY（职责链）――对象行为型模式
	5.2 COMMAND（命令）――对象行为型模式
	5.3 INTERPRETER（解释器）――类行为型模式
	5.4 ITERATOR（迭代器）――对象行为型模式
	5.5 MEDIATOR（中介者）――对象行为型模式
	5.6 MEMENTO（备忘录）――对象行为型模式
	5.7 OBSERVER（观察者）――对象行为型模式
	5.8 STATE（状态）――――对象行为型模式
	5.9 STRATEGY（策略）――对象行为型模式
	5.10 TEMPLATE METHOD（模板方法）――类行为型模式
	5.11 VISITOR（访问者）――对象行为型模式
	5.12 行为模式的讨论
		5.12.1 封装变化 
		5.12.2 对象作为参数
		5.12.3 通信应该被封装还是被分布
		5.12.4 对发送者和接收者解耦
		5.12.5 总结
第6章  结论
	6.1 设计模式将带来什么
	6.2 一套通用的设计词汇
	6.3 书写文档和学习的辅助手段
	6.4 现有方法的一种补充
	6.5 重构的目标
	6.6 本书简史
	6.7 模式界
	6.8 Alexander的模式语言
	6.9 软件中的模式
	6.10 邀请参与
	6.11 临别感想
附录
	附录A 词汇表
	附录B 图示符号指南
	附录C 基本类

3.  程序设计的模式语言（Pattern Languages of Program Design）

卷1
★
作者：James O.Coplien、Douglas C. Schmidt  

第1部分 框架和组件
	第1章  功能点选
	第2章  一套基于工具和材料比喻的工具构造和集成模式语言
		背景和动机
		总体方法
		中心思想和设计比喻
			设计比喻和设计模式之间的区别
			工具和材料比喻
		工具构造和集成设计模式
			图形符号
			设计模式线路图
			工具构造设计模式
			单个工具设计模式的应用
		工具集成
			扩展范例
			工具集成设计模式
			展望：系统边界
		实际运转的工具和材料
		工具和材料比喻
		展望
		致谢
		参考文献
	第3章  灵活的命令解释器：一个可扩展、语言无关解释器系统模式
	第4章  旧服务器，新客户端：一套客户/服务器框架模式语言
		介绍
		关于具体化的注解
		例外
		单人游戏
		记录对象
		请求
		实物化
		终结化
		身份管理
		巨滚
		搜索业务对象
		依赖性
		创建和更新业务对象
		工厂方法
		窗口保管
		察看
		一个客户/服务器框架
		结论
		致谢
		参考文献
第2部分 系统和分布式处理
	第5章  一套生成式的分布处理模式语言
		对模式和它们用途的一些思考
		朝着一套分布式计算的模式语言前进 
			名称：定义数据结构
			名称：确定名词
			名称：抽取公用属性
			名称：规范化角色
			名称：确定问题领域关系
			名称：引入虚拟属性
			名称：激活数据
			名称：时间线索分析
			命名：决定参与者
			原始会议模式
		参考文献
	第6章  G++：一套计算机集成制造模式语言
		摘要
		介绍
			应用领域
			论文组织
		模式语言
			模式1 控制层次的层级
			模式2 控制模块之间的可见性和通信
			模式3 按并发性给对象分类
			模式4 事件触发的动作
			模式5 服务“等待”
			模式6 客户端/服务器/服务模型：实现控制模块
			模式7 “多类型服务”控制模块的实现
			模式8 控制模块的接口
			模式9 原型和现实
			模式10 控制模块分布
		和“设计模式编目”比较
		结论
		致谢
		参考文献
	第7章  分层体系结构的创建模式
		摘要
		背景
		模式
			阶梯模式
			桥接模式
			对称重用模式
			提升引用以增强可重用性
		参考文献
	第8章  半对象+协议模式
	第9章  主从模式
		摘要
		介绍
		模式
			理由
			适用性
			分类
			描述
			动态行为
			方法
			实现
			示例
			讨论
		参考文献
第3部分 业务对象
	第10章  信息完整性的CHECKS模式语言
		整值
		异常值
		无意义行为
		回显
		可见含义
		延迟验证
		快速预测
		假定发布
		预测确认
		诊断式查询
	第11章  帐户号码模式
		模式
		参考文献
		致谢
	第12章  星型结构：一种查询优化方案模式语言
		查询优化过的数据库
		整个业务实体
		关键业务活动和影响
		事务处理历史
		人员、地点和事物 
		时间
		维上卷
第4部分 过程与组织
	第13章  产生式开发过程模式语言
		介绍
			语言内容
			语言的驱动因素
			组织内无名的质
			语言原理
			备注
			致谢
		模式语言
			模式1：确定组织的规模
			模式2：自选团队
			模式3：独奏爱好者
			模式4：确定进度
			模式5：形式服从功能
			模式6：角色的专业知识
			模式7：逐步深入
			模式8：见习生
			模式9：组织服从位置
			模式10：组织服从市场
			模式11：开发人员控制过程 
			模式12：老板
			模式13：体系结构设计师控制产品
			模式14：反向法则
			模式15：体系结构设计师也进行实现
			模式16：检查体系结构
			模式17：代码所有权
			模式18：根据测试设计划分应用设计
			模式19：进行品质保证
			模式20：客户交往
			模式21：分组验证
			模式22：场景定义问题
			模式23：雇佣分析员
			模式24：防火墙
			模式25：看门人
			模式26：形成循环圈
			模式27：转移职责
			模式28：水牛山
			模式29：内部工作流
			模式30：每个角色需要3-7个助手
			模式31：命名的稳定基础
			模式32：分治
			模式33：分解各个阶段
			模式34：轮轴、钢圈和辐条
			模式35：美学模式
			模式36：耦合减少延迟
			模式37：原型
			模式38：不要打盹
			模式39：配对开发
			模式40：中止阻塞
			模式41：不要打断一个中断
			模式42：成功补偿
		参考文献
	第14章  生命周期以及支持演变和利用的重构模式
		介绍
		背景对象深化
		模式：原型化均衡设计 
			上下文
			问题
			解决方案
			相关模式
		模式：扩展初始原型
			上下文
			问题
			解决方案
			相关模式
		模式：合并程序以支持演化和重用
			上下文
			问题
			解决方案
			相关模式
		模式：从继承层次结构中演化聚合
			上下文
			问题
			解决方案
			相关模式
		模式：创建抽象超类
			上下文
			问题
			解决方案
			相关模式
		讨论
		致谢
		参考文献
	第15章  PAPPeL：一种用于面向对象开发的“需求分析过程”模式语言
		摘要
		RAPPeL的基本原理 
		警告
		模式语言模式1：构建正确的东西
		模式5：客户期望的管理与满足
		模式9：客户和谐
		模式14：赞助人意图
		模式17：定义需求
		模式20：问题域分析
		模式22：信息需求
		模式24：域对象的寻找和定义 
		模式25：域对象的分类、关联与分组
		模式26：域对象的细化 
		模式27：对象老化
		模式28：对象造型
		模式30：行为性需求
		模式32：展望
		模式34：需求规范
		模式36：业务规则
			解决方案
			约束用例的规则
			约束对象及其状态的规则
		模式40：实用外部需求
		模式50：用户界面需求
		模式97：原型
		模式99：需求验证
		参考文献
	第16章  毛虫的命运：一种用于分析――设计转换的模式语言
		摘要
		介绍
		CF模式语言
		模式1：并发执行线程
		模式2：并发线程同步
		模式3：协作工作包
		模式4：工作包内容
		模式5：工作包状态报告
		模式6：工作包完工报告 
		模式7：工作包优先级
		模式8：工作包安全性
		模式9：程序形态
		模式10：系统成员的角色
		模式11：决策制定者的角色
		模式12：工作人员的角色
		模式13：接口的角色
		模式14：信息化角色
		模式15：小家族系统
		模式16：通过对话完成的工作
		模式17：关键区域保护
		模式18：事件获取
		模式19：事件路由
		模式20：人机界面角色是一种特殊的接口角色
		模式21：数据知其出处
		CF的使用
		CF的状态
		相关事宜
		参考文献
第5部分 设计模式及其编目
	第17章  一种模式系统
		摘要
		介绍
		一种模式系统
		如何描述模式
		模式的分类
			粒度
			功能
			结构化原则
		模式
			体系架构级框架
			设计模式
		异构的体系架构
		经验
		未决事宜
		相关研究工作
		结论与展望
		参考文献
	第18章  设计模式之间的关系
		摘要
		介绍
		设计模式目录的总结构
		关系分类
			需要解决的问题
			关系类别
			分类
			使用分类 
		更改关系和设计模式
			一个新设计模式：Objectifier
			其他更改
		设计模式层
			层中的组织
			基本设计模式和技术
			解决典型软件问题的设计模式
			针对特定应用域的设计模式
			其他组织
		相关著作
		结论
		参考文献
		附录：对象化器模式描述
	第19章  发现现有应用中的模式
		介绍
		模式
			容器模式
			高层设计模式
			低层设计模式
		小结
		参考文献
		附录
	第20章  实现模式
		介绍
		抽象模式和具体模式
		实现过程中模式被摒弃
		多簇相互依赖的类
		模式类
		常用模式库
		例证
		概念问题
		致谢
		参考文献
		附录A：模式作为一个类
		附录B：类组合的C++实现
第6部分 体系结构与通信
	第21章  流：“拉力驱动”式处理的一种模式
		模式名称：流
		参考文献
	第22章  管道和过滤器体系结构
		摘要
		介绍
		模式
		结论
		参考文献
		附录
	第23章  基于模式的集成体系结构
		摘要
		介绍
		集成模式的范例
		结论
		致谢
		参考文献
		相关书目 
	第24章  软件体系结构的模式
		摘要
		软件体系结构的设计模式
		组件包装和交互的模式
		亚历山大的模式
		致谢 
		参考文献
第7部分 对象用法及对象风格
	第25章  VisualWorks Smalltalk之ValueModel框架的理解及使用
		介绍
		什么是ValuaModel
			使用ValuaModel泛化对象的性质
			使用ValuaModel共享值
		如何使用ValuaModel
			使用onChangeSend:to:登记对值的兴趣
			使用ValuaModel链代替onChangeSend:to:
			封装value/value:的发送者
			确保共享同一个值的所有对象使用相同的ValuaModel
			维护一致的ValuaModel值类型
		ValuaModel的类型
			使用ValuaHolder存放孤立对象
			使用AspectAdapter存放对象的性质
			使用BufferedValueHolder延迟新值的提交
			使用RangeAdaptor分流数的区间
			使用IndexedAdaptor存放集合中的某个索引
			使用SlotAdaptor存放某个实例变量
			使用PluggableAdaptor存放对象的某个部分
			使用TypeConverter来回转换值的类型
			使用ScrollValueHolder存放n维空间中的点
			使用SelectionInList存放列表及列表选中项
		参考文献
	第26章  客户指定的Self
		摘要
		意图
		动机
		适用性
		结构
		动态
		结果 
		实现
		示例代码
		使用
		相关模式
		参考文献
	第27章  通过自封装实现的可复用性
		简介
		模式语言
		结论
第8部分 事件和事件处理程序
	第28章  分离组合和处理的模式
		上下文
		人造卫星数据处理
		实例语法（C++）
		致谢
		参考文献
	第29章  Reactor：并发事件信号分离与事件处理程序派发的对象行为性模式
		意图
		动机
		适用性
		结构
		参与方
		协作 
		结果 
		实现
		示例代码
			Client_Acceper类
			Logging_IO类
			日志服务器主函数
		已知的用途
		各相关模式
		致谢
		参考文献
	第30章  事件模式
		事件为中心的体系结构
		事件对象类
		事件的详细分类
		面向对象状态机
		请参阅
		参考文献
附录 请求屏幕修改

卷2
★
作者：James O.Coplien、Douglas C. Schmidt、Norman L.Kerth

第1部分 特定语言的模式与惯用法
	第1章  局部所有权：管理 C++中的动态对象
		1.1 摘要
		1.2 介绍
		1.3 术语
		1.4 综述
			1.4.1 局部所有权
			1.4.2 动态对象之外的资源
		1.5 模式1：创建者是惟一所有者
		1.6 模式1.1：函数是惟一所有者
		1.7 模式1.2：对象是惟一所有者
		1.8 模式1.3：类作为惟一所有者
		1.9 模式2：所有者序列 
		1.10 模式3：共享所有权
		1.11 相关主题
		1.12 致谢
		1.13 参考文献
	第2章  延迟优化：高效Smalltalk编程模式
		2.1 性能评估
		2.2 延迟优化
		2.3 性能标准
		2.4 阈值开关
		2.5 性能度量
		2.6 热点
		2.7 实验
		2.8 可缓存的表达式
		2.9 缓存临时变量
		2.10 缓存参数
		2.11 缓存状态变量
		2.12 简化 
		2.13 削减临时对象
		2.14 对象转换
		2.15 假设一定大小的集合
		2.16 连接流
		2.17 参考文献
	第3章  将Smalltalk代码划分成ENVY/Developer组件
		3.1 综述
		3.2 模式语言：ENVY划分
		3.3 分层和分区域架构
			3.3.1 独立层
			3.3.2 独立区
		3.4 应用中的层
		3.5 子应用中的区域
		3.6 两个应用
		3.7 没有子应用
		3.8 致谢
		3.9 参考文献
第2部分 通用模式
	第4章  命令处理器
		参考文献
	第5章  观察者模式的实现模式
		5.1 介绍
		5.2 模式：目标变化的传递
		5.3 模式：每个变化请求一条消息
		5.4 模式：每个受影响对象一条消息
		5.5 反面模式：每个变化请求优化消息
		5.6 模式：消息包
		5.7 模式：观察者更新消息
		5.8 模式：更新观察者
		5.9 参考文献
	第6章  封装类树模式
		6.1 介绍
		6.2 模式背景
		6.3 框架示例
		6.4 类树封装
		6.5 规范支持
		6.6 与其他模式的关系 
		6.7 模式格式
		6.8 小结与结论
		6.9 致谢
		6.10 参考文献
	第7章  代理设计模式回顾
		7.1 摘要
		7.2 例子
		7.3 一般模式
		7.4 上下文
		7.5 问题
		7.6 解决方案
		7.7 结构
		7.8 动态
		7.9 实现
		7.10 第二层模式
			7.10.1 远程代理
			7.10.2 保护代理
			7.10.3 缓存代理
			7.10.4 同步代理
			7.10.5 计数代理
			7.10.6 虚拟代理
			7.10.7 防火墙代理
		7.11 组合代理变形
		7.12 示例的解决方案
		7.13 相关工作
		7.14 精选的已知应用
		7.15 结论
		7.16 同时参阅
		7.17 开放问题
		7.18 致谢
		7.19 参考文献
	第8章  MOODS：状态面向对象设计的模块
		8.1 设计决策树
		8.2 设计决策1：要简化复杂行为，使用分解
		8.3 设计决策2：对于有情绪的对象，使用状态类
			8.3.1 如何跟踪对象变化的情绪
			8.3.2 如何支持情绪敏感的方法选择
		8.4 设计决策3：当事件产生情绪时，使用状态机
		8.5 设计决策4：对于状态机，使用转移方法
		8.6 设计决策5：当状态是条件时，使用判断状态类
		8.7 设计决策6：当状态是关联时，使用状态对象
		8.8 设计决策7：对于复杂情绪，使用情绪转换器
		8.9 设计决策8：当有很多情绪时，使用情绪分类器
		8.10 例子中用到的C++源代码
			8.10.1 使用状态对象的分配器
			8.10.2 分配器作为带有判断状态类的转换器
			8.10.3 分配器作为情绪分类器
		8.11 参考文献
	第9章  购物者
		9.1 介绍
		9.2 动机
		9.3 结构
		9.4 适用性
		9.5 参与者
		9.6 协作
		9.7 结论
		9.8 实现
			9.8.1 遍历提供者组
			9.8.2 获取和选择提供者中的被请求项目
		9.9 示例代码
		9.10 相关模式
		9.11 致谢
		9.12 参考文献
第3部分 专用模式
	第10章  可分离检查器/可删除cout：用于设计透明分层服务的一种结构模式
		10.1 摘要
		10.2 动机
		10.3 解决方案
		10.4 适用性
		10.5 静态和动态结构
			10.5.1 类、责任和协作者
			10.5.2 动态协作者
		10.6 结论
		10.7 实现
		10.8 示例代码与使用
		10.9 已知应用
		10.10 相关模式
			10.10.1 装饰者
			10.10.2 访问者
			10.10.3 独身者
		10.11 注释
		10.12 变形
		10.13 致谢
		10.14 参考文献
	第11章  面向对象超媒体应用的设计模式
		11.1 摘要
		11.2 介绍
		11.3 一种面向对象的超媒体框架
		11.4 NavigationStratety
		11.5 NavigationObserver
		11.6 结束语
		11.7 致谢
		11.8 参考文献
	第12章  组织复用：用于与分布式团队处理卫星遥测的模式
		12.1 摘要
		12.2 介绍
		12.3 项目组织
		12.4 模式
			12.4.1 模式1：松散接口
			12.4.2 模式2：解释器/构造器
			12.4.3 模式3：工厂等级
			12.4.4 模式4：处理器
		12.5 结论
		12.6 文中引用的模式
			12.6.1 来自“生成开发过程模式语言”
			12.6.2 来自“设计模式”的模式
			12.6.3 来自“早期开发模式”的模式
		12.7 致谢
		12.8 参考文献
	第13章  备份模式：在面向对象的软件中设计冗余
		13.1 摘要
		13.2 目的
		13.3 别名
		13.4 问题与上下文
		13.5 难点
		13.6 难点解决方案
		13.7 动机
		13.8 适用性
		13.9 结构
		13.10 参与者
		13.11 协作
		13.12 结论
		13.13 实现
			13.13.1 创建候选
			13.13.2 候选的独立性
			13.13.3 保持当前候选的状态
			13.13.4 确定正确的功能
			13.13.5 撤销主模式块执行产生的影响 
			13.13.6 验收测试
		13.14 示例代码与应用
		13.15 已知应用
		13.16 相关模式
		13.17 小结
		13.18 致谢
		13.19 参考文献
	第14章  交叉中断：对象-RDBMS集成的模式语言（静态模式）
		14.1 摘要
		14.2 介绍
		14.3 静态模式（关系方面）
			14.3.1 表的设计时间
			14.3.2 将对象描述成表
			14.3.3 将对象关系描述成表
			14.3.4 在关系数据库中描述继承关系 
			14.3.5 在关系数据库中描述集合
			14.3.6 对象标识符
			14.3.7 外键引用 
		14.4 静态模式（对象方面）
			外键与直接引用 
		14.5 参考文献
	第15章  事务和帐户
		15.1 摘要
		15.2 介绍
		15.3 商业事务
		15.4 将事务处理与存档分开
		15.5 商业帐户
		15.6 组合事务
		15.7 调整事务
		15.8 月底结算
		15.9 显式业务规则
		15.10 持续处理
		15.11 致谢 
		15.12 参考文献
第4部分 架构模式
	第16章  软件架构的一些模式
		16.1 摘要
		16.2 软件架构的设计模式
		16.3 架构模式
			16.3.1 流水线
			16.3.2 数据抽象
			16.3.3 通信进程
			16.3.4 隐式调用 
			16.3.5 仓库
			16.3.6 解释器
			16.3.7 主程序和子例程
			16.3.8 分层架构
		16.4 致谢
		16.5 参考文献
	第17章  反射
		17.1 介绍
		17.2 例子
		17.3 结构
		17.4 动态
		17.5 实现
		17.6 示例解析
		17.7 变形
		17.8 已和应用
		17.9 结论
		17.10 同时参阅
		17.11 参考文献
	第18章  进化、架构和变形
		18.1 摘要
		18.2 介绍
		18.3 软件构造 
		18.4 灵活基础
		18.5 变形
		18.6 小结
		18.7 致谢
		18.8 参考文献
第5部分 过程和组织
	第19章  软件设计中优先级问题
		19.1 介绍
		19.2 模式1：保护变量
			模式1.1：持久存取器
		19.3 模式2：技能混合
			19.3.1 模式2.1：三个子系统
			19.3.2 模式2.2：通用UI，专用UI
			19.3.3 模式2.3：通用和专用 
		19.4 模式3：应用边界
			19.4.1 模式3.1：分解确认
			19.4.2 模式3.2：内部编辑
		19.5 模式4：每团队的子类
			模式4.1：模型层次
		19.6 模式5：正面
			模式5.1：域截取
		19.7 对这种格式的评价
		19.8 参考文献
	第20章  决策延迟和捕捉模式语言
		20.1 介绍
		20.2 综述
		20.3 模式1：基于决策的模型
		20.4 模式2：适当的现存模型
		20.5 模式3：可执行模型 
		20.6 模式4：向上的可溯性
		20.7 模式5：向下变化
		20.8 致谢
		20.9 参考文献
	第21章  团队的组织模式
		21.1 模式语言：团队设计
		21.2 模式1：目标一致
		21.3 模式2：成员关系的多样性
		21.4 模式3：团结起来
		21.5 模式4：团队确认
		21.6 参考文献
	第22章  责任的组织结构
		22.1 介绍
		22.2 组织结构的问题
		22.3 模式综述
		22.4 模型符号
		22.5 模式1：团体
		22.6 模式2：组织的递归结构
		22.7 模式3：子类型中带有约束的抽象模型
		22.8 模式4：多层关联
		22.9 模式5：组织结构类型的关系
		22.10 模式6：关联具体化
		22.11 模式7：类型关系
		22.12 模式8：责任抽象
		22.13 模式9：责任知识等级
		22.14 模式10：将经常变化的结构放到实例中
		22.15 模式11：知识等级
		22.16 致谢
		22.17 参考文献
	第23章  插曲：一种竞争开发模式语言
		23.1 产品
			23.1.1 产品的最初状态
			23.1.2 市场调整
			23.1.3 隐含需求
		23.2 开发
			23.2.1 工作序列
			23.2.2 工作组
			23.2.3 工作序列报表
			23.2.4 比较工作
			23.2.5 完成天数
			23.2.6 开发插曲
			23.2.7 不正规的劳动计划
			23.2.8 工作划分 
			23.2.9 再提交会议
		23.3 编程
			23.3.1 需求调查
			23.3.2 技术备忘录
			23.3.3 参考数据
			23.3.4 编程插曲
		23.4 补充模式
		23.5 参考文献
第6部分 展示
	第24章  课堂教学模式
		24.1 摘要
		24.2 介绍
		24.3 本章要讨论的模式
		24.4 模式1：重复课程开发
		24.5 模式2：鸡和蛋
		24.6 模式3：新旧混合
		24.7 模式4：陷阱诊断和预防
		24.8 模式5：模块的故事
		24.9 模式6：七个部分
		24.10 模式7：显而易见的清单
		24.11 模式8：熟悉的例子
		24.12 模式9：使用一周的例子
		24.13 模式10：参考例子
		24.14 模式11：生动的类比
		24.15 模式12：仿真游戏
		24.16 模式13：测试游戏
		24.17 模式14：活动后听取汇报
		24.18 模式语言
		24.19 参考文献
	第25章  演示准备：用于准备软件演示的一种模式语言
		25.1 介绍
		25.2 模式1：元素识别
		25.3 模式2：催化场景
		25.4 模式3：易变的代码
		25.5 模式4：原型语言
		25.6 模式5：轻量级用户界面
		25.7 模式6：明智的争论
		25.8 模式7：存档场景
		25.9 结论
		25.10 参考文献
	第26章  基于文章的网站使用的一种模式语言
		26.1 A：文本格式模式
			A.1：自然文本流**
			A.2：自然文本超链接*
			A.3：自然文本目录
		26.2 B：文章格式模式
			B.1：生动的文章 
			B.2：低深度文档树
			B.3：文档格式一致性
			B.4：基于小节的文章 
			B.5：短小的、单页文章
			B.6：一致的页眉和页脚
			B.7：介绍性小节
			B.8：介绍性图片
			B.9：朝向顶部的活动
			B.10：文档内容列表
			B.11：引用项
			B.12：后一个和前一个引用链接
		26.3 C：元信息模式
			C.1：揭露内幕
			C.2：作者小传
			C.3：对应日期
			C.4：工作表文档
			C.5：可下载CGI
			C.6：联系作者
			C.7：直接文档讨论
			C.8：新文档通知
			C.9：变化的文档通知
			C.10：临时保留文档版本
		26.4 D：调制解调器速度慢的模式
			D.1：14.4Kbps测试
			D.2：少量图片
			D.3：隔行扫描的图片
			D.4：低位深度图片
		26.5 E：其他模式
			E.1：链接类型判别
			E.2：主页版本
		26.6 致谢
		26.7 参考Web站点
第7部分 并行编程/分布式系统
	第27章  半同步/半异步：高效的、结构完善的并行I/O使用的一种架构模式
		27.1 致谢
		27.2 参考文献
	第28章  资源交换器：低开销并行资源管理的一种行为模式
		28.1 摘要
		28.2 解决方案
		28.3 应用
		28.4 结构
			28.4.1 类、责任和协作者
			28.4.2 动态协作 
		28.5 结论
		28.6 实现
		28.7 示例代码和使用
		28.8 已知应用
		28.9 相关模式
		28.10 变形
		28.11 致谢
		28.12 参考文献
	第29章  客户――分配器――服务器设计模式
		参考文献
	第30章  主动对象：并行编程使用的一种对象行为模式
		30.1 摘要
			30.1.1 目的
			30.1.2 别名
			30.1.3 动机
			30.1.4 适用性
			30.1.5 结构及参与者
			30.1.6 协作者
			30.1.7 结论
			30.1.8 实现
			30.1.9 示例代码
			30.1.10 已知应用
			30.1.11 相关模式
		30.2 参考文献
	第31章  为并行程序选择锁定设计
		31.1 摘要
		31.2 例子算法
		31.3 上下文概述
		31.4 难点
		31.5 锁定设计模式索引
			31.5.1 模式关系 
			31.5.2 解决难点
			31.5.3 缺陷表
		31.6 锁定设计模式
			31.6.1 串行程序
			31.6.2 代码锁定
			31.6.3 数据锁定
			31.6.4 数据所有权
			31.6.5 并行快捷路径
			31.6.6 读者/写者锁定
			31.6.7 分层锁定
			31.6.8 分配器缓存
			31.6.9 临界区熔合
			31.6.10 临界区划分 
		31.7 致谢
		31.8 参考文献
第8部分 反应性系统
	第32章  反应性系统中面向对象的设计模式
		32.1 介绍
			32.1.1 仿真的重要性
			32.1.2 BASEstar Open
		32.2 模式1：面向对象的仿真，事件驱动的现实
		32.3 模式2：具体化事件
		32.4 模式3：具体化系统状态
		32.5 模式4：远程控制对象
		32.6 模式5：事件驱动
		32.7 总结
		32.8 致谢
		32.9 参考文献
	第33章  容错电信系统模式
		33.1 介绍
		33.2 术语
		33.3 模式：人工干预最小化
		33.4 模式：人最小解
		33.5 模式：无升级消息的5分钟
		33.6 模式：瞬时抑制
		33.7 模式：漏桶计数器
		33.8 模式：SICO首要并总是
		33.9 模式：尝试所有的硬件联合体
		33.10 模式：欺骗一次
		33.11 致谢
		33.12 参考文献
	第34章  复用队列改善交互应用的响应性
		34.1 摘要
		34.2 介绍
		34.3 模式1：事件队列
		34.4 模式2：组合兼容事件
		34.5 模式3：处理人为事件
		34.6 模式4：将执行和输出分离
		34.7 结论
		34.8 致谢
		34.9 参考文献
	第35章  用于改善反应性系统功能的模式语言
		35.1 摘要 
		35.2 介绍
		35.3 问题域历史
		35.4 模式语言
		35.5 容量模式
			35.5.1 模式1：容量瓶颈
			35.5.2 模式2：处理容量
			35.5.3 模式3：优化高运行状况
			35.5.4 模式4：分散负载
			35.5.5 模式5：完成处理过程中的工作负载
			35.5.6 模式6：在失效前更新工作负载
			35.5.7 模式7：匹配正在处理的工作负载与新工作负载 
			35.5.8 模式8：分担负载
			35.5.8 模式9：在外设分散工作负载
			35.5.10 模式10：信用漏桶
		35.6 致谢
		35.7 参考文献

卷3
★☆
作者：Robert C.Martin、Dirk Riehle、Frank Buschmann

前言
	致谢
第1部分 通用目的设计模式
	第1章  空对象
		意图
		别名
		动机
		关键
		适用性
		结构
		参与者
		合作
		结果
		实现
		样例代码
		已知的用法 
		相关模式
		致谢
		参考文献
	第2章  管理者		
		场景
		问题
		解决方案
		结构
		动态性
		实现
		变体 
		类方法
		已知的用法
		结果
		参见
		致谢
		参考文献
	第3章  产品交易商
		意图
		别名
		动机
		适用性
		结构
		参与者
		合作
		结果
		实现
		样例代码
		已知的用法
		相关模式
		致谢
		参考文献
	第4章  类型对象
		目的
		别名
		动机
		关键
		适用性
		结构
		参与者
		合作
		结果
		实现
		样例代码
		已知的用法
		相关模式
		致谢
		参考文献
	第5章  主办者――选择器
		目的
		别名
		场景
		问题
		解决方案
		结构
		动态性
		实现
		范例分解
		变体
		已知的用法 
		结果
		参见
		致谢
		参考文献
	第6章  扩展对象
		目的
		别名
		动机
		适用性
		结构
		参与者
		合作
		结果
		实现
		样例代码
		已知的用法 
		相关模式
		致谢
		参考文献
第2部分 设计模式的变体
	第7章  非循环访问者
		目的
		动机
		解决方案
		适用性
		参与者
		合作
		结果 
		样例代码
		已知的用法
		注意
		致谢
		参考文献
	第8章  默认和外部访问者
		默认Visitor
			目的
			动机
			适用性
			结构
			参与者
			合作
			结果
			实现
			已知的用法 
			相关模式
		外部VISITOR
			目的
			动机
			适用性
			结构
			参与者
			合作
			结论		
			实现
			已知的用法 
			相关模式
		选择Visitor模式变体
		结论
		致谢
		参考文献
	第9章  状态模式
		模式总结
		STATE OBJECT
			问题
			作用力
			解决方案
		STATE MEMBER
			问题
			作用力
			解决方案
		PURE STATE
			问题
			作用力
			解决方案
		EXPOSED STATE
			问题
			作用力
			解决方案
		状态驱动的转换
			问题
			解决方案
		拥有者驱动的转换
			问题
			作用力
			解决方案
		默认状态	
			问题
			作用力
			解决方案
		致谢
		参考文献
第3部分 架构模式
	第10章  递归控制
		递归控制模式
		控制
		设计原则
		从函数中分离控制
		从控制机制中分离控制策略
		递归控制模式
		协作 
		适用性
		参与者
		结果 
		与更基本械的关系 
		实现
		总结
		致谢
		参考文献
	第11章  官僚
		BUREAUCRACY模式
		目的
		动机
		适用性
		结构
		角色
		合作
		结果
		实现
		样例代码
		已知的用法
		概念和技术
		角色图表
		角色关系矩阵
		矩阵说明 
		方法评价
		结论
		致谢
		参考文献
第4部分 分布模式
	第12章  接受器和连接器
		ACCEPTOR和CONNECTOR模式
		目的
		别名 
		动机
		常见的错误陷阱
		解决方案
		适用性
		结构和参与者
		合作
		结果
		实现
		样例代码
		Peer组件
		Gateway组件
		已知的用法
		相关模式
		总结评论
		致谢
		参考文献
		附录
	第13章  保镖
		目的
		动机
		适用性
		结构
		参与者
		合作
		结果
		变体
		实现
		参与者实现
		相关模式
		已知的用法
		致谢
		参考文献
	第14章  异步完成标识
		目的
		别名
		动机
		常见错误陷阱
		解决方案
		适用性
		结构和参与者
		合作
		结论
		实现
		样例代码
		变化 
		已知的用法 
		相关的模式
		致谢
		参考文献
	第15章  对象恢复
		目的
		别名
		动机
		问题
		作用力
		适用性
		结构和参与者
		合作
		结果 
		实现
		样例代码 
		策略实现
		协作画图
		已知的用法 
		相关模式
		致谢
		参考文献
	第16章  记录诊断消息的模式
		DIAGNOSTIC LOGGER
			问题
			场景
			作用力
			解决方案
			结果场景
			原理
			变化 
			相关模式
		DIAGNOSTIC CONTEXTS
			问题
			场景
			作用力
			解决方案
			结果环境
			变化 
			原理
		TYPED DIAGNOSTICS
			问题
			场景
			作用力
			解决方案
			结果场景
			原理
			致谢
第5部分 持续模式
	第17章  串行化器
		目的
		别名
		动机
		适用性
		结构
		参与者
		合作
		结果
		实现
		样例代码
		已知的用法 
		相关模式
		致谢
		参考文献
	第18章  访问关系数据库
		数据库访问层的相关工作
		一般作用力
		运行范例
		模式语言图
		符号约定
		关系数据库访问层模式
			场景
			问题
			作用力
			解决方案
			结构
			参与者
			动态行为
			结果
			实现
			变体 
			相关模式
			已知的用法
		分层视图模式
			问题
			作用力
			解决方案
			结构
			范例解析
			结果
			实现
			变体
			相关模式
			已和的用法
		物理视图模式
			场景
			问题
			作用力
			解决方案
			结构
			范例解析
			结果 
			实现
			变体 
			相关模式
		QUERY BROKER模式
			场景
			问题
			作用力
			解决方案
			结构
			动态行为
			结果 
			实现
			变体 
			相关模式
			已知的用法
		致谢
		参考文献
第6部分 用户接口模式
	第19章  开发窗体样式窗口的模式语言
		Subform
			问题
			场景
			作用力
			解决方案
			结果场景
		Alternative Subform
			问题
			场景环境
			作用力
			解决方案
			结果场景
		Subform Selection
			问题
			场景
			作用力
			解决方案
			结果场景
		Subform Match
			问题
			场景
			作用力
			解决方案
			结果场景
			相关场景
		Subform Mismatch
			问题
			场景
			作用力
			解决方案
			结果场景
			总结
		致谢
		参考文献
第7部分 编程模式
	第20章  双重检查锁
		目的
		别名
		动机
		适用性
		结构与参与者
		合作
		结果
		实现和样例代码 
		评价
		性能测试
		变体
		已知用法
		相关模式
		致谢 
		参考文献
	第21章  外部多态性
		目的
		动机
		适用性
		结构和参与者
		合作
		结果 
		实现
		样例代码
		变体 
		已知用法 
		相关模式
		致谢
		参考文献
第8部分 特定领域模式
	第22章  关联对象的商业模式
		模式语言总结
		关联对象模式
		问题
		场景
		作用力
		解决方案
		已知用法 
		客户联系模式
		问题
		场景
		作用力
		解决方案
		相关模式和已知用法
		3级订单模式
		问题
		场景
		作用力
		解决方案
		已知用法 
		结论
		致谢
		参考文献
	第23章  运输系统点和路线的模式语言
		公共运输领域
		PLOTS和它的模式形式
		POINT模式
			目的
			别名
			问题
			结构
			参与者
			模式交互
			场景
			作用力与设计原理
			相似的模式和应用程序
		Route模式
			目的
			别名
			问题
			结构
			参与者
			模式交互
			场景
			作用力与设计原理
			相似的模式和应用程序
		致谢
		参考文献
	第24章  火警系统的点和偏差模式语言
		系统概述
		DEVIATION 模式
			场景
			问题
			作用力
			解决方案
			相关模式
		POINT 模式
			场景
			问题
			作用力
			解决方案
			相关模式
		POOL 模式
			场景
			问题
			作用力
			解决方案
		Lazy State 模式
			场景
			问题
			作用力
			解决方案
		Periodic Object 模式
			场景
			问题
			作用力
			解决方案
			相关模式
		DATA PUMP 模式
			场景
			问题
			作用力
			解决方案
		总结评论
		致谢
		参考文献
第9部分：处理模式
	第25章  自私类
		SELFISH CLASS
			场景
			问题
			作用力
			解决方案
			相关模式
		WOERKS OUT OF THE BOX
			别名			
			问题
			场景
			作用力
			解决方案
			结果
			相关模式
		LOW SURFACE-TO-VOLUME RATIO
			别名
			场景
			问题
			作用力
			解决方案
			相关模式
		GENTLE LEARNING CURVE
			别名
			问题
			作用力
			解决方案
		PROGRAMMING-BY-DIFFERENCE
			别名
			问题
			作用力
			解决方案
			相关模式
		FIRST ONE'S FREE
			别名
			问题
			作用力
			解决方案
		WINNING TEAM
			别名
			问题
			作用力
			解决方案
		结论
		致谢
		参考文献
	第26章  改进框架的模式
		3个范例
			问题
			作用力
			解决方案
			原理
			实现
			相关模式
		白盒框架
			问题
			作用力
			解决方案
			原理
			实现
			相关模式
		组件库
			问题
			作用力
			解决方案
			原理
			实现
			相关模式
		热点
			问题
			作用力
			解决方案
			原理
			实现
			相关模式
		可插入对象
			问题
			作用力
			解决方案
			原理
			实现
			相关模式
		细粒度对象
			问题
			作用力
			解决方案
			原理
			实现
			相关模式
		墨盒框架
			问题
			作用力
			解决方案
			原理
			实现
			相关模式
		VISUAL BUILDER
			问题
			作用力
			解决方案
			原理
			实现
			相关模式
		语言工具
			问题
			作用力
			解决方案
			原理
			实现
		致谢
		参考文献
	第27章  团队设计模式
		多竞争设计模式
			问题
			解决方案
			涉及到的角色
			作用力
			已知用法 
			相关模式
		决策文档模式
			问题
			解决方案
			涉及到的角色
			作用力
			已知用法 
			相关模式
		创建者――评审者模式
			问题
			解决方案
			涉及角色
			作用力
			已知用法 
			相关模式
		大师――熟练工模式
			问题
			解决方案
			涉及角色
			作用力
			已知用法 
			相关模式
		特别修改模式
			问题
			解决方案
			涉及角色
			作用力
			已知用法 
			相关模式
		致谢
		参考文献
	第28章  系统测试模式
		公共场景
		公共作用力
		测试组织
		测试员比测试案例更重要
			问题
			作用力
			解决方案
			结果场景
			原理
		设计者是我们的朋友
			问题
			解决方案
			结果场景
			原理
			相关模式
		尽早参加
			问题
			作用力
			解决方案
			结果场景
			原理
			相关模式
		测试时间
			别名
			问题
			场景
			作用力
			解决方案
			结果场景
			原理
			相关模式
		花费时间
			问题
			场景
			作用力
			解决方案
			结果场景
			原理
		测试效率
		“未改变的”接口
			问题
			场景
			作用力
			解决方案
			结果场景
			原理
		歧义文档
			问题
			场景
			作用力
			解决方案
			结果场景
			原理
			相关模式
		使用旧问题报告 
			问题
			场景			
			解决方案
			结果场景
			原理
		问题区
			问题
			场景 
			解决方案
			结果场景
			原理
		测试策略
		忙系统
			问题
			场景
			解决方案
			结果场景
			原理
			相关模式
		不要信任模拟
			问题
			场景
			作用力
			解决方案
			结果场景
			原理
			相关模式
		终端用户观点
			问题
			作用力
			解决方案
			结果场景
			原理
		与众不同的时间选择
			问题
			解决方案
			结果场景
			原理
		多处理器
			问题
			解决方案
			结果场景
			原理
		Scratch'sn Sniff
			别名
			问题
			场景
			解决方案
			结果场景
			原理
			相关模式
		奇异的行为
			问题
			场景
			解决方案
			结果场景
			原理
		杀手测试
			问题
			场景
			解决方案
			结果场景
			原理
		问题分解
		记录问题
			问题
			场景
			作用力
			解决方案
			结果场景
			原理
			相关模式
		收养问题
			问题
			场景
			作用力
			解决方案
			结果场景
			原理
		宠物麻烦
			问题
			场景
			解决方案
			结果场景
			原理
		已知的应用
		致谢
		参考文献
第10部分 模式中的模式
	第29章  编写模式的模式语言
		这种模式语言的历史
		模式语言概要
		如何使用这些模式
		约定
		A 场景设置模式
			A.1 Pattern模式
				场景
				问题
				作用力
				解决方案
			A.2 模式语言模式
				场景
				问题
				作用力
				解决方案
		B 模式结构模式
			B.1 必要元素存在模式
				别名
				问题
				场景
				作用力
				解决方案
				原理
			B.2 有用时可选元素模式
				问题
				场景
				作用力
				解决方案
			B.3 可见作用力模式
				问题
				场景
				作用力
				解决方案
			B.4 一遍可读模式
				问题
				场景
				作用力
				解决方案
				原理
				相关模式
			B.5 可跳读部分模式
				场景
				问题
				作用力
				解决方案
				原理
				结果场景
				相关模式
			B.6 可找到部分模式
				场景
				问题
				作用力
				解决方案
				原理
				相关模式
		C 模式命名和引用模式
			C.1 与其他模式之间的关系
				问题
				作用力
				解决方案
				原理
			C.2 模式可阅读引用的模式
				场景
				问题
				作用力
				解决方案
				原理
				相关模式
				C.2.1 （外部）简短模式的模式
					场景
					问题
					作用力
					解决方案
					原理
					相关模式
			C.3 能想起模式名称的模式
				别名
				场景
				问题
				作用力
				解决方案
				原理
				相关模式
				C.3.1 名词短语名称模式
					别名
					场景
					问题
					作用力
					解决方案
					原理
					相关模式
				C.3.2 有意义的隐喻名称模式						
					场景
					问题
					作用力
					解决方案
					原理
					相关模式
			C.4 目标目录的模式
				场景
				问题
				作用力
				解决方案
				结果场景
				原理
				相关模式
		D 使模式可以理解的模式
			D.1 明确目标听众人的模式
				别名
				问题
				场景
				作用力
				解决方案
				原理
				相关模式
			D.2 术语适用于听众的模式
				问题
				场景
				作用力
				解决方案
				结果场景
				原理
			D.3 理解符号的模式
				场景
				问题
				作用力
				解决方案
				原理
				相关模式
			D.4 样例代码模式
				别名
				场景
				问题
				作用力
				解决方案
				原理
				相关模式
				D.4.1 样本代码为奖励的模式
					别名
					问题
					场景
					作用力
					解决方案
					原理
					样例代码
		E 模式语言结构化模式
			E.1 模式语言总结模式
				问题
				场景
				作用力
				解决方案
				原理
				E.1.1 问题/解决方案总结模式
					场景
					问题
					作用力
					解决方案
					原理
			E.2 突出常见问题的模式
				场景
				问题
				作用力
				解决方案
				相关模式
				原理
			E.3 运行范例模式
				问题
				场景
				作用力
				解决方案
				原理
			E.4 （与众不同的）标题传输结构模式
				问题
				场景
				作用力
				解决方案
				原理
				相关模式
			E.5 术语表模式
				场景
				作用力
				解决方案
				原理
				总结评论
		致谢
		参考文献
		附录 问题/解决方案总结
关于作者

卷4
★☆
作者：Neil Harrison、Brian Foote、Hans Rohnert

前言
	序言
		致谢
	前言一
		参考文献
	前言二
		参考文献
第1部分 基本面向对象模式
	第1章  抽象类
		分类 
		目标
		也称为
		动机
		关键
		适用性
		结构
		参与者
		协作
		结果
		实现
		示例代码
		已知应用
		相关模式
		参考文献
	第2章  角色对象
		目标
		动机
		适用性
		结构
		参与者
		协作
		结果
		实现
		示例代码
		已知应用
		相关模式
		致谢
		参考文献
	第3章  本质
		环境
		问题
		强制
		解决方案
		结果
		实现
		已知应用
		相关模式
		致谢
		参考文献
	第4章  对象递归
		分类 
		目标
		也称为
		动机
		关键
		适用性
		结构
		参与者
		协作 
		结果
		实现
		示例代码
		已知应用
		相关模式
		致谢
		参考文献
	第5章  基于原型的对象系统
		目标
		也称为
		动机
		适用性
		结构
		参与者
		协作 
		结果
		实现
		示例代码
		已知应用
		相关模式
		致谢
		参考文献
	第6章  基本关系模式
		强制
		例子
		格式 
		Relationship As Attribute
			例子
			评论
			已知应用
			参看
		Relationship Object
			也称为
			例子
			评论
			已知应用
			参看
		Collection Object
			例子
			评论
			已知应用
			参看
		Active Value
			也称为
			例子
			评论
			已知应用
			参看
		Mutual Friends
			也称为
			例子
			评论
			已知应用
			参看
		致谢
		参考文献
第2部分 面向对象基础结构
	第7章  抽象会话：一种对象结构模式
		目标
		也称为
		动机
		例子：网络通信
			解决方案
			适用性
			结构和参与者
			协作
			结果
			实现
		示例代码：通信协议
		已知应用
		相关模式
		致谢
		参考文献
	第8章  对象同步器
		目标
		也称为
		例子
		问题
		强制
		解决方案
		适用性
		结构和参与者
		协作
		结果
		实现
		示例代码
		已知应用
		相关模式
		致谢
		参考文献
	第9章  主动反应
		目标
		环境和强制
		传统并发模型的常见陷阱和缺陷
		解决方案：通过主动式操作实现并发性
		适用性
		结构和参与者
		协作 
		结果
		实现
		示例代码
		已知应用
		相关模式
		结论
		致谢
		参考文献
		附录A：替代实现
			A.1 多个同步线程
			A.2 单线程反应式事件分配
第3部分 编程策略
	第10章  C++语言模式
		模式目标
		模式语言结构
		空间行进
		模式
		Handle/Body
			环境
			问题
			强制
			解决方案
			例子
			结果环境
			基本原理
		Counted Body
			也称为
			问题
			强制
			解决方案
			例子
			结果环境
			基本原理
		Detached Counted Body
			环境
			问题
			强制
			解决方案
			例子
			结果环境
		Handle/Body Hierarchy
			也称为
			环境
			问题
			强制
			解决方案
			例子
			结果环境
			基本原理
		Envelope/Letter
			环境
			问题
			强制
			解决方案
			例子
			结果环境
			基本原理
		Virtual Constructor
			环境
			问题
			强制
			解决方案
			例子
			结果环境
		Concrete Data Type
			环境
			问题
			强制
			解决方案
			结果环境
		Algebraic Hierarchy
			环境
			问题
			强制
			解决方案
			例子
			结果环境
		Homogeneous Addition
			环境
			问题
			强制
			解决方案
			例子
			结果环境
		Promotion and Add
			环境
			问题
			强制
			解决方案			
			结果环境
		Promotion Ladder
			环境
			问题
			强制
			解决方案			
			结果背景
		Non-Hierarchical Addition
			环境
			问题
			强制
			解决方案
			例子
			结果环境
		Type Promotion 
			环境
			问题
			强制
			解决方案
			结果环境
			基本原理
		致谢
		参考文献
	第11章  Smalltalk体系结构模式
		已知应用
		Smalltalk介绍
		模式
		Extensible Attributes 
			环境
			问题
			强制
			解决方案
			基本原理
			结果
			相关模式
		Aritificial Accessors
			环境
			问题
			强制
			解决方案
			基本原理
			结果
			例子
		Generated Accessor
			环境
			问题
			强制
			解决方案
			基本原理
			结果
			代码例子
		Artificial Delegation
			背景
			问题
			强制
			解决方案
			基本原理
			结果
			例子
		Cached Extensibility
			环境
			问题
			强制
			解决方案
			基本原理
			结果
			例子
		Selector Synthesis
			环境
			问题
			强制
			解决方案
			基本原理
			结果
			相关模式
		结论
		致谢
		参考文献
	第12章  存储器维护协会的高级和处理模式：管理有限的存储器模式
		模式形式
		强制
		适用性
		模式
		Think Small
			结果
			已知应用
			参看
		Memory Budget
			结果
			已知应用
			参看
		Memory Overdraft
			结果
			已知应用
			参看
		Make the User Worry
			结果
			已知应用
			参看
		Partial Failure
			也称为
			结果
			已知应用
			参看
		Captain Oates
			也称为
			结果
			已知应用
			参看
		Exhaustion Tests
			也称为
			结果
			已知应用
			参看
		Memory Performance Assessment			
			结果
			已知应用
			参看
		致谢
		参考文献
第4部分 时间
	第13章  时间模式
		模式
		时间属性
			也称为
			环境
			问题
			强制
			解决方案
			结果
			实现
			已知应用
			相关模式
		时间关联
			也称为
			环境
			问题
			强制
			解决方案
			结果
			实现
			已知应用
			相关模式
		快照			
			环境
			问题
			强制
			解决方案
			结果
			实现
			已知应用
			相关模式
		致谢
		参考文献
	第14章  历史模式集合
		相关模式
			Historic Mapping
			Memento
		已知应用
		基本时间概念
			事件
			时间间隔
			持续时间
		模式
		Edition
			环境
			例子
			问题
			强制
			解决方案
			图
			示例代码
			强制的解决方案
			相关模式
			已知应用
		Change Log
			环境
			例子
			问题
			强制
			解决方案
			图
			示例代码
			强制的解决方案
			相关模式
			已知应用
		History On Association
			也称为
			环境
			例子
			问题
			强制
			解决方案
			图
			示例代码
			强制的解决方案
			相关模式
			已知应用
		Posting
			也称为
			环境
			例子
			问题
			强制
			解决方案
			图
			示例代码
			强制的解决方案
			相关模式
			已知应用
		History On Self			
			环境
			例子
			问题
			强制
			解决方案
			图
			示例代码
			强制的解决方案
			相关模式
			已知应用
		Memento Child
			背景
			例子
			问题
			强制
			解决方案
			图
			示例代码
			强制的解决方案			
			已知应用
		History On Tree			
			环境
			例子
			问题
			强制
			解决方案
			图
			示例代码
			强制的解决方案
			相关模式
			已知应用
		结论
		致谢
		参考文献
第5部分 安全性
	第15章  支持应用程序案例性的体系结构模式
		模式
		也称为
		动机
		问题
		强制 
		解决方案
		例子
		结果
		相关模式
		已知应用
		非安全已知应用
		检查点
			也称为
			动机
			问题
			强制 
			解决方案
			例子
			结果
			相关模式
			已知应用
		角色
			也称为
			动机
			问题
			强制 
			解决方案
			例子
			结果
			相关模式
			已知应用
			非安全已知应用
		会话
			也称为
			动机
			问题
			强制 
			解决方案
			例子
			结果
			相关模式
			已知应用
			非安全已知应用
		容错全视图
			也称为
			动机
			问题
			强制 
			解决方案
			例子
			结果
			相关模式
			已知应用
			非安全已知应用
		有限视图
			也称为
			动机
			问题
			强制 
			解决方案
			例子
			结果
			相关模式
			已知应用
			非安全已知应用
		安全访问层
			也称为
			动机
			问题
			强制 
			解决方案
			例子
			结果
			相关模式
			已知应用
		模式整合
			改进带来的问题
			Limited View模式与Full View With Errors模式
			协同工作
		致谢
		参考文献
	第16章  Tropyc：面向对象的加密软件的模式语言
		PayPerclick――电子付款系统
		面向对象的加密软件的模式语言
		模式
			环境
			问题
			适用性
			强制
			解决方案
			结果
			结果环境
			实现
			例子
			已知应用
			相关模式
		信息保密
			环境
			问题
			适用性
			强制
			解决方案
			结果
			结果环境
			实现
			例子
			已知应用
		信息完整性
			环境
			问题
			适用性
			强制
			解决方案
			结果
			结果环境
			实现
			例子
			已知应用
		发送方身份验证
			环境
			问题
			适用性
			强制
			解决方案
			结果
			结果环境
			实现
			例子
			已知应用
		签名
			环境
			问题
			适用性
			强制
			解决方案
			结果
			结果环境
			实现
			例子
			已知应用
		完整性保密
			环境
			问题
			适用性
			强制
			解决方案
			结果
			结果环境
			实现
			例子
			已知应用
		发送方身份验证
			环境
			问题
			适用性
			强制
			解决方案
			结果
			结果环境
			实现
			例子
			已知应用
		签名保密
			环境
			问题
			适用性
			强制
			解决方案
			结果
			结果环境
			实现
			例子
			已知应用
		附言签名
			环境
			问题
			适用性
			强制
			解决方案
			结果
			结果环境			
			例子
			已知应用
		附言签名保密
			环境
			问题
			适用性
			强制
			解决方案
			结果环境
			结果			
			实现
			例子
			已知应用
		部署密码模式语言
		结论
		致谢
		附录：基本密码学模仿
			密码机制
			常见的攻击
			辅助服务
			参考文献
第6部分 面向领域的模式
	第17章  使用查询对象创建报表
		模式
		报表对象
			动机
			问题
			强制
			解决方案
			结果
			相关模式
			已知应用
		查询对象
			动机
			问题
			强制
			解决方案
			例子
			结果
			相关模式
			已知应用
		可组合查询对象
			动机
			问题
			强制
			解决方案
			例子
			结果
			相关模式
		公式对象
			动机
			问题
			强制
			解决方案
			例子
			结果
			相关模式
			已知应用
		约束观察者
			动机
			问题
			强制
			解决方案
			例子
			结果
			相关模式
			已知应用
		结论
		致谢
		参考文献
	第18章  特征抽取：用于信息检索的模式
		环境
		问题
		强制
		解决方案
		设计决策
		结果
		实现要点
		一种方案
		示例代码
		已知应用
		相关模式
		致谢
		参考文献
	第19章  有限状态机模式
		模式总则
		例子
		基础FSM
			环境
			问题
			强制
			解决方案
			结构
			解决的例子
			结果 
			相关模式
		状态驱动的转换
			环境
			问题
			强制
			解决方案
			结构
			解决的例子
			结果 
			相关模式
		接口组织
			环境
			问题
			强制
			解决方案
			结构
			解决的例子
			结果 
			相关模式
		分层的组织
			环境
			问题
			强制
			解决方案
			结构
			解决的例子
			结果 
		Meally
			环境
			问题
			强制
			解决方案			 
			解决的例子
			结果 
			相关模式
		Moore
			环境			 
			强制
			解决方案			
			解决的例子
			结果 
			相关模式
		Hybrid
			环境
			问题
			强制
			解决方案			
			解决的例子			 
			相关模式
		封装状态
			环境
			问题
			强制
			解决方案			
			解决的例子
			相关模式
		动态状态例子化
			环境
			问题
			强制
			解决方案			
			解决的例子
			结果
			相关模式
			已知应用
		致谢
		参考文献
		附录：有限状态机模式总结
第7部分 人机交互模式
	第20章  设计可导航信息空间的模式
		设计高质量超媒体应用程序
		超媒体的设计模式
		可导航环境：基于集合导航
			目标
			问题
			强制
			解决方案
			已知应用
		可导航环境：环境中的节点
			目标
			问题
			强制
			解决方案
			已知应用
		活动参考
			目标
			问题
			强制
			解决方案
			已知应用
		新闻
			目标
			问题
			强制
			解决方案
			已知应用
		路标
			目标
			问题
			强制
			解决方案
			已知应用
		购物篮
			目标
			问题
			强制
			解决方案
			已知应用
		使导航模式增效工作
		参考文献
	第21章  创建可重用的多媒体人工制品
		基本人工制品
		复合人工制品
		多媒体创建和重用模式语言
		胶水
			问题
			先决条件
			后续条件
			解决方案
			适用性
			示例结构
			例子
			结果
			评论
		组件布局
			问题
			先决条件
			后续条件
			解决方案
			适用性
			示例结构
			例子
			相关模式
			结果
			评论
		模板
			问题
			先决条件
			后续条件
			解决方案
			适用性
			创建模板的示例结构
			创建实例的示例结构
			例子
			相关模式
			结果
			评论
		 定义和运行演示
			问题
			先决条件
			后续条件
			解决方案
			适用性
			示例结构
			例子
			相关模式
			结果
			评论
		同步通道
			问题
			先决条件
			后续条件
			解决方案
			适用性			
			例子
			相关模式
			结果
			评论
		结论
		致谢
		参考文献
	第22章  显示维护：一种模式语言
		模式
		显示列表
			结果
			已知应用
			相关模式
		请求更新
			结果
			已知应用
			相关模式
		全局更新
			结果
			已知应用
			相关模式
		画家算法
			结果
			已知应用
			相关模式
		合并请求
			结果
			已知应用
			相关模式
		惰性重绘
			结果
			已知应用
			相关模式
		剪裁请求
			结果
			已知应用
			相关模式
		双缓冲区
			结果
			已知应用
			相关模式
		页面翻转
			结果
			已知应用
			相关模式
		致谢
		参考文献
	第23章  一种输入和输出模式语言：从远程通信中学到的经验
		背景
		已知应用
		语言映射
		模式分类
		模式
		MML
			也称为
			问题
			强制
			解决方案
			结果环境
			例子
			基本原理 
		IO 看门人			
			问题
			环境
			强制
			解决方案
			结果环境			
			基本原理 
		Mind Your Own Business			
			问题
			环境
			强制
			解决方案
			结果环境
			例子 
		IO Triage		
			问题
			环境
			强制
			解决方案
			结果环境
		Timestamp			
			问题			 
			强制
			解决方案
			结果环境
		Who Asked?			
			问题
			环境
			强制
			解决方案
			结果环境
		George Washington Is Still Dead
			也称为
			问题
			环境
			强制
			解决方案
			结果环境
			相关模式
		The bottom Line
			环境
			强制
			解决方案
			结果环境
			相关模式
		Five Minutes of No Escalation Messages			 
			问题
			环境
			强制
			解决方案
			结果环境
			相关模式
		Shut Up and Listen			 
			问题
			环境
			强制
			解决方案
			结果环境
		Pseudo-IO		 
			问题
			环境
			强制
			解决方案
			结果环境
		Beltline Terminal			 
			问题
			环境
			强制
			解决方案
			结果环境
			基本原理
		Audible alarm			 
			问题
			环境
			强制
			解决方案
			结果环境
			基本原理
		Alarm Grid		 
			问题
			环境
			强制
			解决方案
			结果环境
		Office Alarms			 
			问题
			环境
			强制
			解决方案
			结果环境
		Don't Let Them Forget			 
			问题
			环境
			强制
			解决方案
			结果环境
			相关模式
		String A Wire			 
			问题
			环境
			强制
			解决方案
			结果环境
		Raw IO			 
			问题
			环境
			强制
			解决方案
			结果环境
		模式简介
		致谢
		参考文献
第8部分 评审
	第24章  确定支持者：用于程序委员会的组织模式语言
		模式
		确定支持者
			环境
			问题
			强制
			解决方案
			基本原理
			例子
			相关模式
		专家评审论文
			环境
			问题
			强制
			解决方案
			基本原理
			结果环境
		支持者评审论文
			环境
			问题
			强制
			解决方案
			基本原理
			实例
			相关模式
		明确支持
			环境
			问题
			强制
			解决方案
			基本原理
			例子
				环境
				问题
				强制
				解决方案
				基本原理
			例子
			相关模式
		确定缺席的支持者
			背景
			问题
			强制
			解决方案
			基本原理
		支持者先发言
			环境
			问题
			强制
			解决方案
			基本原理
			结果环境
			例子
			相关模式
		关于PC论文的一致意见
			环境
			问题
			强制
			解决方案
			基本原理
		致谢
		参考文献
	第25章  用于作者研讨会的模式语言
		概述
		设置模式
		过程模式
		也称为
		也称为
		也称为
		致谢
		参考文献
		附录：亚历山大模式形式
第9部分 管理软件
	第26章  客户交互模式
		模式
		是关系，而不是销售
			问题
			环境
			强制
			解决方案
			结果环境
			基本原理
			已知应用
			模式来源
		了解客户
			也称为
			问题
			环境
			强制
			解决方案
			结果环境
			基本原理
			已知应用
			模式来源
		建立信任
			也称为
			问题
			背景
			强制
			解决方案
			结果环境
			基本原理
			已知应用
			模式来源
		倾听、倾听、再倾听			 
			问题
			环境
			强制
			解决方案
			结果环境
			基本原理
			已知应用
			模式来源
		迅速答复
			也称为
			问题
			环境
			强制
			解决方案
			结果环境
			基本原理
			已知应用
			模式来源
		客户会议：早出晚归	
			也称为
			问题
			环境
			强制
			解决方案
			结果环境
			基本原理			 
			模式来源
		表现个人的正直			 
			问题
			环境
			强制
			解决方案
			结果环境
			基本原理
			已知应用
			模式来源
		不要反驳			 
			问题
			环境
			强制
			解决方案
			结果环境
			基本原理
			模式作者
		注意边界
			也称为
			问题
			环境
			强制
			解决方案
			结果环境
			基本原理
			已知应用
			模式来源
		注意礼貌			 
			问题
			环境
			强制
			解决方案
			结果环境
			基本原理
			已知应用
			模式来源
		致谢
		参考文献
	第27章  有能力的、有生产力的、满意的：一些用于保护生产人员的组织模式
		关于这些模式
		一种用于认识团队潜力的模式
			生产潜力
			环境
			问题
			强制
			解决方案
			结果环境
			已知问题
			相关模式
		一些用于建立生产潜力的模式
			自举
			背景
			问题
			强制
			解决方案
			结果环境
			已知问题
			相关模式
		面向问题的团队
 			环境
			问题
			强制
			解决方案
			结果环境
			已知问题
			相关模式
		对症下药
 			环境
			问题
			强制
			解决方案
			结果环境
			已知问题
			相关模式
		一些用于维持生产潜力的模式
			脉搏
 			环境
			问题
			强制
			解决方案
			结果环境
			已知问题
			相关模式
		将发布的交付产品
 			环境
			问题
			强制
			解决方案
			结果环境			 
			相关模式
		团队空间
 			环境
			问题
			强制
			解决方案
			结果环境
			已知问题
			相关模式
		一些用于保持生产潜力的模式
			有效移交
 			环境
			问题
			强制
			解决方案
			结果环境
			已知问题
			相关模式
		布置家具
 			环境
			问题
			强制
			解决方案
			结果环境
			已知问题
			相关模式
		致谢
		参考文献
	第28章  SCRUM：用于超生产力软件开发的模式语言
		SCRUM是如何工作的
		模式
		Sprint
			环境
			问题
			强制
			解决方案
			基本原理 
			已知应用
			结果环境
		待办业务
			环境
			问题
			强制
			解决方案 
			结果环境
		SCRUM会议
			环境（源自：待办业务）
			问题
			强制
			解决方案
			基本原理 
			已知应用
			结果环境
		结论
		致谢
		参考文献
	第29章  大泥球
		强制
		大泥球	
			也称为
		一次性代码
			也称为
		渐进增长
			也称为
		保持运行
			也称为
		修剪层次
		“扫到地毯下”
			也称为
		重建
			也称为
		结论
		致谢 
		参考文献

卷5
★★
作者：Dragos Manolescu、Markus voelter、James Noble 

前言
	前言
	导言 
		问题1：什么做得比较好并且是决不能忘记的？
		问题2：我们学到了什么？
		问题3：下一次要做的与以往有何不同？
		问题4：还有何难题？
		问题5：我最大的乐趣是什么？
		回顾挑战
		结论
		参考文献
第Ⅰ部分 设计模式
	第1章  动态对象模型
		1.1 目的
		1.2 别名
		1.3 动机
		1.4 问题
		1.5 解决方案结构
		1.6 优缺点
			1.6.1 简明性
			1.6.2 灵活性
			1.6.3 最终用户配置
			1.6.4 编程环境
			1.6.5 动态行为
			1.6.6 运行时输入
			1.6.7 可移植性
		1.7 扩展
		1.8 实现
		1.9 示例代码
		1.10 已知应用
		1.11 相关模式
		1.12 致谢
		1.13 参考文献 
	第2章  域对象管理器
		2.1 目的
		2.2 别名
		2.3 动机
		2.4 可应用性
		2.5 结构
		2.6 组成
		2.7 协作
		2.8 结果
		2.9 实现
		2.10 示例代码
		2.11 已知应用
		2.12 相关模式
		2.13 致谢
		2.14 参考文献
	第3章  封装上下文
		3.1 受众
		3.2 示例
		3.3 问题
		3.4 限制条件
			3.4.1 可替换性
			3.4.2 封装
			3.4.3 耦合到环境
			3.4.4 避免数据复制
		3.5 解决方案
		3.6 实现
		3.7 最终解决方案
		3.8 变体 
		3.9 结果
			3.9.1 可替换性
			3.9.2 封装
			3.9.3 耦合到环境
			3.9.4 避免数据复制
			3.9.5 推理
			3.9.6 实例化
			3.9.7 整洁的代码
			3.9.8 同步点
			3.9.9 测试
			3.9.10 Blob趋势
			3.9.11 隐藏的全局变量
			3.9.12 主要成员
		3.10 已知应用
			3.10.1 Chutney Technologies Apptimizer（C++）
			3.10.2 Reuters Liffe Connect Data Router（C++）
			3.10.3 Jiffy（Parthenon计算）XML数据库服务器（C++）
			3.10.4 Enterprise Java Beans
			3.10.5 Interpreter模式示例
		3.11 相关模式
		3.12 更多示例
		3.13 小结
		3.14 致谢
		3.15 参考文献
第Ⅱ部分 并发、网络与实时模式
	第4章  用于高效、可预测及可伸缩的调试组件的模式语言
		4.1 介绍
		4.2 调度组件与模式语言的概述
		4.3 用于调度组件的模式语言
			4.3.1 对单一对象的调度
			4.3.2 对多对象的调度
		4.4 结束语
		4.5 参考文献
	第5章  3T――硬实时系统中用于可靠通信的模式系统
		5.1 简介
			5.1.1 运行示例：线控制动
			5.1.2 模式概述
		5.2 提前计划的周期性传输
			5.2.1 上下文
			5.2.2 示例
			5.2.3 问题
			5.2.4 解决方案
			5.2.5 实现
			5.2.6 运行时示例分解
			5.2.7 结果
			5.2.8 已知应用
			5.2.9 相关模式
		5.3 时间触发时针同步
			5.3.1 上下文
			5.3.2 问题
			5.3.3 示例			
			5.3.4 解决方案
			5.3.5 实现 
			5.3.6 结果
			5.3.7 已知应用
			5.3.8 相关模式
		5.4 同步帧
			5.4.1 上下文
			5.4.2 问题
			5.4.3 示例			
			5.4.4 解决方案
			5.4.5 实现
			5.4.6 分解时运行示例
			5.4.7 结果
			5.4.8 已知应用
			5.4.9 相关模式
		5.5 总线守护
			5.5.1 上下文
			5.5.2 问题
			5.5.3 示例			
			5.5.4 解决方案
			5.5.5 实现
			5.5.6 分解时运行示例
			5.5.7 结果
			5.5.8 已知应用
			5.5.9 相关模式
		5.6 临时应用程序解耦
			5.6.1 上下文
			5.6.2 问题
			5.6.3 示例			
			5.6.4 解决方案
			5.6.5 实现 
			5.6.6 结果
			5.6.7 已知应用
		5.7 致谢
		5.8 附录
			5.8.1 术语
			5.8.2 已知应用
		5.9 参考文献
 	第6章  实时和资源超载语言
		6.1 介绍
		6.2 语言图
		6.3 语言上下文
			模式1 超载帝国
			模式2 灾难性通知
			模式3 重新评估过载决定
			模式4 如果工作很好，不要修改
			模式5 屏蔽分流工作优先权
			模式6 资源排队
			模式7 过载弹性
			模式8 合理的资源分配
		6.4 以前发布的模式
		6.5 致谢
		6.6 图像来源
			6.6.1 引入模式的图像
			6.6.2 其他图像
		6.7 参考文献
第Ⅲ部分 分布式系统
	第7章  分散锁定
		7.1 介绍
		7.2 别名
		7.3 示例
		7.4 上下文
		7.5 问题
		7.6 解决方案
		7.7 结构
		7.8 动态
		7.9 实现
			步骤1
			步骤2
			步骤3
			步骤4
			步骤5
		7.10 示例分解
		7.11 变体
		7.12 已知应用
		7.13 结果
		7.14 相关模式
		7.15 致谢
		7.16 参考文献
	第8章  比较模式：使用专门值简化身份测试
		8.1 简介
		8.2 示例
		8.3 上下文
		8.4 问题
		8.5 解决方案
		8.6 实现
			8.6.1 “正确的”比较语义
			8.6.2 对克隆的比较
			8.6.3 哪些类可相互比较
			8.6.4 给定系统的限制条件
			8.6.5 重用已有的属性
			8.6.6 执行比较操作
			8.6.7 分布式环境中的比较字符
			8.6.8 模糊比较字符
			8.6.9 复合比较字符
			8.6.10 计算比较字符
			8.6.11 协同比较字符
		8.7 结果
		8.8 已知应用
			8.8.1 JPDA
			8.8.2 远程方法请求
			8.8.3 CORBA关系服务
			8.8.4 Enterprise Java Beans
			8.8.5 Ginko
		8.9 相关模式
		8.10 结论
		8.11 致谢
		8.12 参考文献
	第9章  服务发现的模式语言
		9.1 模式
			模式1 询问本地网络
			模式2 覆盖网络
			模式3 侦听广告
			模式4 使用广告主
			模式5 查阅目录
			模式6 目录中的服务注册
			模式7 目录发现服务
			模式8 结合目录与组织
			模式9 动态放置目录
			模式10 从位置中分离标识
			模式11 客户知道最好的
			模式12 服务完成繁重工作
		9.2 结合模式：以SLP为例
		9.3 致谢
		9.4 参考文献
第Ⅳ部分 特定于域的模式
	第10章  MoRaR：移动与无线资源管理的模式语言
		10.1 介绍
		10.2 移动无线系统：体系结构概念
		10.3 MoRaR模式语言
		10.4 移动管理功能的相关模式
			10.4.1 临时标识
			10.4.2 安全数据库
			10.4.3 加密
			10.4.4 认证
			10.4.5 分页
			10.4.6 主数据库与访问数据库
			10.4.7 位置注册
		10.5 无线资源管理模式
			10.5.1 切换决定
			10.5.2 锚实体
			10.5.3 系统间切换执行
			10.5.4 切换失败措施
			10.5.5 释放资源
		10.6 结论
		10.7 致谢
		10.8 参考文献
		10.9 附录
	第11章  Web上的内容转换与生成：模式语言
		11.1 介绍
			11.1.1 目标受众
			11.1.2 表单上的注释
		11.2 模式语言回顾
		11.3 Web上转换和生成内容的模式
			11.3.1 通用内容格式 
			11.3.2 发布者与收集者
			11.3.3 内容转换器
			11.3.4 内容创建器
			11.3.5 内容格式模板
			11.3.6 片段
			11.3.7 内容缓存
		11.4 Java中的实现示例
		11.5 已知应用与相关工作
		11.6 结论
		11.7 致谢
		11.8 参考文献
第Ⅴ部分 体系结构模式
	第12章  插件模式
		12.1 组件的插件特色
		12.2 示例
		12.3 已知应用
		12.4 线路图
		12.5 插件
			12.5.1 上下文
			12.5.2 问题
			12.5.3 限制条件
			12.5.4 解决方案
			12.5.5 术语 
			12.5.6 结果
			12.5.7 实现
			12.5.8 组织问题
			12.5.9 已知应用
			12.5.10 示例
			12.5.11 相关模式
		12.6 插件协议 
			12.6.1 上下文
			12.6.2 问题
			12.6.3 限制条件
			12.6.4 解决方案
			12.6.5 结果
			12.6.6 实现
			12.6.7 变量
			12.6.8 示例
			12.6.9 已知应用
			12.6.10 相关模式
		12.7 提供框架的应用程序
			12.7.1 别名
			12.7.2 上下文
			12.7.3 问题
			12.7.4 限制条件
			12.7.5 解决方案
			12.7.6 结果
			12.7.7 实现
			12.7.8 变量
			12.7.9 示例
			12.7.10 已知应用
			12.7.11 相关模式
		12.8 插件注册 
			12.8.1 上下文
			12.8.2 问题
			12.8.3 限制条件
			12.8.4 解决方案
			12.8.5 结果
			12.8.6 实现
			12.8.7 变量
			12.8.8 示例
			12.8.9 已知应用
			12.8.10 相关模式
		12.9 插件生命周期
			12.9.1 上下文
			12.9.2 问题
			12.9.3 限制条件
			12.9.4 解决方案
			12.9.5 结果
			12.9.6 实现
			12.9.7 变量
			12.9.8 示例
			12.9.9 已知应用
			12.9.10 相关模式
		12.10 插件包
			12.10.1 上下文
			12.10.2 问题
			12.10.3 限制条件
			12.10.4 解决方案
			12.10.5 结果
			12.01.6 实现
			12.10.7 示例
			12.10.8 已知应用
			12.10.9 相关模式
		12.11 协作插件
			12.11.1 别名
			12.11.2 上下文
			12.11.3 问题
			12.11.4 限制条件
			12.11.5 解决方案
			12.11.6 结果
			12.11.7 实现		 
			12.11.8 示例
			12.11.9 已知应用
			12.11.10 相关模式
		12.12 基于插件的产品
			12.12.1 上下文
			12.12.2 问题
			12.12.3 限制条件
			12.12.4 解决方案
			12.12.5 结果
			12.12.6 实现
			12.12.7 组织问题
			12.12.8 示例
			12.12.9 已知应用
			12.12.10 相关模式
		12.13 致谢
		12.14 参考文献
	第13章  网格体系结构模式：影响分布式处理能力
		13.1 目的
		13.2 示例
		13.3 上下文
		13.4 问题
		13.5 解决方案
		13.6 结构
		13.7 动态过程
		13.8 实现
		13.9 已知应用
		13.10 结果
		13.11 相关模式
		13.12 致谢
		13.13 参考文献
	第14章  组件的语言集成的模式
		14.1 介绍
			14.1.1 软件集成
			14.1.2 模式语言轮廓
		14.2 组件和语言集成的模式
			14.2.1 命令语言
			14.2.2 组件打包器
			14.2.3 对象系统层
			14.2.4 自动类型转换器
			14.2.5 分离对象
		14.3 已知应用与技术投射
			14.3.1 文件档案系统再设计
			14.3.2 MHP产品线的硬件选择
			14.3.3 TclCL和XOTcl/SWIG
			14.3.4 用SPLIT OBJECT配置外观
			14.3.5 语义查找服务
			14.3.6 Apache Axis
		14.4 结论
		14.5 致谢
		14.6 参考文献
	第15章  成功框架开发的模式
		15.1 介绍
		15.2 项目背景
			15.2.1 数据访问层框架
			15.2.2 Web门户网站框架
		15.3 路线图
			模式1 重用的具体证据
			模式2 简明的优点
			模式3 技能小组
			模式4 试点应用程序
			模式5 小对象
			模式6 基于试点的测试
			模式7 框架用户参与
			模式8 多变更请求
		15.4 结论
		15.5 致谢
		15.6 参考文献
第Ⅵ部分 元模式
	第16章  高级模式编写
		16.1 简介
		16.2 现有的工作
		16.3“What”解决方案
		16.4 “How”过程
		16.5 “Why”问题
		16.6 Dead Weasels
		16.7 解决方案中的限制条件提示
		16.8 一致“Who”
		16.9 指向细节的指针
		16.10 致谢
		16.11 参考文献
	第17章  语言设计者的模式语言
		17.1 介绍
			17.1.1 LDPL基础
			17.1.2 LDPL中的应用的示例
		17.2 模式语言
			17.2.1 局部修复
			17.2.2 限制条件的群集
			17.2.3 局部对称
			17.2.4 限制条件的分解
			17.2.5 比例的层次
			17.2.6 交叉连接
			17.2.7 区别
			17.2.8 聚合
			17.2.9 共同点
			17.2.10 空隙
		17.3 结论
		17.4 参考文献
	第18章  审阅语言
		18.1 设置环境 
		18.2 三次迭代
		18.3 审阅者了解被审阅者
		18.4 半片面包
		18.5 主体情况
		18.6 作者为主
		18.7 匹配问题与解决方案
		18.8 令人隽的解决方案（”啊“效果）
		18.9 限制条件定义问题
		18.11 战争故事
		18.12 形式服从功能
		18.13 小模式
		18.14 结束语
		18.15 致谢
		18.16 参与文献
		18.10 平衡上下文
	第19章  草原式住宅模式
		19.1 在草原上
			19.1.1 眺望所和庇护所
			19.1.2 Hildebrand的本质特征
			19.1.3 Alexanderian的说明
			19.1.4 作者的注解
		19.2 形式服从优势特性
		19.3 眺望所与庇护所
		19.4 锚一样的烟囱
		19.5 悬桁平台
		19.6 带状窗户
		19.7 庇护所一样的壁炉
		19.8 眺望视角
		19.9 隐藏的垂线
		19.10 迂回的路径
		19.11 评价与结论
		19.12 致谢
		19.13 参考文献
作者介绍

4.  设计模式沉思录（Pattern Hatching Design Patterns Applied）

★★
作者：John Vlissides  

前言
	致谢
第1章  介绍
	1.1 对模式的十大误解
	1.2 观察
第2章  运用模式进行设计 
	2.1 基础
	2.2 孤儿、孤儿的收养以及借用品
	2.3“但是应该如何引入代用品呢？”
	2.4 访问权限
	2.5 关于VISITOR的一些警告
	2.6 单用户文件系统的保护
	2.7 多用户文件系统的保护
	2.8 小结
第3章  主体和变体 
	3.1 终止SINGLETON
	3.2 OBSERVER的烦恼
	3.3 重温VISITOR
	3.4 GENGRATION GAP
	3.5 Type Laundering
	3.6 感谢内存泄漏
	3.7 推拉模型
第4章  爱的奉献
第5章  高效模式编写者的7个习惯
	5.1 习惯1：经常反思
	5.2 习惯2：坚持使用同一套结构
	5.3 习惯3：尽早且频繁地涉及具体问题
	5.4 习惯4：保持模式间的区别和互补性
	5.5 习惯5：有效地呈现
	5.6 习惯6：不懈地重复
	5.7 习惯7：收集并吸取反馈
	5.8 没有银弹

5. 面向模式的软件体系结构 （Pattern-Oriented Software Arfhitecture）

官方网站：
http://www.hillside.net/patterns、 http://www.posa3.org

卷1：模式系统（A System of Patterns）
★
作者： Frank Buschmann、Regine Meunier、Hans Rohnert、Peter sommerlad、Michael Stal

前言
	本书结构
	致谢
第1章  模式
	1.1 什么是模式
	1.2 模式是如何构成的
	1.3 模式类别
		1.3.1 体系结构模式
		1.3.2 设计模式
		1.3.3 惯用用法
		1.3.4 与软件开发结合
	1.4 模式间关系
	1.5 模式描述
	1.6 模式和软件体系结构
		1.6.1 模式作为智力构造块
		1.6.2 构造异构体系结构
		1.6.3 模式和方法
		1.6.4 实现模式
	1.7 总结	
第2章  体系结构模式
	2.1 引言
	2.2 从混沌到结构
		2.2.1 层
		2.2.2 管道和过滤器
		2.2.3 黑板
	2.3 分布式系统
		2.3.1 代理者
	2.4 交互式系统
		2.4.1 模型――视图――控制器
		2.4.2 表示――抽象――控制
	2.5 适应性系统
		2.5.1 微核
		2.5.2 映像
第3章  设计模式
	3.1 引言
	3.2 结构化分解
		3.2.1 整体――部分
	3.3 工作的组织
		3.3.1 主控――从属
	3.4 访问控制
		3.4.1 代理
	3.5 管理
		3.5.1 命令处理器
		3.5.2 视图处理程序
	3.6 通信
		3.6.1 转发器――接收器
		3.6.2 客户机――分配器――服务器
		3.6.3 出版者――订阅者
第4章  惯用法
	4.1 引言
	4.2 惯用法能够提供什么
	4.3 惯用法与风格
	4.4 在哪里可以发现惯用法
		4.4.1 计数指针
第5章  模式系统
	5.1 什么是模式系统
	5.2 模式分类
		5.2.1 模式类别 
		5.2.2 问题类别
		5.2.3 分类图式
		5.2.4 比较
	5.3 模式选择
	5.4 作为实现指南的模式系统
	5.5 模式系统的演化
		5.5.1 模式描述的演化
		5.5.2 作者研讨会
		5.5.3 模式采掘
		5.5.4 新模式养成
		5.5.5 删除过时模式
		5.5.6 扩展组织图式
	5.6 总结
第6章  模式和软件体系结构
	6.1 引言
		6.1.1 软件体系结构
		6.1.2 组件
		6.1.3 关系
		6.1.4 视图
		6.1.5 功能属性和非功能属性
		6.1.6 软件设计
		6.1.7 小结
	6.2 软件体系结构中的模式
		6.2.1 方法学
		6.2.2 软件过程
		6.2.3 体系结构风格
		6.2.4 框架
	6.3 软件体系结构启用技术
		6.3.1 抽象
		6.3.2 封装
		6.3.3 信息隐藏
		6.3.4 模块化
		6.3.5 事务分离
		6.3.6 耦合和内聚
		6.3.7 充分性、完整性和原始性
		6.3.8 策略和实现的分离
		6.3.9 接口和实现的分离
		6.3.10 单一引用点
		6.3.11 分而治之
		6.3.12 小结
	6.4 软件体系结构的非功能属性
		6.4.1 易修改性
		6.4.2 互操作性
		6.4.3 效率
		6.4.4 可靠性
		6.4.5 可测试性
		6.4.6 可重用性
	6.5 总结
第7章  模式团体
	7.1 起源
	7.2 领军人物和他们的著作
	7.3 团体
第8章  模式将走向何方
	8.1 模式采掘
		8.1.1 软件体系结构的模式
		8.1.2 组织模式
		8.1.3 特定领域模式
		8.1.4 模式语言
	8.2 模式组织与索引
	8.3 方法与工具
	8.4 算法、数据结构和模式
	8.5 形式化模式
	8.6 最后评述
附录
	符号
	词汇表
	参考文献

卷2：用于并发和网络化对象模式（Patterns for Concurrent and Networked Objects）
★★★
作者：  Douglas C.Schmidt、Michael Stal、Hans Rohnert、Frank Buschmann

前言
	前言
	内容简介
		本书的读者
		结构和内容
		致谢
	作者简介
	读者指南
		模式介绍
		结构和内容
		模式形式
		阅读背景材料
第1章  并发和网络化对象
	1.1 动机
	1.2 并发和网络化软件的难题
		1.2.1 难题1：服务访问和配置
		1.2.2 难题2：事件处理
		1.2.3 难题3：并发
		1.2.4 难题4：同步
		1.2.5 网络化软件的其他难题
	1.3 安全分析：设计一个并发的Web服务器
		1.3.1 JAWS框架概述
		1.3.2 在JAWS中应用模式解决JAWS中常见的设计难题
		1.3.3 封装低层操作系统API
		1.3.4 从协议处理中分离事件多路分解和连接管理
		1.3.5 通过多线程提高服务器性能
		1.3.6 实现一个同步化的请求队列
		1.3.7 最小化服务器线程的开销
		1.3.8 有效地利用异步I/O
		1.3.9 增强服务器的可配置性
		1.3.10 用于实现JAWS的其他模式
	1.4 小结
第2章  服务访问和配置模式
	2.1 包装器外观
	2.2 组件配置器
	2.3 截取器
	2.4 扩展接口
第3章  事件处理模式
	3.1 反应器
	3.2 主动器
	3.3 异步完成标记
	3.4 接受器――连接器
第4章  同步模式
	4.1 定界加锁
	4.2 策略化回销
	4.3 线程安全接口
	4.4 双检查加锁优化
第5章  并发模式
	5.1 主动对象
	5.2 监视器对象
	5.3 半同步/半异步
	5.4 领导者/追随者
	5.5 线程特定的存储器
第6章  将模式组织在一起
	6.1 从独立模式到模式语言
		6.1.1 没有模式是孤立的
		6.1.2 走向模式语言
	6.2 用于中间件和应用程序的模式语言
		6.2.1 模式语言细节
		6.2.2 对模式语言的讨论
	6.3 并发和网络化之外
		6.3.1 图形用户界面
		6.3.2 组件
		6.3.3 常规编程
	6.4 模式语言与模式系统
第7章  模式的过去、现在和未来 
	7.1 在过去的4年中发生了什么
		7.1.1 模式
		7.1.2 模式系统和模式语言
		7.1.3 方法和工具
		7.1.4 算法与数据结构
		7.1.5 形式化模式
	7.2 模式现状
	7.3 模式向何处去
		7.3.1 模式
		7.3.2 模式语言
		7.3.3 经验报告、方法和工具
		7.3.4 模式文档
		7.3.5 形式化模式和模式语言
		7.3.6 软件开发过程和组织
		7.3.7 教育
		7.3.8 长远预测
	7.4 对预测未来的临别思考
第8章  结束语
附录
	附录A 词汇表
	附录B 符号
	附录C 参考文献

卷3：资源管理（Patterns for Resource Managerment）
★★☆
作者：  Michael Kircher、Prashant Jain

前言
	读者群
	本书结构
	导读
	致谢
	作者简介
第1章  导引
	1.1 资源管理概览
	1.2 资源管理的范围
	1.3 模式的使用
	1.4 资源管理中的模式
	1.5 相关工作
	1.6 模式格式
第2章  资源获取
	2.1 Lookup模式
	2.2 Lazy Acquisition模式
	2.3 Eager Acquisition模式
	2.4 Partial Acquisition模式
第3章  资源的生命周期
	3.1 Caching模式
	3.2 Pooling模式
	3.3 Coordinator模式
	3.4 Resource Lifecycle Manager 模式
第4章  资源释放
	4.1 Leasing模式
	4.2 Evictor模式
第5章  资源管理准则
第6章  案例分析――自组网络计算
	6.1 概览
	6.2 动机
	6.3 解决方案
第7章  案例分析――移动网络
	7.1 概览
	7.2 动机
	7.3 解决方案
第8章  模式的过去、现在和未来
	8.1 过去的四年
	8.2 模式的现状如何
	8.3 模式明天将走向何方
	8.4 关于模式未来的简短声明 
第9章  结语
附录
	引用到的模式
	符号表示法
	参考文献
	致谢

卷4：分布式计算的模式语言（A Pattern Language for Distributed Computing）
★★☆
作者：  Frank Buschmann、Kevlin Henney、Douglas C.Schmidt 

前言
	关于作者
	前言
	关于本书
		目标读者
		结构和内容
		致谢
	读者指南
		关于模式和模式语言
		关于分布式计算
		关于分布式计算模式语言
		模式语言实践
		模式语言细节
第一部分 概念
	第1章  模式与模式语言
		1.1 模式
		1.2 模式内幕
			1.2.1 问题的环境
			1.2.2 驱动因素：所有模式的核心
			1.2.3 解决方案与结果
			1.2.4 模式命名
			1.2.5 模式表现形式概述
		1.3 模式的关系
			1.3.1 模式的互补
			1.3.2 模式的组合
			1.3.3 模式故事 
			1.3.4 模式序列
		1.4 模式语言
			1.4.1 从模式序列到模式语言
			1.4.2 展现和使用模式语言
		1.5 模式的连接
	第2章  分布式系统
		2.1 分布式的优点
		2.2 分布式的挑战
		2.3 用以支持分布式的技术
			2.3.1 分布式对象计算中间件
			2.3.2 组件中间件
			2.3.3 发布/订阅中间件和面向消息的中间件
			2.3.4 面向服务架构和Web服务
		2.4 中间件技术的局限性
	第3章  模式语言
		3.1 意图、范畴和对象
		3.2 起源
		3.3 结构和内容
		3.4 模式的表现
		3.5 实际应用
第二部分 模式故事
	第4章  仓库管理流程控制
		4.1 系统范畴
		4.2 仓库管理流程控制
	第5章  基线架构	
		5.1 架构环境
		5.2 划分大泥球
		5.3 层次分解
		5.4 访问领域对象功能
		5.5 网络桥接
		5.6 分离用户界面
		5.7 功能分布
		5.8 支持并发的领域对象访问
		5.9 获得可扩展的并发性
		5.10 将面向对象与关系型数据库连接起来
		5.11 领域对象的运行时配置
		5.12 基线架构总结
	第6章  通信中间件
		6.1 分布式系统的中间件架构
		6.2 对中间件的内部设计进行结构化
		6.3 封装底层系统机制
		6.4 分离ORB核心事件
		6.5 ORB连接管理
		6.6 提高ORB的可伸缩性
		6.7 实现同步请求队列
		6.8 可互换的内部ORB机制
		6.9 管理ORB策略
		6.10 ORB动态配置
		6.11 通信中间件总结
	第7章  仓库拓扑
		7.1 仓库拓扑基线
		7.2 表现层次化的存储结构
		7.3 存储结构导航
		7.4 存储属性建模
		7.5 不同的存储单元行为
		7.6 实现全局功能
		7.7 遍历仓库拓扑
		7.8 支持控制流扩展
		7.9 连接数据库
		7.10 维护内存中的存储单元数据
		7.11 配置仓库拓扑
		7.12 细述显示接口
		7.13 仓库拓扑总结
	第8章  模式故事背后的故事
第三部分 模式语言
	第9章  从混沌到结构
		9.1 Domain Model
		9.2 Layers
		9.3 Model-View-Controller
		9.4 Presentation-Abstraction-Control
		9.5 Microkernel
		9.6 Reflection
		9.7 Pipes and Filters
		9.8 Shared repository
		9.9 Blackboard
		9.10 Domain Object
	第10章  分布式基础设施
		10.1 Messaging
		10.2 Message Channel
		10.3 Message Endpoint
		10.4 Message Translator
		10.5 Message Router
		10.6 Publisher-Subscriber
		10.7 Broker
		10.8 Client Proxy
		10.9 Requestor
		10.10 Invoker
		10.11 Client Request Handler
		10.12 Server Request Handler
	第11章  事件分离和分发
		11.1 Reactor
		11.2 Proactor
		11.3 Acceptor-Connector
		11.4 Asynchronous Completion Token
	第12章  接口划分
		12.1 Explicit Interface
		12.2 Extension Interface
		12.3 Introspective Interface
		12.4 Dynamic Invocation Interface
		12.5 Proxy
		12.6 Business Delegate
		12.7 Facade
		12.8 Combined Method
		12.9 Iterator
		12.10 Enumeration Methond
		12.11 Batch Method
	第13章  组件划分 
		13.1 Encapsulated Implementation
		13.2 Whole-Part
		13.3 Composite
		13.4 Master-Slave
		13.5 Half-Object plus Protocol
		13.6 Replicated Component Group
	第14章  应用控制
		14.1 Page Controller
		14.2 Front Controller
		14.3 Application Controller
		14.4 Command Processor
		14.5 Template View
		14.6 Transform View
		14.7 Firewall Proxy
		14.8 Authorzation
	第15章  并发
		15.1 Half-Sync/Half-Async
		15.2 Leader/Followers
		15.3 Active Object
		15.4 Monitor Object
	第16章  同步
		16.1 Guarded Suspension
		16.2 Future
		16.3 Thread-Safe Interface
		16.4 Double-Checked Locking
		16.5 Strategized Locking
		16.6 Scoped Locking
		16.7 Thread-Specific Storage
		16.8 Copied Value
		16.9 Immutale Value
	第17章  对象间的交互
		17.1 Observer
		17.2 Double Dispatch
		17.3 Mediator
		17.4 Command
		17.5 Memento
		17.6 Context Object
		17.7 Data Transfer Object
		17.8 Message
	第18章  适配与扩展
		18.1 Bridge
		18.2 Object Adapter
		18.3 Chain of Responsibility
		18.4 Interpreter
		18.5 Interceptor
		18.6 Visitor
		18.7 Decorator
		18.8 Execute-Around Object
		18.9 Template Method
		18.10 Strategy
		18.11 Null Object
		18.13 Wrapper Facade
		18.14 Declarative Component Configuraion
	第19章  模态行为
		19.1 Objects for States
		19.2 Methods for States 
		19.3 Collections for States
	第20章  资源管理
		20.1 Container
		20.2 Component Configurator
		20.3 Object Manager
		20.4 Lookup
		20.5 Virtual Proxy
		20.6 Lifecycle Callback
		20.7 Task Coordinator
		20.8 Resource Pool
		20.9 Resource Cache
		20.10 Lzay Acquisition
		20.11 Eager Acquisition
		20.12 Partial Acquisition
		20.13 Activator
		20.14 Evictor
		20.15 Leasing 
		20.16 Automated Garbage Collection
		20.17 Counting Handles
		20.18 Abstract Factory
		20.19 Builder
		20.20 Factory Method
		20.21 Disposal Method
	第21章  数据库访问 
		21.1 Database Access Layer
		21.2 Data Mapper
		21.3 Row Data Gateway
		21.4 Table Data Gateway
		21.5 Active Record
	第22章  最后的思考

卷5：模式与模式语言（On Patterns and Pattern Languages）
★
作者：  Frank Buschmann、Kevlin Henney、Douglas C.Schmidt 

前言
	关于本书
		目标读者
		结构和内容
		致谢
	读者指南
		鸟瞰模式
		从特定视角看模式
		模式之同源同宗
第0章  尘埃落定
	0.1 渊源
	0.2 成功与失败
		0.2.1 观察
		0.2.2 状态
		0.2.3 处方
	0.3 模式定义及解释
	0.4 深入理解模式
第一部分 模式剖析
	第1章  问题之解决方案及其他 
		1.1 问题之解决方案
			1.1.1 一个例子（1）
			1.1.2 重现与良好 
		1.2 流程和物件
		1.3 “好”的解决方案
		1.4 驱动力：模式之心脏
			1.4.1 一个例子（4）
			1.4.2 dysfunctional、bad还是anti
		1.5 上下文
			1.5.1 一个例子（5）
			1.5.2 上下文的一般性
			1.5.3 独立止下文
			1.5.4 一个例子（6）
		1.6 一般性
		1.7 一图胜（逊）千言
		1.8 模式命名
			1.8.1 模式命名的语法分类
			1.8.2 字面命名还是隐喻
		1.9 模式是循序渐进的
		1.10 模式既是讲故事，又能发起对话
		1.11 模式不能代替思考
		1.12 从“问题――解决方案”到模式
	第2章  多种多样的模式实现
		2.1 是否存在一个通用的模型呢
			2.1.1 Observer模式：快速回顾
			2.1.2 结构的变化与角色
			2.1.3 行为的变化 
			2.1.4 内部差异
			2.1.5 语言及平台的差别
			2.1.6 领域、环境相关的变化 
			2.1.7 再论假设
		2.2 模式与框架
			2.2.1 工具和上下文环境
			2.2.2 两个框架的故事
		2.3 模式与形式主义
		2.4 通用性与特殊性
	第3章  模式格式
		3.1 风格与实质
		3.2 格式的功能
		3.3 格式的元素
		3.4 细节
			3.4.1 案例
			3.4.2 图示
			3.4.3 <code>...</code>
		3.5 鸟瞰图
			3.5.1 从金字塔到托盘
			3.5.2 模式骨架
			3.5.3 总结意图
			3.5.4 模式抽象
		3.6 不同的格式 
			3.6.1 演变
			3.6.2 选择
		3.7  风格与实质
第二部分 模式之间的关系 
	第4章  模式孤岛	
		4.1 模式的联系
		4.2 设计实验：将模式作为孤岛
		4.3 第二个设计实验：交织在一起的模式
		4.4 模式密度
	第5章  模式的互补性
		5.1 一个问题，多种解决方案
		5.2 互相竞争的模式
			5.2.1 以状态为例
			5.2.2 模式族
			5.2.3 迭代开发
			5.2.4 适配开发
			5.2.5 遵从康威定律
			5.2.6 与风格的设计对话
		5.3 互相合作的模式
			5.3.1 一个关于值的例子
			5.3.2 设计上的完善
		5.4 模式结合
			5.4.1 再论迭代
			5.4.2 再论适配编程
		5.5 互补性：竞争、完善、结合
	第6章  模式复合
		6.1 常见模式排列
		6.2 从元素到复合
			6.2.1 Pluggable Factory
			6.2.2 Composite Command的两种视角
			6.2.3 模式复合的格式 
		6.3 从补充到复合
			6.3.1 重申
			6.3.2 适配
		6.4 是元素还是组合 
			6.4.1 组合的含义
			6.4.2 深入MVC
		6.5 复合分析与综合
			6.5.1 非设计模式的复合
			6.5.2 设计模式复合
	第7章  模式序列
		7.1 模式讲述软件工程成功的故事 
		7.2 模式故事
			7.2.1 一个小故事 
			7.2.2 已经发表的故事
		7.3 从故事到序列
		7.4 模式的序列
			7.4.1 一个早期的例子
			7.4.2 模式序列既是流程也是物体
			7.4.3 再次回到以前提到的小故事
		7.5 回顾模式复合和模式互补
			7.5.1 重组
			7.5.2 再论Batch Iterator
			7.5.3 再论Interpreter
			7.5.4 再论Align Architecture and Organizations
		7.6 回到上下文的问题
			7.6.1 定义上下文
			7.6.2 专用化与差异化
		7.7 模式间的联系
	第8章  模式集合
		8.1 模式手册 
		8.2 组织模式集合
		8.3 即时组织
		8.4 根据层次组织
			8.4.1 设计和架构
			8.4.2 惯用法
			8.4.3 混合层次
			8.4.4 层次
		8.5 根据领域组织
		8.6 根据分区组织
			8.6.1 阶层架构
			8.6.2 分区
		8.7 根据意图组织
			8.7.1 根据意图划分POSA的模式
			8.7.2 根据意图划分GoF的模式
			8.7.3 根据意图划分DDD模式
			8.7.4 反思模式意图
		8.8 组织模式集合（重奏）
		8.9 问题框架
			8.9.1 问题框架
			8.9.2 问题框架和模式的对比 
			8.9.3 问题框架与模式的组合 
		8.10 模式符号学
		8.11 模式集合与风格
			8.11.1 Unix接口设计模式
			8.11.2 Web 2.0 设计模式
			8.11.3 风格与概念一致性
		8.12 走向模式语言
第三部分 模式语言
	第9章  语言的元素
		9.1 使用模式进行设计 
		9.2 从模式故事和模式序列到模式语言
			9.2.1 一个未完成的故事
			9.2.2 序列的组合
	第10章  模式网络及其他 
		10.1 模式网络
		10.2 流程与物件
			10.2.1 流程的迭代本质
			10.2.2 具体的面向领域的引导
		10.3 单项最佳
		10.4 驱动力：模式语言之心脏
		10.5 模式上下文定义拓扑结构与架构风格
		10.6 模式构成词汇，序列展示语法
		10.7 通用性
			10.7.1 不同的模式序列
			10.7.2 模式的组合
		10.8 完整的语言胜过千幅图
		10.9 面向领域的命名帮助忆起模式语言
		10.10 模式语言展开对话并讲述很多故事
		10.11 路还很长
		10.12 模式语言对创建性智慧的回报
		10.13 从模式网络到模式语言
	第11章  亿万种不同的实现
		11.1 众口难调
		11.2 渐进式成长 
			11.2.1 面向系统的、进化的设计方法
			11.2.2 渐进式成长和敏捷开发
		11.3 并没有排斥重构
		11.4 一次一个模式
			11.4.1 明白手头上的问题的关键
			11.4.2 优先级驱动的设计决策
			11.4.3 模式集成先于模式实现
		11.5 基于角色的模式集成
			11.5.1 选择1：识别并且保持已经实现的角色
			11.5.2 选择2：识别并分离已经实现的角色
			11.5.3 选择3：将缺失角色分配给既有设计元素
			11.5.4 选择4：将缺失角色作为新设计元素来实现
			11.5.5 选择5：基于角色的模式集成和渐进式成长过程
		11.6 模式语言和参考架构
		11.7 模式语言与产品线架构
		11.8 从十亿个到一个……再到一些
	第12章  模式语言的格式 
		12.1 风格与本质
		12.2 格式的作用
		12.3 格式的元素
			12.3.1 展示全貌
			12.3.2 简洁与细节
			12.3.3 模式连接
			12.3.4 再说元素
		12.4 细节，细节，细节
			12.4.1 模式语言的模式
			12.4.2 鸟瞰图
			12.4.3 展示顺序
			12.4.4 示例
			12.4.5 细节程序
		12.5 再论风格与本质
	第13章  模式与模式语言
		13.1 模式和模式语言：共性 
			13.1.1 共同的核心属性
			13.1.2 共同的根源
			13.1.3 一个模式的模式语言
		13.2 模式与模式语言：区别
			13.2.1 模式和细节
			13.2.2 模式语言和交互
			13.2.3 两个独立的世界
		13.3 模式“对”模式语言
	第14章  从模式到人
		14.1 模式以人为本
			14.1.1 模式价值体系
			14.1.2 人类读者
		14.2 对软件开发者的支持
		14.3 对软件使用者的支持
			14.3.1 用户界面
			14.3.2 用户需求
			14.3.3 交到用户手中
		14.4 对模式作者的支持
			14.4.1 协同写作
			14.4.2 作者研讨会
			14.4.3 牧放
		14.5 技术为人
	第15章  模式的过去、现在和将来	
		15.1 过去的3年
			15.1.1 模式与模式语言
			15.1.2 理论和概念
			15.1.3 重构与集成
			15.1.4 GoF
		15.2 模式的现状
		15.3 模式的明天在哪里
			15.3.1 模式与模式语言
			15.3.2 理论和概念
			15.3.3 重构与集成
			15.3.4 支持其他的软件开发方法
			15.3.5 对其他学科的影响
			15.3.6 其他学科对我们的影响
		15.4 简述模式的未来
	第16章  万事如意
附录
	模式总结
	参考模式
	参考文献

6. 企业应用架构模式 （Patterns of Enterprise Application Architecture）

★
作者：Martin Fowler  

前言
	模式列表
	前言
		本书的读者
		致谢
引言
	0.1 架构
	0.2 企业应用
	0.3 企业应用的种类
	0.4 关于性能的考虑
	0.5 模式
		0.5.1 模式的结构
		0.5.2 模式的局限性
第一部分 表述
	第1章  分层
		1.1 企业应用中层次的演化
		1.2 三个基本品次
		1.3 为各层选择运行环境
	第2章  组织领域逻辑
		2.1 抉择
		2.2 服务器
	第3章  映射到关系数据库
		3.1 架构模式
		3.2 行为问题
		3.3 读取数据
		3.4 结构映射模式
			3.4.1 关系的映射
			3.4.2 继承
		3.5 建立映射
		3.6 使用元数据
		3.7 数据库连接
		3.8 其他问题
		3.9 进一步阅读
	第4章  Web表现层
		4.1 视图模式
		4.2 输入控制器模式
		4.3 进一步阅读
	第5章  并发
		5.1 并发问题
		5.2 执行语境
		5.3 隔离与不变性
		5.4 乐观并发控制和悲观并发控制
			5.4.1 避免不一致读
			5.4.2 死锁
		5.5 事务
			5.5.1 ACID
			5.5.2 事务资源
			5.5.3 减少事务隔离以提高灵活性
			5.5.4 业务事务和系统事务
		5.6 离线并发控制的模式
		5.7 应用服务器并发
		5.8 进一步阅读
	第6章  回话状态
		6.1 无状态的价值
		6.2 会话状态
		6.3 存储会话状态的方法
	第7章  分布策略
		7.1 分布对象的诱惑
		7.2 远程接口和本地接口
		7.3 必须使用分布的情况
		7.4 关于分布边界
		7.5 分布接口
	第8章  通盘考虑
		8.1 从领域层开始
		8.2 深入到数据源层
			8.2.1 事务脚本的数据源
			8.2.2 表模块的数据源
			8.2.3 领域模型的数据源
		8.3 表现层
		8.4 一些关于具体技术的建议
			8.4.1 Java和J2EE
			8.4.2 .NET
			8.4.3 存储过程
			8.4.4 Web Services
		8.5 其他分层方式
第二部分 模式
	第9章  领域逻辑模式
		9.1 事务脚本
			9.1.1 运行机制
			9.1.2 使用时机
			9.1.3 收入确认问题
			9.1.4 例：收入确认
		9.2 领域模型
			9.2.1 运行机制
			9.2.2 使用时机
			9.2.3 进一步阅读
			9.2.4 例：收入确认
		9.3 表模块
			9.3.1 运行机制
			9.3.2 使用时机
			9.3.3 例：基于表模块的收入确认
		9.4 服务层
			9.4.1 运行机制
			9.4.2 使用时机
			9.4.3 进一步阅读
			9.4.4 例：收入确认
	第10章  数据源架构模式
		10.1 表数据入口
			10.1.1 运行机制
			10.1.2 使用时机
			10.1.3 进一步阅读
			10.1.4 例：人员入口
			10.1.5 例：使用ADO.NET数据类
		10.2 行数据入口
			10.2.1 运行机制
			10.2.2 使用时机
			10.2.3 例：人员记录
			10.2.4 例：领域对象的数据保持器
		10.3 活动记录
			10.3.1 运行机制
			10.3.2 使用时机
			10.3.3 例：一个简单的Person类
		10.4 数据映射器
			10.4.1 运行机制
			10.4.2 使用时机
			10.4.3 例：一个简单的数据映射器
			10.4.4 例：分离查找方法
			10.4.5 例：创建一个空对象
	第11章  对象――关系行为模式
		11.1 工作单元
			11.1.1 运行机制
			11.1.2 使用时机
			11.1.3 例：使用对象注册的工作单元
		11.2 标识映射
			11.2.1 运行机制
			11.2.2 使用时机
			11.2.3 例：标识映射中的方法
		11.3 延迟加载
			11.3.1 运行机制
			11.3.2 使用时机
			11.3.3 例：延迟初始化
			11.3.4 例：虚代理
			11.3.5 例：使用值保持器
			11.3.6 例：使用重影
	第12章  对象――关系结构模式
		12.1 标识域
			12.1.1 工作机制
			12.1.2 使用时机
			12.1.3 进一步阅读
			11.1.4 例：整型键
			11.1.5 例：使用键表
			11.1.6 例：使用组合键
		12.2 外键映射
			12.2.1 运行机制
			12.2.2 使用时机
			12.2.3 例：单值引用 
			12.2.4 例：多表查询
			12.2.5 例：引用集合
		12.3 关联表映射
			12.3.1 运行机制
			12.3.2 使用时机
			12.3.3 例：雇员和技能
			12.3.4 例：使用直接的SQL
			12.3.5 例：用一次查询查多个雇员
		12.4 依赖映射
			12.4.1 运行机制
			12.4.2 使用时机
			12.4.3 例：唱片和曲目
		12.5 嵌入值
			12.5.1 运行机制
			12.5.2 使用时机
			12.5.3 进一步阅读
			12.5.4 例：简单值对象
		12.6 序列化LOB
			12.6.1 运行机制
			12.6.2 使用时机
			12.6.3 例：在XML中序列化一个部门层级
		12.7 单表继承
			12.7.1 运行机制
			12.7.2 使用时机
			12.7.3 例：运动员的单表
			12.7.4 从数据库中加载对象
		12.8 类表继承
			12.8.1 运行机制
			12.8.2 使用时机
			12.8.3 进一步阅读
			12.8.4 例：运动员和他们的家属
		12.9 具体表继承
			12.9.1 运行机制
			12.9.2 使用时机
			12.9.3 例：具体运动员
		12.10 继承映射器
			12.10.1 运行机制
			12.10.2 使用时机
	第13章  对象――关系元数据映射模式
		13.1 元数据映射
			13.1.1 运行机制
			13.1.2 使用时机
			13.1.3 例：使用元数据和反射
		13.2 查询对象
			13.2.1 运行机制
			13.2.2 使用时机
			13.2.3 进一步阅读 
			13.2.4 例：简单的查询对象
		13.3 资源库
			13.3.1 运行机制
			13.3.2 使用时机
			13.3.3 进一步阅读 
			13.3.4 例：查找一个人所在的部门
			13.3.5 例：资源库交换策略
	第14章  Web表现模式
		14.1 模型――视图――控制器
			14.1.1 运行机制
			14.1.2 使用时机
		14.2 页面控制器
			14.2.1 运行机制
			14.2.2 使用时机
			14.2.3 例：Servlet控制器和JSP视图的简单演示
			14.2.4 例：使用JSP充当处理程序
			14.2.5 例：代码隐藏的页面控制器
		14.3 前端控制器
			14.3.1 运行机制
			14.3.2 使用时机
			14.3.3 进一步阅读 
			14.3.4 例：简单的显示
		14.4 模板视图
			14.4.1 运行机制
			14.4.2 使用时机
			14.4.3 例：分离的控制器，使用JSP充当视图
			14.4.4 例：ASP.NET服务器页面
		14.5 转换视图
			14.5.1 运行机制
			14.5.2 使用时机
			14.5.3 例：简单的转换
		14.6 两步视图
			14.6.1 运行机制
			14.6.2 使用时机
			14.6.3 例：两阶XSLT（XSLT）
			14.6.4 例：JSP和定制标记
		14.7 应用控制器
			14.7.1 运行机制
			14.7.2 使用时机
			14.7.3 进一步阅读
			14.7.4 例：状态模型应用控制器
	第15章  分布模式
		15.1 远程外观
			15.1.1 运行机制
			15.1.2 使用时机
			15.1.3 例：使用Java语言的会话Bean来作为远程外观
			15.1.4 例：Web Service
		15.2 数据传输对象
			15.2.1 运行机制
			15.2.2 使用时机
			15.2.3 进一步阅读
			15.2.4 例：传输唱片信息
			15.2.5 例：使用XML实现序列化
	第16章  离线并发模式
		16.1 乐观离线锁
			16.1.1 运行机制
			16.1.2 使用时机
			16.1.3 例：领域层与数据映射层
		16.2 悲观离线锁
			16.2.1 运行机制
			16.2.2 使用时机
			16.2.3 例：简单锁管理对象
		16.3 粗粒度锁
			16.3.1 运行机制
			16.3.2 使用时机
			16.3.3 例：共享的乐观离线锁
			16.3.4 例：共享的悲观离线锁
			16.3.5 例：根对象乐观离线锁
		16.4 隐含锁
			16.4.1 运行机制
			16.4.2 使用时机
			16.4.3 例：隐含的悲观离线锁
	第17章  会话状态模式
		17.1 客户会话状态
			17.1.1 运行机制
			17.1.2 使用时机
		17.2 服务器会话状态
			17.2.1 运行机制
			17.2.2 使用时机
		17.3 数据库会话状态
			17.3.1 运行机制
			17.3.2 使用时机
	第18章  基本模式
		18.1 入口 
			18.1.1 运行机制
			18.1.2 使用时机
			18.1.3 例：私有消息服务的入口
		18.2 映射器 
			18.2.1 运行机制
			18.2.2 使用时机
		18.3 层超类型 
			18.3.1 运行机制
			18.3.2 使用时机
			18.3.3 例：领域对象
		18.4 分离接口 
			18.4.1 运行机制
			18.4.2 使用时机
		18.5 注册表 
			18.5.1 运行机制
			18.5.2 使用时机
			18.5.3 例：单子注册表
			18.5.4 例：线程安全的注册表
		18.6 值对象
			18.6.1 运行机制
			18.6.2 使用时机
		18.7 货币
			18.7.1 运行机制
			18.7.2 使用时机
			18.7.3 例：货币类
		18.8 特殊情况
			18.8.1 运行机制
			18.8.2 使用时机
			18.8.3 进一步阅读
			18.8.4 例：一个简单的空对象
		18.9 插件
			18.9.1 运行机制
			18.9.2 使用时机
			18.9.3 例：ID生成器
		18.10 服务桩
			18.10.1 运行机制
			18.10.2 使用时机
			18.10.3 例：销售锐服务
		18.11 记录集
			18.11.1 运行机制
			18.11.2 使用时机