条款7 在创建对象时注意区分()和{}
	★	C++11引入了统一初始化，单一的、至少从概念上可以用于一切场合、表达一切意思的初始化。它的基础是大括号形式。
	★	大括号初始化有一项新特性，就是它禁止内建型别之间进行隐式窄化型别转换。
	★	大括号初始化的另一项值得一提的特征是，它对于C++的最令人苦恼之解析语法免疫。
		C++规定：任何能够解析为声明的都要解析为声明。
	★	有一个或多个构造函数声明了任何一个具备std::initializer_list型别的形参，
		那么采用了大括号初始化语法的调用会强烈地优先选用std::initializer_list型别形参的重载版本。
	★	假定你使用了一对空大括号来构造一个对象，而该对象既支持默认构造函数，又支持带有std::initializer_list型别形参的构造函数，在这种情况下应该执行默认构造。
		如果你的确想要调用一个带有std::initializer_list型别形参的构造函数，并传入一个空的std::initializer_list的话，
		你可以通过把空大括号对作为构造函数实参的方式实现这个目的。
	★	大括号初始化可以应用的语境最为宽泛，可以阻止隐式窄化型别转换，还对最令人苦恼之解析语法免疫。
	★	在构造函数重载决议期间，只要有任何可能，大括号初始化物就会与带有std::initializer_list型别的形参相匹配，
		即使其他重载版本有着貌似更加匹配的形参表。
	★	使用小括号还是大括号，会造成结果大相径庭的一个例子是：使用两个实参创建一个std::vector<数值型别>对象。
	★	在模板内容进行对象创建时，到底应该使用小括号还是大括号会成为一个棘手问题。