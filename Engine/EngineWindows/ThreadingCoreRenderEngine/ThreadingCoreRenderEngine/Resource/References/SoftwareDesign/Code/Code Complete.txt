代码大全（Code Complete）
（第2版)

官方网站：
https://stevemcconnell.com/、 http://www.cc2e.com/ （已失效）。

★★☆
作者：Steve McConnell
其他书籍：《软件估算：“黑匣子”揭秘》。

知识点
1.	软件构建手册。 
2.	需求核对表（3.4 需求的先决条件）。
3.  架构核对表（3.5 架构的先决条件）。
4.  前期准备核对表（第3章 三思而后行：前期准备）。
5.	主要的构建实践核对表（4.4 选择主要的构建实践方法）。
6.	软件构造中的设计核对表（5.5	对流行的设计方法的评论）。
7.	类的质量核对表（6.6	超越类：包）。
8.	高质量的子程序核对表（7.7 宏子程序和内联子程序）。
9.	防御式编程核对表（8.8 对防御式编程采取防御的姿态）。
10.	使用数据的一般事项核对表（10.8 为变量指定单一用途）。
11.	变量命名核对表（11.7 应该避免的名字）。
12.	基本数据类型核对表（12.9 创建你自己的类型）。
13.	用狗牌字段来检测损毁的内存（13.2 指针）。
14.	使用不常见数据类型的核对表（13.3 全局数据）。
15.	组织直线型代码核对表（14.2 顺序无关的语句）。
16. 使用条件语句核对表（15.2 case语句）。
17.	循环核对表（16.4 循环和数组的关系）。
18.	不常见的控制结构核对表（17.4 针对不常见控制结构的观点）。
19.	表驱动法核对表（18.5 表查询的其他示例）。
20.	如何度量复杂度（19.6 控制结构与复杂度）。
21.	控制结构相关事宜核对表（19.6 控制结构与复杂度）。
22.	质量保证计划核对表（20.5 软件质量的普通原理）。
23.	有效的结对编程核对表（21.2 结对编程）。
24.	测试用例核对表（22.7 保留测试记录）。
25.	关于调试的建议核对表（23.5 调试工具——明显的和不那么明显的）。
26. 重构的理由核对表（24.2 重构简介）。
27.	重构总结核对表（24.3 特定的重构）。
28.	安全的重构核对表（24.4 安全的重构）。
29. 代码调整策略核对表（25.6 代码调整方法总结）。
30.	代码调整方法核对表（26.6 用低级语言重写代码）。
31.	配置管理核对表（28.2 配置管理）。
32.	集成核对表（29.4 每日构建与冒烟测试）。
33.	编程工具核对表（30.6 工具幻境）。
34.	布局核对表（31.8 类的布局）。
35.	自说明文档核对表（32.2 编程风格作文档）。
36.	好的注释技术检查表（32.6 IEEE标准）。

要点
1.	首先为人编写代码，其次才是为机器。（译序）
2.	可以用较低代价修正的错误，并不意味着这些错误的修正不重要。（前言）
3.	隐喻的价值绝不应低估。隐喻的优点在于其可预期的效果：能被所有的人理解。不必要的沟通和误解也因此大为减低，学习与教授更为快速。
	实际上，隐喻是对概念进行内在化和抽象的一种途径，它让人们在更高的层面上思考问题，从而避免低层次的错误。（第2章）
4.	设计模式提供的益处：（第5章）
	（1）设计模式通过提供现成的抽象来减少复杂度。
	（2）设计模式通过把常见解决方案的细节予以制度化来减少出错。
	（3）设计模式通过提供多种设计方案而带来启发性的价值。
	（4）设计模式通过把设计对话提升到一个更高的层次上来简化交流。
5.	创建类的抽象接口的指导建议：（第6章）
	（1）类的接口应该展现一致的抽象层次。
	（2）一定要理解类所实现的抽象是什么。
	（3）提供成对的服务。
	（4）把不相关的信息转移到其他类中。
	（5）尽可能让接口可编程，而不是表达语义。
	（6）谨防在修改时破坏接口的抽象。
	（7）不要添加与接口抽象不一致的公有成员。
	（8）同时考虑抽象性和内聚性。
6.	良好的封装：（第6章）
	（1）不要公开暴露成员数据。
	（2）避免把私有的实现细节放入类的接口中。
	（3）不要对类的使用者做出任何假设。
	（4）避免使用友元类。
	（5）不要因为一个子程序里仅使用公有子程序，就把它归入公开接口。
	（6）让阅读代码比编写代码更方便。
	（7）要格外警惕从语义上破坏封装性。
	（8）留意过于紧密的耦合关系。
7.	包含：（第6章）
	（1）通过包含来实现“有一个”的关系。
	（2）在万不得已时通过private继承来实现“有一个”的关系。
	（3）警惕有超过约7个数据成员的类。
8.	应该避免的类：（第6章）
	（1）避免创建万能类。
	（2）消除无关紧要的类。
	（3）避免用动词命名的类。
9.	设置函数的返回值：（第7章）
	（1）检查所有可能的返回路径。
	（2）不要返回指向局部数据的引用或指针。
10.	指导建议：（第9章）
	（1）把编译器的警告级别调到最高。
	（2）使用验证工具。
	（3）消息产生错误消息和警告的所有根源。
11.	应该避免的名字：（第11章）
	（1）避免使用具有相似含义的名字。
	（2）避免使用具有不同含义但却有相似名字的变量。
	（3）避免使用发音相近的名字。
	（4）避免在名字中使用数字。
	（5）避免在名字中拼错单词。
	（6）避免使用英语中常常拼错的单词。
	（7）不要仅靠大小写来区分变量名。
	（8）避免使用多种自然语言。
	（9）避免使用标准类型、变量和子程序的名字。
	（10）不要使用与变量含义完全无关的名字。
	（11）避免在名字中包含易混淆的字符。
12.	数值概论：（第12章）
	（1）避免使用“神秘数值”。
	（2）如果需要，可以使用硬编码的0和1
	（3）预防除零错误。
	（4）使类型转换变得明显。
	（5）避免混合类型的比较。
	（6）注意编译器的警告。
13. 最好是去找一种好的方案而且同时避免引发灾难，而不是试图去寻找最佳方案。（18.4 阶梯访问表）
14.	按照数轴的顺序编写数值表达式。（19.1 布尔表达式）
15.	与0比较的指导原则：（19.1 布尔表达式）
	（1）隐式地比较逻辑变量。
	（2）把数和0相比较。
	（3）在C中显式地比较字符和零终止符（'\0'）。
	（4）把指针与NULL相比较。
16.	编译器的警告信息：（23.5 调试工具——明显的和不那么明显的）
	（1）将编译器的警告级别设置为最高级，尽可能不放过任何一个警告，然后修正编译器所报告的全部错误。
	（2）用对待错误的态度来处理警告。
	（3）在项目组范围内使用统一的编译设置。
17.	复制粘贴即设计之谬。（24.2 重构简介）
18.	不要为拙劣的代码编写文档——就当重写代码。（24.2 重构简介）

第1部分 打好基础
	第1章 欢迎进入软件构建的世界
		★	要点：
			1.	软件构建是软件开发的核心活动；构建活动是每个项目中唯一一项必不可少的工作。
			2.	软件构建的主要活动包括：详细设计、编码、调试、集成、开发者测试（包括单元测试和集成测试）。
			3.	构建也常被称作“编码”和“编程”。
			4.	构建活动的质量对软件的质量有着实质性的影响。
	第2章 用隐喻来更充分地理解软件开发
		★	科学发展的历史并不是一系列从“错误”的隐喻到“正确”的隐喻的转变，而是一系列从“不太合适”的隐喻到“更好”的隐喻的转变，
			也是从不是很贴切的隐喻到更贴切的隐喻的转变，还是从在一个方面暗示人们到在别一个方面暗示人们的转变。 
		★	要点：
			1.	隐喻是启示而不是算法。因此它们往往有一点随意。
			2.	隐喻把软件开发过程与其他你熟悉的活动联系在一起，帮助你更好地理解。
			3.	有些隐喻比其他一些隐喻更贴切。
			4.	通过把软件的构建过程比作是房屋的建设过程，我们可以发现，仔细的准备是必要的，而大型项目和小型项目之间也是有差异的。
			5.	通过把软件开发中的实践比作是智慧工具箱中的工具，我们又发现，每位程序员都有许多工具，
				但并不存在任何一个能适用于所有工作的工具，因地制宜地选择正确工具是成为能有效编程的程序员的关键。
			6.	不同的隐喻彼此并不排斥，应当使用对你最有益处的某种隐喻组合。
	第3章 三思而后行：前期准备
		★	要点：
			1.	构建活动的准备工作的根本目标在于降低风险。要确认你的准备活动是在降低风险，而非增加风险。
			2.	如果你想开发高质量的软件，软件开发过程必须由始至终关注质量。
				在项目初期关注质量，对产品质量的正面影响比在项目末期关注质量的影响要大。
			3.	程序员的一部分工作是教育老板和合作者，告诉他们软件开发过程，包括在开始编程之前进行充分准备的重要性。
			4.	你所从事的软件项目的类型对构建活动的前期准备有重大影响——许多项目应该是调度迭代式的，某些应该是序列式的。
			5.	如果没有明确的问题定义，那么你可能会在构建期间解决错误的问题。
			6.	如果没有做完良好的需求分析工作，你可能没能察觉待解决的问题的重要细节。
				如果需要变更发生在构建之后的阶段，其代阶是“在项目早期更改需求”的20至100倍。
				因此在开始编程之前，你要确认“需求”已到到位了。
			7.	如果没有做完良好的架构设计，你可能会在构建期间用错误的方法解决正确的问题。
				架构变更的代阶随着“为错误的架构编写的代码数量”增加而增加，因此，也要确认“架构”已经到位了。
			8.	理解项目的前期准备所采用的方法，并相应地选择构建方法。
	第4章 关键的“构建”决策
		★	要点：
			1.	每种编程语言都有其优点和弱点。要知道你使用的语言的明确优点和弱点。
			2.	在开始编程之前，做好一些约定。“改变代码使之符合这些约定”是近乎不可能的。
			3.	“构建的实践方法”的种类比任何单个项目能用到的更多。有意识地选择最适合你的项目的实践方法。
			4.	问问你自己，你采用的编程实践是对你所用的编程语言的正确响应，还是受它的控制？
				请记得“深入一种语言去编程”，不要仅“在一种语言上编程”。
			5.	你在技术浪潮中的位置决定了哪种方法是有效的——甚至是可能用到的。
				确定你在技术浪潮中的位置，并相应调整计划和预期目标。
第2部分 创建高质量的代码
	第5章 软件构建中的设计
		★	高代价、低效率的设计源于下面三种根源：
			1.	用复杂的方法解决简单的问题。
			2.	用简单但错误的方法解决复杂的问题。
			3.	用不恰当的复杂方法解决复杂的问题。
		★	理想的设计特征：
			1.	最小的复杂度。
			2.	易于维护。
			3.	松散耦合。
			4.	可扩展性。
			5.	可重用性。
			6.	高扇入。
			7.	低扇出。
			8.	可移植性。
			9.	精简性。
			10.	层次性。
			11.	标准技术。
		★	常见的设计模式：
			1.	抽象工厂：通过指定对象组的种类而非单个对象的类型来支持创建一组相关的对象。
			2.	适配器：把一个类的接口转变成为另一个接口。
			3.	桥接：把接口和实现分离开来，使它们可以独立的变化。
			4.	组合：创建一个包含其他同类对象的对象，使得客户代码可以与最上层对象交互而无须考虑所有的细节对象。
			5.	装饰器：给一个对象动态地添加职责，而无须为了每一种可能的职责配置情况去创建特定的子类。
			6.	外观：为没有提供一致接口的代码提供一个一致的接口。
			7.	工厂方法：给特定基类的派生类的实例化时，除了在工厂方法内部之外均无须了解各派生对象的具体类型。
			8.	迭代器：提供一个服务对象来顺序地访问一组元素中的各个元素。
			9.	观察者：使一组相关对象相互同步，方法是让另一个对象负责。
						在这组对象中的任何一个发生改变时，由它把这种变化通知给这个组里的所有对象。
			10. 单件：为有且仅有一个实例的类提供一种全局访问功能。
			11.	策略：定义一组算法或者行为，使得它们可以动态地相互替换。
			12. 模板方法：定义一个操作的算法结构，但是把部分实现的细节留给子类。
		★	要点：
			1.	软件的首要技术使命就是管理复杂度。以简单性作为努力目标的设计方案对此最有帮助。
			2.	简单性可以通过两种方式来获取：一是减少在同一时间所关注的本质性复杂度的量，二是避免生成不必要的偶然的复杂度。
			3.	设计是一种启发式的过程。固执于某一种单一方法会损害创新能力，从而损害你的程序。
			4.	好的设计都是迭代的。你尝试设计的可能性越多，你的最终设计方案就会变得越好。
			5.	信息隐藏是个非常有价值的概念。通过询问“我应该隐藏些什么？”能够解决很多困难的设计问题。
	第6章 可以工作的类
		★	使用ADT的益处：
			1.	可以隐藏实现细节。
			2.	改动不会影响到整个程序。
			3.	让接口能提供更多信息。
			4.	更容易提高性能。
			5.	让程序的正确性更显而易见。
			6.	程序更具自我说明性。
			7.	无须在程序内到处传递数据。
			8.	你可以像在现实世界中那样操作实体。
		★	继承：
			1.	用public继承来实现“是一个”的关系。
			2.	要么使用继承并进行详细说明，要么就不要用它。
			3.	遵循Liskov替换原则。
			4.	确保只继承需要继承的部分。
			5.	不要“覆盖”一个不可覆盖的成员函数。
			6.	把共用的接口、数据及操作放到继承树中尽可能高的位置。
			7.	只有一个实例的类是值得怀疑的。
			8.	只有一个派生类的基类也值得怀疑。
			9.	派生后覆盖了某个子程序，但在其中没做任何操作，这种情况也值得怀疑。
			10.	避免让继承体系过深。
			11.	尽量使用多态，避免大量的类型检查。
			12.	让所有数据都是private（而非protected）。
		★	成员函数和数据成员：
			1.	让类中子程序的数量尽可能少。
			2.	禁止隐式地产生你不需要的成员函数和运算符。
			3.	减少类所调用的不同子程序的数量。
			4.	对其他类的子程序的间接调用要尽可能少。
			5.	应尽量减少类和类之间相互合作的范围。
		★	构造函数
			1.	如果可能，应该在所有的构造函数中初始化所有的数据成员。
			2.	用私有构造函数来强制实现单件属性。
			3.	优先采用深层复本，除非论证可行，才采用浅层复本。
		★	创建类的理由
			1.	对现实世界中的对象建模。
			2.	对抽象对象建模。
			3.	降低复杂度。
			4.	隔离复杂度。
			5.	隐藏实现细节。
			6.	限制变化所影响的范围。
			7.	隐藏全局数据。
			8.	让参数传递更顺畅。
			9.	创建中心控制点。
			10.	让代码更易于重用。
			11.	为程序族做计划。
			12.	把相关操作放到一起。
			13.	实现特定的重构。
		★	要点：
			1.	类的接口应提供一致的抽象。很多问题都是由于违背该原则而引起的。
			2.	类的接口应隐藏一些信息——如某个系统接口、某项设计决策、或一些实现细节。
			3.	包含往往比继承更为可取——除非你要对“是一个”的关系建模。
			4.	继承是一种有用的工具，但它却会增加复杂度，这有违于软件的首要技术使用——管理复杂度。
			5.	类是管理复杂度的首选工具。要在设计类时给予足够的关注，才能实现这一目标。
	第7章 高质量的子程序
		★	创建子程序的正当理由：
			1.	降低复杂度。
			2.	引入中间、易懂的抽象。
			3.	避免代码重复。
			4.	支持子类化。
			5.	隐藏顺序。
			6.	隐藏指针操作。
			7.	提高可移植性。
			8.	简化复杂的布尔判断。
			9.	改善性能。
			10.	确保所有的子程序都很小。
		★	好的子程序名字：
			1.	描述子程序所做的所有事情。
			2.	避免使用无意义、模糊或表述不清的动词。
			3.	不要仅通过数字来形成不同的子程序名字。
			4.	根据需要确定子程序名字的长度。
			5.	给函数命名时要对返回值有所描述。
			6.	给过程起名时使用语气强烈的动词加宾语的形式。
			7.	准确使用对仗词。
			8.	为常用操作建立命名规则。
		★	如何使用子程序参数：
			1.	按照输入——修改——输出的顺序排列参数。
			2.	考虑自己创建in和out关键字。
			3.	如果几个子程序都用了类似的一些参数，应该让这些参数的排列顺序保持一致。
			4.	使用所有的参数。
			5.	把状态或出错变量放在最后。
			6.	不要把子程序的参数用做工作变量。
			7.	在接口中对参数的假定加以说明。
			8.	把子程序的参数个数限制在大约7个以内。
			9.	考虑对参数采用某种表示输入、修改、输出的命名规则。
			10.	为子程序传递用以维持其接口抽象的变量或对象。
			11.	使用具名参数。
			12.	确保实际参数与形式参数相匹配。
		★	要点：
			1.	创建子程序最主要的目的是提高程序的可管理性，当然也有其他一些好的理由。
				其中，节省代码空间只是一个次要原因；提高可读性、可靠性和可修改性等原因都更重要一些。
			2.	有时候，把一些简单的操作写成独立的子程序也非常有价值。
			3.	子程序可以按照其内聚性分为很多类，而你应该让大多数子程序具有功能上的内聚性，这是最佳的一种内聚性。
			4.	子程序的名字是它的质量的指示器。如果名字糟糕但恰如其分，那就说明这个子程序设计得很差劲。
				如果名字糟糕而且又不准确，那么它就反映不出程序是干什么的。
				不管怎样，糟糕的名字都意味着程序需要修改。
			5.	只有在某个子程序的主要目的是返回由其名字所描述的特定结果时，才应该使用函数。
			6.	细心的程序员会非常谨慎地使用宏，而且只在万不得已时才用。
	第8章 防范式编程
		★	防御式编程的主要思想是：
			子程序应该不因传入错误数据而被破坏，哪怕是由其他子程序产生的错误数据。
		★	处理非法数据：
			1.	检查所有来源于外部的数据的值。
			2.	检查子程序所有输入参数的值。
			3.	决定如何处理错误的输入数据。
		★	可以用断言检查：
			1.	输入参数或输出参数的取值处于预期的范围内。
			2.	子程序开始（或者结束）执行时文件或流是处于打开（或关闭）的状态。
			3.	子程序开始（或者结束）执行时，文件或流的读写位置处于开头（或结尾）处。
			4.	文件或流已用只读、只写或可读可写方式打开。
			5.	仅用于输入的变量的没有被子程序所修改。
			6.	指针非空。
			7.	传入子程序的数组或其他容器至少能容纳X个数据元素。
			8.	表已初始化，存储着真实的数值。
			9.	一个经过高度优化的复杂子程序的运算结果和相对缓慢但代码清晰的子程序的运算结果相一致。
		★	使用断言的指导建议：
			1.	用错误处理代码来处理预期会发生的状况，用断言来处理绝不应该发生的状况。
			2.	避免把需要执行的代码放在断言中。
			3.	用断言来注解并验证前条件和后条件。
			4.	对于高健壮性的代码，应该先使用断言再处理错误。
		★	错误处理技术：
			1.	返回中立值。
			2.	换用下一个正确的数据。
			3.	返回与前次相同的数据。
			4.	抵用最接近的合法值。
			5.	把警告信息记录到日志文件中。
			6.	返回一个错误码。
			7.	调用错误处理子程序或对象。
			8.	当错误发生时显示出错消息。
			9.	用最妥当的方式在局部处理错误。
			10.	关闭程序。
		★	异常：
			1.	用异常通知程序的其他部分，发生了不可忽略的错误。
			2.	只在真正例外的情况下才抛出异常。
			3.	不能用异常来推卸责任。
			4.	在恰当的抽象层次抛出异常。
			5.	在异常消息中加入关于导致异常发生的全部信息。
			6.	避免使用空的catch语句。
			7.	了解所用函数库可能抛出的异常。
			8.	考虑创建一个集中的异常报告机制。
			9.	把项目中对异常的使用标准化。
		★	进攻式编程：
			1.	确保断言语句使程序终止运行。不要让程序员养成坏习惯，一碰到已知问题就按回国键把它路过。
				让问题引起的麻烦越大越好，这样它才能被修复。
			2.	安全填充分配到的所有内存，这样可以让你检测内存分配错误。
			3.	安全填充已分配到的所有文件和流，这样可以让你排查出文件格式错误。
			4.	确保每一个case语句中的default分支或else分支都能产生严重错误（比如说让程序终止运行），或者至少让这些错误不会被忽视。
			5.	在删除一个对象之前把它填满垃圾数据。
			6.	让程序把它的错误日志文件用电子邮件发给你，这样你就能了解到在已发布的软件中还发生了哪些错误——如果这对于你所开发的软件适用的话。
		★	确定在产品代码中该保留多少防御式代码：
			1.	保留那些检查重要错误的代码。
			2.	去掉检查细微错误的代码。
			3.	去掉可以导致程序硬性崩溃的代码。
			4.	保留可以让程序稳妥地崩溃的代码。
			5.	为你的技术支持人员记录错误信息。
			6.	确认留在代码中的错误消息是友好的。
		九、要点：
			1.	最终产品代码中对错误的处理方式要比“垃圾进，垃圾出”复杂得多。
			2.	防御式编程技术可以让错误更容易发现、更容易修改，并减少错误对产品代码的破坏。
			3.	断言可以帮助人尽早发现错误，尤其是在大型系统和高可靠性的系统中，以及快速变化的代码中。
			4.	关于如何处理错误输入的决策是一项关键的错误处理决策，也是一项关皱起宾高层设计决策。
			5.	异常提供了一种与代码正常流程角度不同的错误处理手段。
				如果留心使用异常，它可以成为程序员们知识工具箱中的一项有益补充，同时也应该在异常和其他错误处理手段之间进行权衡比较。
			6.	针对产品代码的限制并不适用于开发中的软件。你可以复用这一优势在开发中添加有助于更快地排查错误的代码。
	第9章 伪代码编程过程		
		★	子程序的质量标准：
			1.	检查子程序的接口。
			2.	检查整体的设计质量。
			3.	检查子程序中的变量。
			4.	检查子程序的语句和逻辑。
			5.	检查子程序的布局。
			6.	检查子程序的文档。
			7.	除去冗余的注释。
		★	要点：
			1.	创建类和子程序通常都是一个迭代的过程。在创建子程序的过程中获得的认识常常会反过来影响类的设计。
			2.	每一步完成后都要检查你的工作成果，还要鼓励其他人帮你来检查。
				这样你就会在投入精力最少的时候，用最低的成本发现错误。
第3部分 变量
	第10章 使用变量的一般事项
		★	变量初始化原则：
			1.	在声明变量的时候初始化。
			2.	在靠近变量第一次使用的位置初始化它。
			3.	理想情况下，在靠近第一次使用变量的位置声明和定义该变量。
			4.	在可能的情况下使用final或者const。
			5.	特别注意计数器和累加器。
			6.	在类的构造函数里初始化该类的数据成员。
			7.	检查是否需要重新初始化。
			8.	一次性初始化具名常量：可用执行代码来初始化变量。
			9.	使用编译器设置来自动初始化所有变量。
			10.	利用编译器的警告信息。
			11.	检查输入参数的合法性。
			12.	使用内存访问检查工具来检查错误的指针。
			13.	在程序开始时初始化工作内存。
		★	减少作用域的一般原则：
			1.	在循环开始之前再去初始化该循环里使用的变量，而不是在该循环所属的子程序的开始处初始化这些变量。
			2.	直到变量即将被使用时再为其赋值。
			3.	把相关语句放在一起。
			4.	把相关语句组提取成单独的子程序。
			5.	开始时采用最严格的可见性，然后根据需要扩展变量的作用域。
		★	要点：
			1.	数据初始化过程很容易出错，所以请用本章描述的初始化方法来避免由于非预期的初始值而造成的错误。
			2.	最小化每个变量的作用域。把同一变量的引用点集中在一起。把变量限定在子程序或类的范围之内。避免使用全局数据。
			3.	把使用相同变量的语句尽可能集中在一起。
			4.	早期绑定会减低灵活性，但有助于减少复杂度。晚期绑定可以增加灵活性，同时增加复杂度。
			5.	把每个变量用于唯一的用途。
	第11章 变量名的力量
		★	为布尔变量命名：
			1.	谨记典型的布尔变量名。
			2.	给布尔变量赋予隐含“真/假”含义的名字。
			3.	使用肯定的布尔变量名。
		★	命名规则的好处：
			1.	要求你更多地按规矩行事。
			2.	有助于项目之间传递知识。
			3.	有助于你在新项目中更快速地学习代码。
			4.	有助于减少名字增生。
			5.	弥补编程语言的不足之处。
			6.	强调相关变量之间的关系。
		★	要点：
			1.	好的变量名是提高程序可读性的一项关键要素。对特殊种类的变量，比如循环下标和状态变量，需要加以特殊的考虑。
			2.	名字要尽可能地具体。那些太模糊或者太通用以致于能够用于多种目的的名字通常都是很不好的。
			3.	命名规则应该能够区分局部数据、类数据和全局数据。它们还就当可以区分类型名、具名常量、枚举类型名字和变量名。
			4.	无论做哪种类型项目，你都应该采用某种变量命名规则。你所采用的规则的种类取决于你的程序的规模，以及项目成员的人数。
			5.	现代编程语言很少需要用到缩写。如果你真的要使用缩写，请使用项目缩写词典或者标准前缀来帮助理解缩写。
			6.	代码阅读的次数远远多于编写的次数。确保你所取的名字更侧重于阅读方便而不是编写方便。
	第12章 基本数据类型
		★	整数：
			1.	检查整数除法。
			2.	检查整数溢出。
			3.	检查中间结果溢出。
		★	浮点数：
			1.	避免数量级相差巨大的数之间的加减运算。
			2.	避免等量判断。
			3.	处理传入误差问题。
			4.	检查语言和函数库对特定数据类型的支持。
		★	字符和字符串：
			1.	避免使用神秘字符和神秘字符串。
			2.	避免off-by-one错误。
			3.	了解你的语言和开发环境是如何支持Unicode的。
			4.	在程序生命期中尽早决定国际化/本地化策略。
			5.	如果你知道只需要支持一种文字的语言，请考虑使用ISO 8859字符集。
			6.	如果你需要支持多种语言，请使用Unicode。
			7.	采用某种一致的字符串类型转换策略。
		★	C语言中的字符串：
			1.	注意字符串指针和字符数组之间的差异。
			2.	把C-style字符串的长度声明为CONSTANT + 1。
			3.	用null初始化字符串以避免没有终端的字符串。
			4.	用字符数组取代C中的指针。
			5.	用strncpy()取代strcpy()以避免无终端的字符串。
		★	布尔变量：
			1.	用布尔变量对程序加以文档说明。
			2.	用布尔变量来简化复杂的判断。
			3.	如果需要的话，创建你自己的布尔类型。
		★	枚举类型：
			1.	用枚举类型来提高可读性。
			2.	用枚举类型来提高可靠性。
			3.	用枚举类型来简化修改。
			4.	将枚举类型作为布尔变量的替换方案。
			5.	检查非法数值。
			6.	定义出枚举的第一项和最后一项，以便用于循环边界。
			7.	把枚举类型的第一个元素留做非法值。
			8.	明确定义项目代码编写标准中第一个和最后一个元素的使用规则，并且使用时保持一致。
			9.	警惕给枚举元素明确赋值而带来的失误。
		★	具名常量：
			1.	在数据声明中使用具名常量。
			2.	避免使用文字量，即使是“安全”的。
			3.	用具有适当作用域的变量或类来模拟具名常量。
			4.	统一地使用具名常量。
		★	数组：
			1.	确认所有的数组下标都没有超出数组的边界。
			2.	考虑用容器来取代数组，或者将数组作为顺序化结构来处理。
			3.	检查数组的边界点。
			4.	如果数组是多维的，确认下标的使用使用顺序是正确的。
			5.	提防下标串话。
			6.	在C中结合ARRAY_LENGTH()宏来使用数组。
		★	创建自己类型的原因：
			1.	易于修改。
			2.	避免过多的信息分发。
			3.	增加可靠性。
			4.	弥补语言的不足。
		★	创建自定义数据类型的指导原则：
			1.	给所创建的类型取功能导向的名字。
			2.	避免使用预定义类型。
			3.	不要重定义一个预定义的类型。
			4.	定义替代类型以便于移植。
			5.	考虑创建一个类而不是使用typeded。
		★	要点：
			1.	使用特定的数据类型就意味着要记住适用于各个类型的很多独立的原则。
			2.	如果你的语言支持，创建自定义类型会使得你的程序更容易修改，并更具有描述性。
			3.	当你用typedef或者其等价方式创建一个简单类型的时候，考虑是否更应该创建一个新的类。
	第13章 不常见的数据类型
		★	结构体：
			1.	用结构体来明确数据关系。
			2.	用结构体简化对数据块的操作。
			3.	用结构体来简化参数列表。
			4.	用结构体来减少维护。
		★	使用指针的一般技巧：
			1.	把指针操作限制在子程序或者类里面。
			2.	同时声明和定义指针。
			3.	在与指针分配相同的作用域中删除指针。
			4.	在使用指针之前检查指针。
			5.	先检查指针所引用的变量再使用它。
			6.	用狗牌字段来检测损毁的内存。
			7.	增加明显的冗余。
			8.	用额外的指针变量来提高代码清晰度。
			9.	简化复杂的指针表达式。
			10.	按照正确的顺序删除链表中的指针。
			11.	分配一片保留的内存后备区域。
			12.	粉碎垃圾数据。
			13.	在删除或者释放指针之后把它们设为空值。
			14.	在删除变量之前检查非法指针。
			15.	跟踪指针分配情况。
			16.	编写覆盖子程序，集中实现避免指针问题的策略。
			17.	采用非指针技术。
		★	C++指针：
			1.	理解指针和引用之间的区别。
			2.	把指针用于“按引用传递”参数，把const引用用于“按值传递”参数。
			3.	灵活运用智能指针。
		★	C指针：
			1.	使用显式指针类型而不是默认类型。
			2.	避免强制类型转换。
			3.	遵循参数传递的星号规则。
			4.	在内存分配中使用sizeof()确定变量的大小。
		★	与全局数据有关的常见问题：
			1.	无意间修改了全局数据。
			2.	与全局数据有关的奇异的和令人激动的别名问题。
			3.	与全局数据有关的代码重入问题。
			4.	全局数据阻碍代码重用。
			5.	与全局数据有关的非确定的初始化顺序事宜。
			6.	全局数据破坏了模块化和智力上的可管理性。
		★	要点：
			1.	结构体可以使得程序更简单、更容易理解，以及更容易维护。
			2.	每当你打算使用结构体的时候，考虑采用类是不是会工作得更好。
			3.	指针很容易出错。用访问器子程序或类以及防御式编程实践来保护自己的代码。
			4.	避免用全局变量，不只是因为它们很危险，还是因为你可以用其他更好的方法来取代它们。
			5.	如果你不得不使用全局变量，那么就通过访问器子程序来使用它。
				访问器子程序为你带来全局变量所能带来的一切优点，还有一些额外好处。 
第4部分 语句
	第14章 组织直线型代码
		★	组织语句的简单原则：
			1.	设法组织代码，使依赖关系变得非常明显。
			2.	使子程序名能突显依赖关系。
			3.	利用子程序参数明确显示依赖关系。
			4.	用注释对不清晰的依赖关系进行说明。
			5.	用断言或者错误处理代码来检查依赖关系。
		★	顺序无关物语句：
			1.	指导原则就是就近原则，把相关的操作放在一起。
			2.	使代码易于自上而下地阅读。
			3.	把相关的语句组织在一起。
		★	要点：
			1.	组织直线型代码的最主要原则是按照依赖关系进行排列。
			2.	可以用好的子程序名、参数列表、注释，以及——如果代码足够重要——内务管理变量来让依赖关系变得更明显。
			3.	如果代码之间没有顺序依赖关系，那就设法使相关的语句尽可能地接近。
	第15章 使用条件语句
		★	if语句的指导原则：
			1.	首先写正常代码路径，再处理不常见情况。
			2.	确保对于等量的分支是正确的。
			3.	把正常情况的处理放在if后面而不要放在else后面。
			4.	让if子句后面跟随一个有意义的语句。
			5.	考虑else子句。
			6.	测试else子句的正确性。
			7.	检查if和else子句是不是弄反了。
		★	if-then-else指导原则：
			1.	利用布尔函数调用简化复杂的检测。
			2.	把最常见的情况放在最前面。
			3.	确保所有的情况都考虑到了。
			4.	如果你的语言支持，请把if-then-else语句替换成其他结构。
		★	为case选择最有效的排列顺序：
			1.	把字母顺序或按数字顺序排列各种情况。
			2.	把正常的情况放在前面。
			3.	按执行频率排列case子句。
		★	使用case语句的提示：
			1.	简化每种情况对应的操作。
			2.	不要为了使用case语句而刻意制造一个变量。
			3.	把default子句只用于检查真正的默认情况。
			4.	利用default子句来检测错误。
			5.	在C++和Java里，避免代码执行越过一条case子句的末尾。
			6.	在C++里，在case末尾明确无误地标明需要穿越执行的程序流程。
		★	要点：
			1.	对于简单的if-else语句，请注意if子句和else子句的顺序，特别是用它来处理大量错误的时候，要确认正常的情况是清晰的。
			2.	对于if-then-else语句串和case语句，选择一种最有利于阅读的排序。
			3.	为了捕捉错误，可以使用case语句中的default子句（默认子句），
				或者使用if-then-else语句串中的最后那个else子句。
			4.	各种控制结构并不是生来平等的，请为代码的每个部分先用最合适的控制结构。
	第16章	控制循环
		★	进入循环指导原则：
			1.	只从一个位置进入循环。
			2.	把初始化代码紧放在循环前面。
			3.	用while(true)表示无限循环。
			4.	在适当的情况下多使用for循环。	
			5.	在while循环更适用的时候，不要使用for循环。
		★	处理好循环体：
			1.	用“{”和“}”把循环中的语句括起来。
			2.	避免空循环。
			3.	把循环内务操作要么放在循环的开始，要么放在循环的末尾。
			4.	一个循环只做一件事。
		★	退出循环：
			1.	设法确认循环能够终止。
			2.	使循环终止条件看起来很明显。
			3.	不要为了终止循环而胡乱改动for循环的下标。
			4.	避免出现依赖于循环下标最终取值的代码。
			5.	考虑使用安全计数器。
		★	提前退出循环：
			1.	考虑在while循环中使用break语句而不用布尔标记。
			2.	小心那些有很多break散布其中的循环。
			3.	在循环开始处用continue进行判断。
			4.	如果语言支持，请使用带标号break结构。
			5.	使用break和continue时要小心谨慎。
		★	使用循环变量的指导原则：
			1.	用整数或者枚举类型表示数组和循环的边界。
			2.	在嵌套循环中使用有意义的变量名来提高其可读性。
			3.	用有意义的名字来避免循环下标串话。
			4.	把循环下标变量的作用域限制在本循环内。
		★	循环长度的指导原则：
			1.	循环要尽可能地短，以便能够一目了然。
			2.	把嵌套限制在3层以内。
			3.	把长循环的内容移到子程序里。
			4.	要让长循环格外清晰。
		★	要点：
			1.	循环复杂。保持循环简单将有助于别人阅读你的代码。
			2.	保持循环简单的技巧包括：避免使用怪异的循环、减少嵌套层次、让入口和出口一目了然、把内务操作代码放在一处。
			3.	循环下标很容易被滥用。因此命名要准确，并且要把它们各自仅用于一个用途。
			4.	仔细地考虑循环，确认它在每一种情况下都运行正常，并且在所有可能的条件下都能退出。
	第17章 不常见的控制结构
		★	return语句的指导原则：
			1.	如果能增加可读性，那么就使用return。
			2.	用防卫子名来简化复杂的错误处理。
			3.	减少每个子程序中return的数量。
		★	使用递归的技巧：
			1.	确认递归能够停止。
			2.	使用安全计数器防止出现无穷递归。
			3.	把递归限制在一个子程序内。
			4.	留心栈空间。
			5.	不要用递归去计算阶乘或者斐波纳契数列。
		★	要点：
			1.	多个return可以增强子程序的可读性和可维护性，同时可以避免产生很深的嵌套逻辑。但是使用它的时候要多加小心。
			2.	递归能够很优雅地解决一小部分问题。对它的使用也要倍加小心。
	第18章 表驱动法
		★	使用阶梯技术时候需要注意的一些细节：
			1.	留心端点。
			2.	考虑用二分查找取代顺序查找。
			3.	考虑用索引访问来取代阶梯技术。
			4.	把阶梯表查询操作提取成单独的子程序。
		★	要点：
			1.	表提供了一种复杂的逻辑和继承结构的替换方案。如果你发现自己对某个应用程序的逻辑或者继承树关系感到困惑，
				那么问问自己它是否可以通过一个查询表加以简化。
			2.	使用表的一项关键决策是决定如何去访问表。你可以采取直接访问、索引访问或者阶梯访问。
			3.	使用表的另一项关键决策是决定应该把什么内容放入表中。
	第19章 一般控制问题
		★	隐式地比较布尔值与true和false。
		★	简化复杂的表达式：
			1.	拆分复杂的判断并引入新的布尔变量。
			2.	把复杂的表达式做成布尔函数。
			3.	用决策表代替复杂的条件。
		★	编写肯定形式的布尔表达式：
			1.	在if语句中，把判断条件从否定形式转换为肯定形式，并且互换if和else子句中的代码。
			2.	用狄摩根定理简化否定的布尔判断。
		★	用括号使布尔表达式更清晰：
			1.	用一种简单的计数技巧来使括号对称。
			2.	把布尔表达式全括在括号里面。
		★	空语句：
			1.	小心使用空语句。
			2.	为空语句创建一个DoNothing()预处理宏或者内联函数。
			3.	考虑如果抵用一个非空的循环体，是否会让代码更清晰。
		★	避免深层嵌套的方法：
			1.	通过重复检测条件中的某一部分来简化嵌套的if语句。
			2.	用break块来简化嵌套if。
			3.	把嵌套if转换成一组if-then-else语句。
			4.	把嵌套if转换成case语句。
			5.	把深层嵌套的代码抽取出来放进单独的子程序。
			6.	使用一种更面向对象的方法。
			7.	重新设计深层嵌套的代码。
		★	对减少嵌套层次的技术总结：
			1.	重复判断一部分条件。
			2.	转换成if-then-else。
			3.	转换成case语句。
			4.	把深层嵌套的代码提取成单独的子程序。
			5.	使用对象和多态派分。
			6.	用状态变量重写代码。
			7.	用防卫子句来退出子程序，从而使代码的主要路径更为清晰。
			8.	使用异常。
			9.	完全重新设计深层嵌套的代码。
		★	要点：
			1.	使布尔表达式简单可读，将非常有助于提高你的代码的质量。
			2.	深层次的嵌套使得子程序变得难以理解。所幸的是，你可以相对容易地避免这么做。
			3.	结构化编程是一种简单并且仍然适用的思想：你可以通过把顺序、选择和循环三者组合起来而开发出任何程序。
			4.	将复杂度降低到最低水平是编写高质量代码的关键。
第5部分	代码改善
	第20章 软件质量概述
		★	软件的外在特性指的是该产品的用户所能够感受到的部分：
			1.	正确性。
			2.	可用性。
			3.	效率。
			4.	可靠性。
			5.	完整性。
			6	适应性。
			7.	精确性。
			8.	健壮性。
		★	内在质量特性：
			1.	可维护性。
			2.	灵活性。
			3.	可移植性。
			4.	可重用性。
			5.	可读性。
			6.	可测试性。
			7.	可理解性。
		★	软件质量中的要素：
			1.	软件质量目标。
			2.	明确定义质量保证工作。
			3.	测试策略。
			4.	软件工程指南。
			5.	非正式技术复查。
			6.	正式技术复查。
			7.	外部审查。
		★	开发过程：
			1.	对变更进行控制的过程。
			2.	结果的量化。
			3.	制作原型。
		★	一个有效的软件质量项目的底线，必须包括在开发的所有阶段联合使用多种技术：
			1.	对所有需求、架构以及系统关键部分的设计进行正式检查。
			2.	建模或者创建原型。
			3.	代码阅读或者检查。
			4.	执行测试。
		★	要点：
			1.	开发高质量代码最终并没有要求你付出更多，只是你需要对资源进行重新分配，
				以低廉的成本来防止缺陷出现，从而避免代价高昂的修正工作。
			2.	并非所有的质量保证目标都可以全部实现，明确哪些目标是你希望达到的，
				并就这些目标和团队成员进行沟通。
			3.	没有任何一种错误检测方法能够解决全部问题，测试本身并不是排除错误的最有效方法。
				成功的质量保证计划应该使用多种不同的技术来检查各种不同类型的错误。
			4.	在构建期间应当使用一些有效的质量保证技术，但在这之前，一些具有同样强大功能的质量保证技术也是必不可少的。
				错误发现越早，它与其余代码的纠缠就越少，由此造成的损失也越小。
			5.	软件领域的质量保证是面向过程的。软件开发与制造业不一样，在这里并不存在会影响最终产品的重复的阶段，
				因此，最终产品的质量受到开发软件所有的过程的控制。
	第21章 协同构建
		★	协同构建包括结对编程、正式检查、非正式技术复查、文档阅读，
			以及其他让开发人员共同承担创建代码及其他工作产品责任的技术。
		★	成功运用结对编程的关键：
			1.	用编码规范来支持结对编程。
			2.	不要让结对编程变成旁观。
			3.	不要强迫在简单的问题上使用结对编程。
			4.	有规律地对结对人员和分配的工作任务进行轮换。
			5.	鼓励双方跟上对方的步伐。
			6.	确认两个人都能看到显示器。
			7.	不要强迫程序员与自己关系紧张的人组对。
			8.	避免新手组合。
			9.	指定一个组长。
		★	结对编程的好处：
			1.	与单独开发相比，结对能够使人们在压力之下保持更好的状态。
				结对编程鼓励双方保持代码的高质量，即使在出现了让人不得不飞快地编写代码的压力时仍然如此。
			2.	它能够改善代码质量。代码的可读性和可理解性都倾向于上升至团队中最优秀程序员的水平。
			3.	它能缩短进度时间表。结对往往能够更快地编写代码，代码的错误也更少。
				这样一来，项目组在项目后期花费在修正缺陷的时间会更少。
			4.	它还具有协同构建的其他常见好处，包括传播公司文件，指导初始程序员，
				以及培养集体归属感。
		★	要点：
			1.	协同开发实践往往能比测试发现更多的缺陷，并且更有效率。
			2.	协同开发实践所发现错误的类型通常跟测试所以现的不同，
				这意味着你需要同时使用详查和测试来保证你软件的质量。
			3.	正式检查通过运用核对表、准备工作、明确定义的角色以及对方法的持续改善，
				将缺陷侦测的效率提升至最高。它往往能比走查发现更多的缺陷。
			4.	通常，结对编程拥有和详查相同的成本，并能产生质量相当的代码。
				当需要缩短开发周期的时候，结对编程就非常有价值。相对于单独工作来说，
				有些开发人员更喜欢结对工作。
			5.	正式的检查可以应用在除代码之外的很多工作成果上，例如需求、设计以及测试用例等。
			6.	走查和代码阅读是详查的替代方案。代码阅读更富有弹性，能有效地利用每个人的时间。
	第22章 开发者测试
		★	测试：
			1.	测试的目标与其他开发活动背道而驰，测试的目标是找出错误。
			2.	测试永远不可能彻底证明程序中没有错误。
			3.	测试本身并不能改善软件的质量。
			4.	测试时要求你假设会在代码里面找到错误。
		★	开发者测试的推荐方法：
			1.	对每一项相关的需求进行测试。
			2.	对每一个相关的设计关注点进行测试。
			3.	用基础测试来扩充针对需求和设计的详细测试用例。
			4.	使用一个检查表，其中记录着你在本项目迄今为止所犯的，以及在过去的项目中所犯的错误类型。
		★	测试先行还是测试后行：
			1.	在开始写代码之前先写测试用例，并不比之后再写要多花功能，
				只是调整了一下测试用例编写活动的工作顺序而已。
			2.	假如你首先编写测试用例，那么你将可以更早发现缺陷，同时也更容易修正它们。
			3.	首先编写测试用例，将迫使你在开始写代码之前至少思考一下需求和设计，
				而这往往会催生更高质量的代码。
			4.	在编写代码之前先编写测试用例，能更早地把需求上的问题暴露出来，
				因为对于一个糟糕的需求来说，要写出测试用例是一件困难的事情。
			5.	如果你保存了最初编写的测试用例——这是你应该做的，
				那么先进行测试并非唯一选择，你仍然可以最后再进行测试。
		★	开发者测试的局限性：
			1.	开发者测试倾向于“干净测试”。
			2.	开发者测试对覆盖率有过于乐观的估计。
			3.	开发者测试往往会忽略一些更复杂的测试覆盖率类型。
		★	结构化的基础测试，其思想是，你需要去测试程序中的每一条语句至少一次。
		★	边界值分析的思想就是写一些测试用例来测试边界值条件。
		★	错误的分类：
			1.	大多数错误的影响范围是相当有限的。
			2.	许多错误发生在构建的范畴之外。
			3.	大多数的构建期错误是编程人员的失误造成的。
			4.	让人惊奇的是，笔误是一个常见的问题根源。
			5.	研究程序员所犯错误原因时，错误理解设计这条会经常出现。
			6.	大多数错误都很容易修正。
			7.	总结所在组织中对付错误的经验。
		★	减少测试用例当中的错误量：
			1.	检查你的工作。
			2.	开发软件的时候就要计划好测试用例。
			3.	保留你的测试用例。
			4.	将单元测试纳入测试框架。
		★	一种脚手架是所谓的哑类，待测试的类可以使用它：
			1.	立刻返回控制权，不做任何动作。
			2.	检查传给它的数据。
			3.	输出诊断信息，可能是显示所传入的参数，或者是将信息记录到日志文件中。
			4.	返回用户交互输入的值。
			5.	不管输入是什么都返回一个标准的响应。
			6.  消耗原本分配给真实对象或者真实子程序的时钟周期。
			7.	以某种慢速、臃肿、简单或粗略的方式实现真实对象或者子程序的功能。
		★	另一种脚手架类型，是调用待测试的真实函数的伪造函数：
			1.	用固定的一组输入调用对象。
			2.	提示用户输入，然后根据输入去调用对象。
			3.	从命令行取得参数去调用对象。
			4.	从文件中读入参数，并据此调用对象。
			5.	用一集预先定义的输入数据去多次调用有关的对象。
		★	最后一种脚手架是所谓的哑文件，即真实文件的一个小尺寸版本，它的构成和全尺寸文件一模一样。
		★	测试数据生成器：
			1.	正确设计的随机数据生成器可以产生你意想不到的、不寻常的测试数据组合。
			2.	比起手工构造测试数据，随机数据生成器可以更加彻底地对程序进行测试。
			3.	你可以在很长时间中进一步精炼随机生成的测试用例，以强化所生成的输入的真实性。
			4.	在测试期间，模块化设计就显现出它的优势来了。
			5.	甚至在你修改了被测试的代码之后，你还可以重用测试驱动程序。
		★	系统干扰器：
			1.	内存填充。
			2.	内存抖动。
			3.	选择性内存失败。
			4.	内存访问检查。
		★	自动化测试的好处：
			1.	自动化测试发生的错误的几率比手动测试要小。
			2.	一旦你把一个测试自动化了，那么你只需稍下功夫，就很容易在项目的剩余部分继续实施自动化。
			3.	如果测试是自动进行的，那么就可以频繁地运行，看看新check in的代码是否破坏了原有的程序。
			4.	自动化测试可以提高问题刚产生就被发现的可能性，这可能显著减少分析和修正错误所需要的工作量。
			5.	由于自动化测试能够提升快速发现修改所引入错误的几率，因此它为大规模代码修改提供了一张安全网。
			6.	自动化测试在那些新的、不稳定的技术环境当中特别有价值，因为它提早稀释了环境改变对系统的影响，而非事后补救。
		★	要点：
			1.	开发人员测试是完整测试策略的一个关键部分。
			2.	同编码之后编写测试用例相比较，编码开始之前编写测试用例，工作量和花费的时间差不多，
				但是后者可以缩短缺陷——侦测——调试——修正这一周期。
			3.	即使考虑到了各种可用的测序手段，测试仍然是良好软件质量计划的一部分。
				高质量的开发方法至少和测试一样重要，这包括尽可能减少需求和设计阶段的缺陷。
				在检测错误方面，协同开发的成效至少与测试相当。这些方法所检测错误的类型也各不相同。
			4.	你可以根据各种不同的思路来产生很多测试用例，
				这些思路包括基础测试、数据流分析、边界分析、错误数据类型以及正确数据类型等。
				你还可以通过猜测错误的方式得到更多的测试用例。
			5.	错误往往集中在少数几个容易出错的类和子程序上。找出这部分代码，重新设计和编写它们。
			6.	测试数据本身出错的密度往往比被测试代码还要高。
			7.	自动化测试总体来说是很有用的，也是进行回归测试的基础。
			8.	从长远来看，改善测试过程的最好办法就是将其规范化，并对其进行评估。
				然后用从评估中获得的经验教训来改善这个过程。
	第23章 调试
		★	从错误中得到以下好处：
			1.	理解你正在编写的程序。
			2.	明确你犯了哪种类型的错误。
			3.	从代码阅读者的角度分析代码质量。
			4.	审视自己解决问题的方法。
			5.	审视自己修正缺陷的方法。
		★	运用经典的科学调试方法时，你会经历如下步骤：
			1.	通过可重复的试验收集数据。
			2.	根据相关数据的统计构造一个假说。
			3.	设计一个实验来证明或反证这个假说。
			4.	证明或反证假说。
			5.	根据需要重复进行上面的步骤。
		★	寻找缺陷的有效方法：
			1.	将错误状态稳定下来。
			2.	确定错误的来源。
			3.	修补缺陷。
			4.	对所修补的地方进行测试。
			5.	查找是否还有类似的错误。
		★	寻找缺陷的一些小建议：
			1.	在构造假设时考虑所有的可用数据。
			2.	提炼产生错误的测试用例。
			3.	在自己的单元测试族中测试代码。
			4.	利用可用的工具。
			5.	采用多种不同的方法重现错误。
			6.	用更多的数据生成更多的假设。
			7.	利用否定性测试用例的结果。
			8.	对可能的假设尝试头脑风暴。
			9.	在桌上放一个记事本，把需要尝试的事情逐条列出。
			10.	缩小嫌疑代码的范围。
			11.	对之前出现过缺陷的类和子程序保持警惕。
			12.	检查最近修改过的代码。
			13.	扩展嫌疑代码的范围。
			14.	增量式集成。
			15.	检查常见缺陷。
			16.	同其他人讨论问题。
			17.	抛开问题，休息一下。
		★	蛮力调试：
			1.	对崩溃代码的设计和编码进行彻底检查。
			2.	抛弃有问题的代码，从头开始设计和编程。
			3.	抛弃整个程序，从头开始设计和编程。
			4.	编译代码时生成全部的调试信息。
			5.	在最为苛刻的警告级别中编译代码，不放过任何一个细微的编译器警告。
			6.	全面执行单元测试，并将新的代码隔离起来单独测试。
			7.	开发自动化测试工具，通宵达量地对代码进行测试。
			8.	在调试器中手动地遍历一个大的循环，直到发现错误条件。
			9.	在代码中加入打印、显示和其他日志记录语句。
			10.	用另一个不同的编译器来编译代码。
			11.	在另一个不同的环境里编译和运行程序。
			12.	在代码运行不正确的时候，使用能够产生警告信息的特殊库或者执行环境来链接和运行代码。
			13.	复制最终用户的完整系统配置信息。
			14.	将新的代码分小段进行集成，对每段集成的代码段进行完整的测试。
		★	修正缺陷：
			1.	在动手之前先要理解问题。
			2.	理解程序本身，而不仅仅是问题。
			3.	验证对错误的分析。
			4.	放松一下。
			5.	保存最初的源代码。
			6.	治本，而不是治标。
			7.	修改代码时一定要有恰当的理由。
			8.	一次只做一个改动。
			9.	检查自己的改动。
			10.	增加能暴露问题的单元测试。
			11.	搜索类似的缺陷。
		★	要点：
			1.	调试同整个软件开发的成败息息相关。
			2.	要想成功，系统化地查找和改正错误的方法至关重要。要专注于你的调试工作，
				让每一次测试都能让你朝着正确的方向前进一步。要使用科学的调试方法。
			3.	在动手解决问题之前，要理解问题的根本。
				胡乱猜测错误的来源和随机修改将会让你的程序陷入比刚开始调试时更为糟糕的境地。
			4.	将编译器警告级别设置为最严格，把警告信息所报告的错误都改正。
				如果你忽略了明显的错误，那么要改正那些微妙的错误就会非常麻烦。
			5.	调试工具对软件开发而言是强有力的支持手段。
				找出这些工具并加以应用，当然，请记得在调试的时候开动脑筋。
	第24章 重构
		★	现在的开发方法增强了代码在构造阶段中改变的潜力。
		★	区分软件演化类型的关键，就是程序的质量在这一过程中是提高了还是降低了。
		★	区分软件演化类型的第二个标准，就是这样的演化是源于程序构建过程中的修改，还是维护过程中的修改。
		★	再庞大复杂的代码都可以通过重构加以改善。
		★	重构的理由：
			1.	代码重复。
			2.	冗长的子程序。
			3.	循环过长或嵌套过深。
			4.	内聚性太差的类。
			5.	类的接口未能提供层次一致的抽象。
			6.	拥有太多参数的参数列表。
			7.	类的内部修改往往被局限于某个部分。
			8.	变化导致对多个类的相同修改。
			9.	对继承体系的同样修改。
			10.	case语句需要做相同修改。
			11.	同时使用的相关数据并未以类的方式进行组织。
			12.	成员函数使用其他类的特征比使用自身类的特征还要多。
			13.	过多使用基本数据类型。
			14.	某个类无所事事。
			15.	一系列传递流浪数据的子程序。
			16.	中间人对象无事可做。
			17.	某个类同其他类关系过于亲密。
			18.	子程序命名不恰当。
			19.	数据成员被设置为公有。
			20.	某个派生类仅使用了基类的很少一部分成员函数。
			21.	注释被用于解释难懂的代码。
			22.	使用了全局变量。
			23.	在子程序调用前使用了设置代码，或在调用后使用了收尾代码。
			24.	程序中的一些代码似乎是在将来的某个时候才会用的。
		★	超前设计学学会遭遇很多可预见的问题：
			1.	对这些“超前设计”的代码而言，需求不可能定义得很完备。
			2.	即使程序员对未来需求的前瞻几近完全准确，他也不可能广泛预见未来需求所有的复杂脉络。
			3.	那些使用“超前设计”代码的未来程序员们并不知道自己手中的代码原本是经过“超前设计”的，
				或许他们会期望这些代码能比实际情况表现得更好。
			4.	“超前设计”的代码是画蛇添足，增加了程序的复杂性，带来了额外的测试、
				修补缺陷等工作量，其整体效应主浊拖了项目的后腿。
		★	数据级的重构：
			1.	用具名常量替代神秘数值。
			2.	使变量的名字更为清晰且传递更多信息。
			3.	将表达式内联化。
			4.	用函数来代替表达式。
			5.	引入中间变量。
			6.	用多个单一用途变量代替某个多用途变量。
			7.	在局部用途中使用局部变量而不是参数。
			8.	将基础数据类型转化为类。
			9.	将一组类型码转化为类或枚举类型。
			10.	将一组类型码转换为一个基类及其相应派生类。
			11.	将数组转换为对象。
			12.	把群集封装起来。
			13.	用数据类来代替传统记录。
		★	语句级重构：
			1.	分解布尔表达式。
			2.	将复杂布尔表达式转换成命名准确的布尔函数。
			3.	合并条件语句不同部分中的重复代码片段。
			4.	使用break或return而不是循环控制变量。
			5.	在嵌套 的if-then-else语句中一旦知道答案就立即返回，而不是去赋一个返回值。
			6.	用多态来替代条件语句（尤其是重复的case语句）。
			7.	创建和使用null对象而不是去检测空值。
		★	子程序级重构
			1.	提取子程序或者方法。
			2.	将子程序的代码内联化。
			3.	将冗长的子程序转换为类。
			4.	用简单算法替代复杂算法。
			5.	增加参数。
			6.	删除参数。
			7.	将查询操作从修改操作中独立出来。
			8.	合并相似的子程序，通过参数区分它们的功能。
			9.	将行为取决于参数的子程序拆分开来。
			10.	传递整个对象而非特定成员。
			11.	传递特定成员而非整个对象。
			12.	包装向下转型的操作。
		★	类实现的重构：
			1.	将值对象转化为引用对象。
			2.	将引用对象转化为值对象。
			3.	用数据初始化替代虚函数。
			4.	改变成员函数或成员数据的位置。
			5.	将特殊代码提取为派生类。
			6.	将相似的代码结合起来放置到基类中。
		★	类接口的重构：
			1.	将成员函数放到另一个类中。
			2.	将一个类变成两个。
			3.	删除类。
			4.	去除委托关系。
			5.	去掉中间人。
			6.	用委托代替继承。
			7.	用继承代码委托。
			8.	引入外部的成员函数。
			9.	引入拓展类。
			10.	对暴露在外的成员变量进行封装。
			11.	对于不能修改的类成员，删除相关的Set()成员函数。
			12.	隐藏那些不会在类之外被用到的成员函数。
			13.	封装不使用的成员函数。
			14.	合并那些实现非常类似的基类和派生类。
		★	系统级重构：
			1.	在无法控制的数据创建明确的索引源。
			2.	将单向的类联系改为双向的类联系。
			3.	将双向的类联系改为单向的类联系。
			4.	用Factory Method模式而不是简单地构造函数。
			5.	用异常取代错误处理代码，或者做相反方向的变换。
		★	避免错误地使用重构：
			1.	保存初始代码。
			2.	重构的步伐请小些。
			3.	同一时间只做一项重构。
			4.	把要做的事情一条条列出来。
			5.	设置一个停车场。
			6.	多使用检查点。
			7.	复用编译器警告信息。
			8.	重新测试。
			9.	增加测试用例。
			10.	检查对代码的修改。
			11.	根据重构风险级别来调整重构方法。
		★	不宜重构的情况：
			1.	不要把重构当做先写后改的代名词。
			2.	避免用重构代替重写。
		★	重构策略：
			1.	在增加子程序时进行重构。
			2.	在添加类的时候进行重构。
			3.	在修补缺陷的时候进行重构。
			4.	关注易于出错的模块。
			5.	关注高度复杂的模块。
			6.	在维护环境下，改善你手中正在处理的代码。
			7.	定义清楚干净代码和拙劣代码之间的边界，然后尝试把代码移过这条边界。
		★	要点：
			1.	修改是程序一生都要面对的事情，不仅包括最初的开发阶段，还包括首次发布之后。
			2.	在修改中软件的质量要么改进，要么恶化。软件演化的首要法则就是代码演化就当提升程序的内在质量。
			3.	重构成功之关键在于程序员应学会关注那些标志着代码需要重构的众多的警告或“代码臭味”。
			4.	重构成功的另一要素是程序员应当掌握大量特定的重构方法。
			5.	重构成功的最后要点在于要有安全重构的策略。一些重构方法会比其他重构方法要好。
			6.	开发阶段的重构是提升程序质量的最佳时机，因为你可以立刻让刚刚产生的改变梦想变成现实。
	第25章 代码调整策略
		★	从以下方面来思考效率问题：
			1.	程序需求
			2.	程序的设计
			3.	类和子程序的设计 
			4.	程序同操作系统的交互
			5.	代码编译
			6.	硬件
			7.	代码调整
		★	在设计架构时做先考虑整体性能，然后再为单个的子系统、特征和类设置要达到的资源占用目标：
			1.	设置单独的资源占用目标将使得系统的最终性能可预测。
			2.	把这些目标描述得越明确，越有可能来使子系统满足这些指标。
			3.	你可以设定一些目标，尽管借助这些目标无法直接实现高效率，但从长远来看却能促进效率的提升。
		★	一些无稽之谈：
			1.	在高级语言中，减少代码的行数就可以提升所生成的机器代码的运行速度，或是减少其资源占用——错误！
			2.	特定运算可能比其他的快，代码规模也较小——错误！
			3.	应当随机随地进行优化——错误！
			4.	程序的运行速度同其正确性同等重要——错误！
		★	不成熟的优化的主要缺陷在于它缺乏前瞻性。
		★	常见的低效率之源：
			1.	输入/输出操作。
			2.	分页。
			3.	系统调用。
			4.	解释型语言。
			5.	错误。
		★	代码调整方法总结：
			1.	用设计良好的代码开发软件，从而使程序易于理解和修改。
			2.	如果程序性能很差。
				（1） 保存代码的可运行版本，这样你才能回到“最近的已知正常状态”。
				（2） 对系统进行分析测量，找出热点。
				（3） 判断性能拙劣是源于设计、数据类型或算法上的缺陷，确定是否应该做代码调整。
					  如果不是，请跳回到第一步。
				（4） 对步骤（3）中所确定的瓶颈代码进行调整。
				（5） 每次调整后都对性能提升进行测量。
				（6） 如果调整没有改进代码的性能，就恢复到步骤（1）保存的代码。
			3.	重复步骤2。
		★	要点：
			1.	性能只是软件事件质量的一个方面。通常不是最重要的。
				精细的代码调整也只是实现整体性能的一种方法，通常也不是决定性的。
				相对于代码本身的效率而言，程序的架构、细节设计以及数据结构和算法选择对程序的运行速度和资源占用的影响通常会更大。
			2.	定量测量是实现性能最优化的关键。定量测量需要找出能真正决定程序性能的部分，
				有修改之后，就当通过重复测量来明确修改是提高还是降低了软件的性能。
			3.	绝大多数的程序都有那么一小部分代码耗费了绝大部分的运行时间。
				如果没有测量，你不会知道是哪一部分代码。
			4.	代码调整需要反复尝试，这样才能获得理想的性能提高。
			5.	为性能优化工作做好准备的最佳方式就是在最初阶段编写清晰的代码，
				从而使代码在后续工作中易于理解和修改。
	第26章	代码调整技术	
		★	在知道答案后停止判断。
		★	按照出现频率来调整判断顺序。
			以运行最快和判断结果最有可能为真的判断首先被执行。
		★	用查询表替代复杂表达式。
		★	使用惰性求值。
		★	让循环本身更快：
			1.	将判断外提。
			2.	合并。
			3.	展开。
			4.	尽可能减少在循环内部做的工作。
			5.	哨兵值。
			6.	把最忙的循环放在最内层。
			7.	削减强度。
		★	数据类型的改变同样可以成为减少程序规模和改进执行速度方面的利器。
			1.	使用整型数而不是浮点数。
			2.	数组维度尽可能少。
			3.	尽可能减少数组引用。
			4.	使用辅助索引。
			5.	使用缓存机制。
		★	复杂的表达式往往代价昂贵：
			1.	利用代数恒等式。
			2.	削弱运算强度。
			3.	编译期初始化。
			4.	小心系统函数。
			5.	使用正确的常量类型。
			6.	预先算出结果。
			7.	删除公共子表达式。
		★	预先计算优化程序的几种形式：
			1.	在程序执行之前算出结果，然后把结果写入常量，在编译时赋值。
			2.	在程序执行之前计算结果，然后把它们硬编译在运行时使用的变量里。
			3.	在程序执行之前计算结果，把结果存放在文件中，在运行时载入。
			4.	在程序启动时一次性计算出全部结果，每当需要时去引用。
			5.	尽可能在循环开始之前计算，最大限度地减少循环内部需要做的工作。
			6.	在第一次需要结果时进行计算，然后将结果保存起来以备后用。
		★	代码调整的利器之一就是良好的子程序分解。短小、定义明确的子程序能够代替多处单独执行相同操作的代码，因而能够节省空间。
		★	要点：
			1.	优化结果在不同的语言、编译器和环境下有很大差异。
				如果没有对每一次的优化进行测量，你将无法判断优化到底是帮助还是损害了这个程序。
			2.	第一次优化通常不会是最好的。即使找到了效果很不错的，也不要停下扩大战果的步伐。
			3.	代码调整这一话题有点类似于核能，富有争议，甚至会让人冲动。
				一些人认为代码调整损害了代码可读性和可维护性，他们绝对会将其弃之不用。
				其他人则认为只要有适当的安全保障，代码调整对程序是有益的。
第6部分	系统考虑
	第27章	程序规模对构建的影响
		★	要点：
			1.	随着项目规模的扩大，交流需要加以支持。大多数方法论的关键点都在于减少交流中的问题，而一项方法论的存亡关键也应取决于它能否促进交流。
			2.	在其他条件都相等的时候，大项目的生产率会低于小项目。
			3.	在其他条件都相等的时候，大项目的每千行代码错误率会高于小项目。
			4.	在小项目里的一些看起来“理当如此”的活动在大项目中必须仔细地计划。
				随着项目规模扩大，构建活动的主导地位逐渐降低。
			5.	放大轻量级的方法论要好于缩小重量级的方法论。最有效的办法是使用“适量级”方法论。
	第28章	管理构建
		★	鼓励良好的编码实践的技术
			1.	给项目的每一部分分派两个人。
			2.	逐行复查代码。
			3.	要求代码签名。
			4.	安排一些好的代码示例代价参考。
			5.	强调代码是公有财产。
			6.	奖励好代码。
			7.	一份简单的标准。
		★	配置管理是“系统化地定义项目工件和处理变化，以使项目一直保持其完整性”的实践活动。
		★	控制设计变更的指导原则：
			1.	遵循某种系统化的变更控制手续。
			2.	成组地处理变更请求。
			3.	评估每项变更的成本。
			4.	提防大量的变更请求。
			5.	成立变更控制委员会或者类似机构。
			6.	警惕官僚主义，但也不要因为害怕官僚主义而排斥有效的变更控制。
		★	评估项目的方法：
			1.	建立目标。
			2.	为评估留出时间，并且做出计划。
			3.	清楚地说明软件需求。
			4.	在底层细节层面进行评估。
			5.	使用若干不同的评估方法，并且比较其结果。
			6.	定期做重新评估。
		★	如果你落后了该怎么办：
			1.	希望自己能赶上。
			2.	扩充团队。
			3.	缩减项目范围。
		★	对项目进行度量的两项根本原因：
			1.	任何一种项目特征都是可以用某种方法来度量的，而且总会比根本不度量好得多。
			2.	留心度量的副作用。
			3.	反对度量就是认为最好不要去了解项目中到底在发生什么。
		★	要点：
			1.	好的编码实践可以通过“贯彻标准”或者“使用更为灵活的方法”来达到。
			2.	配置管理，如果应用得当，会使程序员的工作变得更加轻松。特别包括变更控制。
			3.	好的软件评估是一项重大挑战。成功的关键包括采用多种方法、随着项目的开展而修缮评估结果，以及很好地利用数据来创建评估等。
			4.	度量是构建管理成功的关键。你可以采取措施度量项目的任何方面，而这要比根本不度量好得多。
				准确的度量是制定准确的进度表、质量控制和改进开发过程的关键。
	第29章	集成
		★	从周到的集成中，你能预期获得某些下列的益处：
			1.	更容易诊断缺陷。
			2.	缺陷更少。
			3.	脚手架更少。
			4.	花费更少的时间获得第一个能工作的产品。
			5.	更短的整体开发进度表。
			6.	更好的顾客关系。
			7.	增强士气。
			8.	增加项目完成的机会。
			9.	更可靠地估计进度表。
			10.	更准确有现状报告。
			11.	改善代码质量。
			12.	较少的文档。
		★	增量集成的益处：
			1.	易于定位错误。
			2.	及早在项目里取得系统级的成果。
			3.	改善对进度的监控。
			4.	改善客户关系。
			5.	更加充分地测试系统中的各个单元。
			6.	能在更短的开发进度计划内建造整个系统。
		★	增量集成的策略：
			1.	自顶向下集成。
			2.	自底向上集成。
			3.	三明治集成。
			4.	风险导向的集成。
			5.	功能导向的集成。
			6.	T-型集成。
		★	每日构建详情：
			1.	检查失败的构建。
			2.	每天进行冒烟测试。
			3.	让冒烟测试与时俱进。
			4.	将每日构建和冒烟测试自动化。
			5.	成立构建小组。
			6.	仅当有意义时，才将修订加入构建中。
			7.	但是别等太久才将修订加入进来。
			8.	要求开发人员在把他的代码添加到系统之前，进行冒烟测试。
			9.	为即将添加到构建的代码准备一块暂存区。
			10.	惩罚破坏构建的人。
			11.	在早上发布构建。
			12.	即使有压力，也要进行每日构建和冒烟测试。
		★	要点：
			1.	构建的先后次序和集成的步骤会影响设计、编码、测试各类的顺序。
			2.	一个经过充分思考的集成顺序能减少测试的工作量，并使调试变容易。
			3.	增量集成有若干变型，而且——除非项目是微不足道的——任何一种形式的增量集成都比阶段式集成好。
			4.	针对每个特定的项目，最佳的集成步骤通常是自顶向下、自底向上、风险导向及其他集成方法的某种组合。
				T-型集成和竖直分块集成通常都能工作得很好。
			5.	每日构建能减少集成的问题，提升开发人员的士气，并提供非常有用的项目管理信息。
	第30章	编程工具
		★	要点：
			1.	程序员有时会在长达数年的时间里忽视某些最强大的工具，之后才发现并使用之。
			2.	好的工具能让你的日子过得安逸得多。
			3.	下面这些工具已经可用了：编辑、分析代码质量、重构、版本控制、除错、测试、代码调整。
			4.	你能打造许多自己用的专用工具。
			5.	好的工具能减少软件开发中最单调乏味的工作的量，但它不能消除对“编程”的需要，
				虽然它会持续地重塑“编程”的含义。
第7部分	软件工艺
	第31章	布局与风格
		★	格式化的基本原理指出，好的布局凸现程序的逻辑结构。
		★	良好布局的目标：
			1.	准确表现代码的逻辑结构。
			2.	始终如一地表现代码的逻辑结构。
			3.	改善可读性。
			4.	经得起修改。
		★	不要将赋值语句按等号对齐。
		★	每行仅写一条语句。
		★	数据声明的布局：
			1.	每行只声明一个数据。
			2.	变量声明应尽量接近其首次使用的位置。
			3.	合理组织声明顺序。
		★	注释的布局：
			1.	注释的缩进要与相应代码一致。
			2.	每行注释用至少一个空行分开。
		★	文件和程序布局：
			1.	一个文件应只有一个类。
			2.	文件的命名应与类名有关。
			3.	在文件中清晰地分隔各子程序。
			4.	按字母顺序排列子程序。
		★	要点：
			1.	可视化布局的首要任务是指明代码的逻辑组织。评估该任务是否实现的指标包括准确性、一致性、易读性和易维护性。
			2.	外表悦目比起其他指标是最不重要的。然而，如果其他指标都达到了，	
				代码又质量好，那么布局效果看上云也会不错。
	第32章	自说明代码
		★	对于完工的代码，只允许有的三种注释类型：
			1.	代码无法表达的信息。
			2.	目的性注释。
			3.	概述性注释。
		★	何时该用行尾注释：
			1.	行尾注释用于数据声明。
			2.	避免用行尾注释存放维护注记。
			3.	用行尾注释标记块尾。
		★	注释代码段时应注重“为何做”而不是“怎么做”。
		★	要点：
			1.	该不该注释是个需要认真对待的问题。差劲的注释只会浪费时间，帮倒忙；好的注释才有价值。
			2.	源代码就当含有程序大部分的关键信息。只要程序依然在用，
				源代码比其他资料都能保持更新，故而将重要信息融入代码是很有用处的。
			3.	好代码本身就是最好的说明。如果代码太糟，需要大量注释，
				应先试着改进代码，直到无须过多注释为止。
			4.	注释应说出代码无法说出的东西——例如概述或用意等信息。
			5.	有的注释风格需要这么多重复性劳动，应舍弃之，改用易于维护的注释风格。
