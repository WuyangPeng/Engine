Effective C++
（第3版）

官方网站：
http://aristeia.com/BookErrata/ec++3e-errata.html、 http://aristeia.com/MailingList。

★★★★
作者：Scott Meyers
其他书籍：《More Effective C++》、《Effective STL》、《Effective Modern C++》。

知识点 
1.	C++ 基础知识。 

序言
致谢
导读
	术语
	命名习惯
		★	除非我有一个好理由允许构造函数被用于隐式类型转换，否则我会把它声明为explicit。
	关于线程
	TR1和Boost
第1章 自己习惯C++
	条款01 视C++为一个语言联邦
	条款02 尽量以const，enum，inline代替#define
	条款03 尽可能使用const
	条款04 确定对象被使用前已先被初始化
第2章 构造，析构，赋值运算
	条款05 了解C++默默编写并调用哪些函数
	条款06 若不想使用编译器自动生成的函数，就该明确拒绝
	条款07 为多态基类声明virtual析构函数
	条款08 别让异常逃离析构函数
	条款09 绝不在构造和析构过程中调用virtual函数
	条款10 令operator=返回一个reference to *this
	条款11 在operator=中处理“自我赋值”
	条款12 复制对象时勿忘其每一个成分
第3章 资源管理
	条款13 以对象管理资源
	条款14 在资源管理类中小心coping行为
	条款15 在资源管理类中提供对原始资源的访问
	条款16 成对使用new和delete时要采取相同形式
	条款17 以独立语句将newed对象置入智能指针
第4章 设计与声明
	条款18 让接口容易被正确使用，不易被误用
	条款19 设计class犹如设计type
	条款20 宁以pass-by-reference-to-const替换pass-by-value
	条款21 必须返回对象时，别妄想返回其reference
	条款22 将成员变量声明为private
	条款23 字以non-member、non-friend替换member函数
	条款24 若所有参数皆需类型转换，请为此采用non-member函数
	条款25 考虑写出一个不抛出异常的swap函数
第5章 实现
	条款26 尽可能延后变量定义式的出现时间
	条款27 尽量少做转型动作
	条款28 避免返回handles指向对象内部成分
	条款29 为“异常安全”而努力是值得的
	条款30 透彻了解inlining的里里外外
	条款31 将文件间的编译依存关系降至最低
第6章 继承与面向对象设计
	条款32 确定你的public继承塑模出is-a关系
	条款33 避免遮掩继承而来的名称
	条款34 区分接口继承和实现继承
	条款35 考虑virtual函数以外的其他选择
	条款36 绝不重新定义继承而来的non-virtual函数
	条款37 绝不重新定义继承而来的缺省参数值
	条款38 通过复合塑模出has-a或“根据某物实现出”
	条款39 明智而审慎地使用private继承
	条款40 明智而审慎地使用多重继承
第7章 模板与泛型编程
	条款41 了解隐式接口和编译期多态
	条款42 了解typename的双重意义
	条款43 学习处理模板化基类内的名称
	条款44 将与参数无关的代码抽离templates
	条款45 运用成员函数模板接受所有兼容类型
	条款46 需要类型转换时请为模板定义非成员函数
	条款47 请使用traits classes表现类型信息
	条款48 认识template元编程
第8章 定制new与delete
	条款49 了解new-handler的行为
	条款50 了解new和delete的合理替换时机
	条款51 编写new和delete时需固守常规
	条款52 写了placement new 也要写placement delete
第9章 杂项讨论
	条款53 不要轻忽编译器的警告
	条款54 让自己熟悉包括TR1在内的标准程序库
	条款55 让自己熟悉Boost
A 本书之外