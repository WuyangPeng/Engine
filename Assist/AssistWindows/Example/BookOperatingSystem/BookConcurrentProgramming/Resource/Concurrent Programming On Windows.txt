Windows 并发编程指南 （Concurrent Programming On Windows）

官方网站：    
http://www.bluebytesoftware.com/books （已失效）
 
★★
作者：Joe Duffy

序
前言
	本书的结构
	代码要求
	致谢
	作者简介
第一部分 概念
	第1章 概述
		1.1 为什么需要并发
		1.2 程序架构与并发
		1.3 并行的层次
		1.4 为什么不需要并发
		1.5 小结
		延伸阅读
	第2章 同步与时间
		2.1 程序状态的管理
			2.1.1 共享状态与私有状态的区分
			2.1.2 状态机与时间
			2.1.3 独立性
			2.1.4 不变性
		2.2 同步：种类与实现技术
			2.2.1 数据同步
			2.2.2 协作与控制同步
		2.3 小结
		延伸阅读
第二部分 机制
	第3章 线程
		3.1 从高层面上来看线程
			3.1.1 Windows线程是什么
			3.1.2 CLR线程是什么
			3.1.3 显式线程操作及其替代方法
		3.2 线程的诞生与消亡
			3.2.1 线程的创建
			3.2.2 线程终止
			3.2.3 DllMain
			3.2.4 线程局部存储
		3.3 小结
		延伸阅读
	第4章 线程的高级内容
		4.1 线程的状态
			4.1.1 用户态线程栈
			4.1.2 内部数据结构（KTHREAD、ETHREAD和TEB）
			4.1.3 上下文
		4.2 线程的创建过程与终止过程
			4.2.1 线程创建的具体流程
			4.2.2 线程终止的具体流程
		4.3 线程调度
			4.3.1 线程的状态
			4.3.2 优先级
			4.3.3 时间片
			4.3.4 优先级与时间片调整
			4.3.5 睡眠与退让
			4.3.6 挂起
			4.3.7 关联性：优先在某个CPU上运行
		4.4 小结
		延伸阅读
	第5章 Windows内核同步机制
		5.1 基础知识：触发和等待
			5.1.1 为什么要使用内核对象
			5.1.2 在非托管代码中执行等待操作
			5.1.3 托管代码
			5.1.4 异步过程调用
		5.2 内核对象的使用
			5.2.1 互斥体
			5.2.2 信号量
			5.2.3 互斥体/信号量使用示例：阻塞/有界的队列
			5.2.4 自动重置事件和手动重置事件
			5.2.5 等待定时器
			5.2.6 触发对象与自动等待
			5.2.7 内核对象的调试
		5.3 小结
		延伸阅读
	第6章 数据同步与控制同步
		6.1 互斥
			6.1.1 Win32临界区
			6.1.2 CLR锁
		6.2 读/写锁（RWL）
			6.2.1 WindowsVista中的轻量级读/写锁
			6.2.2 .NEI框架中的轻量级读/写锁
			6.2.3 .NET框架中原来的读/写锁
		6.3 条件变量
			6.3.1 WindowsVista条件变量
			6.3.2 .NET框架的Monitor
			6.3.3 被守护区域
		6.4 小结
		延伸阅读
	第7章 线程池
		7.1 线程池的基本知识
			7.1.1 三种方式：WindowsVista、Windows遗留代码以及CLR
			7.1.2 通用功能
		7.2 Windows线程池
			7.2.1 WindowsVista线程池
			7.2.2 遗留的Win32线程池
		7.3 CLR线程池
			7.3.1 工作项
			7.3.2 I/O完成端口
			7.3.3 定时器
			7.3.4 注册等待
			7.3.5 记住（再次提醒）：你并不拥有这些线程
			7.3.6 线程池的线程管理
			7.3.7 调试
			7.3.8 案例分析：优先级分层以及在线程池之上的隔离性
		7.4 在使用线程池时的性能
		7.5 小结
		延伸阅读
	第8章 异步编程模型
		8.1 异步编程模型（APM）
			8.1.1 汇集：四种方式
			8.1.2 实现IAsyncResult
			8.1.3 在.NET框架的哪些地方使用了APM
			8.1.4 ASP.NET异步页
		8.2 基于事件的异步模式
			8.2.1 基础知识
			8.2.2 支持取消
			8.2.3 支持进度报告以及增量结果
			8.2.4 在.NET框架的哪些地方将使用EAP
		8.3 小结
		延伸阅读
	第9章 纤程
		9.1 纤程简介优点与缺点
		9.2 纤程的使用
			9.2.1 创建新的纤程
			9.2.2 将线程转换为纤程
			9.2.3 判断线程是否为纤程
			9.2.4 纤程间的切换
			9.2.5 删除纤程
			9.2.6 切换当前线程的示例
		9.3 与纤程相关的其他主题
			9.3.1 纤程局部存储
			9.3.2 线程关联性
			9.3.3 案例分析：纤程与CLR
		9.4 构建用户态的调度器
			9.4.1 实现
			9.4.2 关于栈阻塞与无栈阻塞
		9.5 小结
		延伸阅读
第三部分 技术
	第10章 内存模型与无锁编程
		10.1 内存加载与存储等操作的重新排序
			10.1.1 实际运行的顺序并非总是编写的顺序
			10.1.2 将临界域作为栅栏
			10.1.3 数据依赖性及其对重排的影响
		10.2 硬件原子性
			10.2.1 普通加载指令和存储指令的原子性
			10.2.2 互锁操作
		10.3 内存一致性模型
			10.3.1 硬件内存模型
			10.3.2 内存栅栏
			10.3.3 .NET内存模型
			10.3.4 无锁编程
		10.4 低锁代码的示例
			10.4.1 延迟初始化与双重检查锁定
			10.4.2 无阻塞栈和ABA问题
			10.4.3 重新回顾Dekker的算法
		10.5 小结
		延伸阅读
	第11章 并发的危害
		11.1 正确性危害
			11.1.1 数据竞争
			11.1.2 递归与重入
			11.1.3 锁与进程关闭
		11.2 活跃性危害
			11.2.1 死锁
			11.2.2 遗失的唤醒
			11.2.3 活锁
			11.2.4 锁护送效应
			11.2.5 “蜂拥”现象
			11.2.6 两步舞
			11.2.7 优先级反转与饥饿
		11.3 小结
		延伸阅读
	第12章 并行容器
		12.1 细粒度锁定
			12.1.1 数组
			12.1.2 FIFO队列
			12.1.3 链表
			12.1.4 字典（散列表）
		12.2 无锁
			12.2.1 无锁FIFO队列
			12.2.2 工作密迁队列
		12.3 协作式容器
			12.3.1 生产者/消费者数据结构
			12.3.2 通过栅栏来分阶段计算
		12.4 小结
		延伸阅读
	第13章 数据并行与任务并行
		13.1 数据并行
		13.2 任务并行
			13.2.1 分支/合并算法
			13.2.2 数据流并行（Future抽象与Promise抽象）
			13.2.3 递归
			13.2.4 流水线
			13.2.5 查找
		13.3 基于消息的并行
		13.4 一些共同问题
			13.4.1 并发的异常
			13.4.2 取消
		13.5 小结
		延伸阅读
	第14章 性能与可伸缩性
		14.1 并行硬件架构
			14.1.1 SMP、CMP与HT
			14.1.2 超标量执行
			14.1.3 内存的层次结构
			14.1.4 Visual Studio中的性能分析工具
		14.2 加速比：并行代码与串行代码
			14.2.1 决定“采用并行”
			14.2.2 测量并行带来的性能提升
			14.2.3 Amdahl定律
			14.2.4 关键路径以及负载不均衡
			14.2.5 垃圾收集与可伸缩性
		14.3 自旋等待
			14.3.1 如何在Windows上正确地自旋
			14.3.2 纯自旋锁
			14.3.3 Mellor-Crummey-Scott（MCS）锁
		14.4 小结
		延伸阅读
第四部分 系统
	第15章 输入与输出
		15.1 重叠I/O
			15.1.1 重叠对象
			15.1.2 Win32异步：I/O
			15.1.3 .NET框架的异步I/O
		15.2 I/O取消
			15.2.1 当前线程的异步I/O取消
			15.2.2 其他线程上的同步I/O取消
			15.2.3 任意线程的异步I/O取消
		15.3 小结
		延伸阅读
	第16章 图形用户界面
		16.1 GUI线程模型
			16.1.1 单线程套间（STA）
			16.1.2 响应度：它是什么
		16.2.NET异步GUI功能
			16.2.1.NET的GUI框架
			16.2.2 同步上下文
			16.2.3 异步操作
			16.2.4 一个方便的类：BackgroundWorker
		16.3 小结
		延伸阅读
第五部分 附录
	附录A 为.NET并发程序设计可重用的库
	附录B .NET的并行扩展