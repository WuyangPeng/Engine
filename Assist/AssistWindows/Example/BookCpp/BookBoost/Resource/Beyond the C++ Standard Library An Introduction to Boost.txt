超越C++标准库：Boost库导论（Beyond the C++ Standard Library:An Introduction to Boost）

官方网站：
http://www.boost.org/ 、 https://www.artima.com/cppsource 。

★
作者：Bjorn Karlsson

知识点 
1.	C++ boost库基础知识。 

序
前言
本书组织结构
Boost库简介
	字符串和文本处理
	数据结构、容器、迭代器和算法 
	函数对象和高级编程
	泛型编程和模板元编程
	数学和数值计算
	输入/输出
	综合
第Ⅰ部分 通用库
	第1章 Smart_ptr库
		1.1 Smart_ptr库如何改进程序
　　	1.2 何时需要智能指针
　　	1.3 Smart_ptr库如何适用于标准库
　　	1.4 智能指针scoped_ptr
			1.4.1 头文件
			1.4.2 成员
			1.4.3 自由函数
			1.4.4 使用方法
			1.4.5 不需要手动删除
			1.4.6 和智能指针auto_put几乎一样
			1.4.7 智能指针socped_ptr和pimpl惯用法
			1.4.8 智能指针socped_ptr不同于const auto_ptr
			1.4.9 小结
　　	1.5 智能指针scoped_array
　　	1.6 智能指针shared_ptr
			1.6.1 头文件
			1.6.2 成员
			1.6.3 自由函数
			1.6.4 使用方法
			1.6.5 回顾Pimpl惯用法
			1.6.6 智能指针shared_ptr和标准库容器
			1.6.7 智能指针shared_ptr和其他资源
			1.6.8 使用自定义删除工具的安全性
			1.6.9 从this创建智能指针shared_ptr
			1.6.10 小结
		1.7 智能指针shared_array
		1.8 智能指针intrusive_ptr
			1.8.1 头文件
			1.8.2 成员
			1.8.3 自由函数
			1.8.4 使用方法
			1.8.5 提供引用计数器
			1.8.6 把this用作智能指针
			1.8.7 支持不同的引用计数器
			1.8.8 小结
		1.9 智能指针weak_ptr
			1.9.1 头文件
			1.9.2 成员 
			1.9.3 使用方法
			1.9.4 一个常见问题
			1.9.5 两种从weak_ptr创建shared_ptr的惯用法
			1.9.6 小结
		1.10 Smart_ptr库小结
	第2章 Conversion库
		2.1 Conversion库如何改进程序
		2.2 polymorphic_cast转型函数
			2.2.1 头文件
			2.2.2 使用方法
			2.2.3 向下转型和交叉转型
			2.2.4 dynamic_cast和polymorphic_cast的对比 
			2.2.5 polymorphic_cast并不总是正确的选择
			2.2.6 小结
		2.3 polymorphic_downcast转型函数
			2.3.1 头文件
			2.3.2 使用方法
			2.3.3 小结
		2.4 numeric_cast转型函数
			2.4.1 头文件
			2.4.2 使用方法
			2.4.3 将较大的类型赋值给较小的类型
			2.4.4 特殊情况：目标类型是无符号整数
			2.4.5 有符号和无符号整数类型的混用
			2.4.6 浮点类型
			2.4.7 小结
		2.5 lexical_cast转型函数
			2.5.1 头文件
			2.5.2 使用方法
			2.5.3 使lexical_cast函数工作的方法
			2.5.4 用lexical_cast函数进行泛型编程
			2.5.5 使类适用于lexical_cast函数
			2.5.6 小结
		2.6 Conversion库小结
	第3章 Utility库
		3.1 Utility库如何改进程序
		3.2 BOOST_STATIC_ASSERT断言
			断言
			3.2.1 头文件
			3.2.2 使用方法
			3.2.3 函数作用域中的BOOST_STATIC_ASSERT
			3.2.4 小结 
		3.3 checked_delete函数
			3.3.1 头文件
			3.3.2 使用方法
			3.3.3 到底发生了什么问题
			3.3.4 使用checked_delete解决问题
			3.3.5 小结
		3.4 noncopyable类
			3.4.1 头文件
			3.4.2 使用方法
			3.4.3 使类无法复制的方法
			3.4.4 使用noncopyable类
			3.4.5 记住Big Three定律
			3.4.6 小结
		3.5 addressof函数
			3.5.1 头文件
			3.5.2 使用方法
			3.5.3 快速了解一下怀有恶意的人
			3.5.4 其他问题的迅速解决方法
			3.5.5 小结
		3.6 enable_if函数
			3.6.1 头文件
			3.6.2 使用方法
			3.6.3 小结
		3.7 Utility库小结
	第4章 Operators库
		4.1 Operators库如何改进程序
		4.2 Operators库如何适用于标准库
		4.3 Operators库
			4.3.1 头文件
			4.3.2 解引用运算符
			4.3.3 复合算术运算符
		4.4 使用方法
			4.4.1 对比较运算符的支持
			4.4.2 Barton-Nackmann技巧
			4.4.2 严格弱序
			4.4.4 避免对象膨胀
			4.4.5 运算符和各种类型
			4.4.6 相等和等价之间的差别
			4.4.7 算术类型
			4.4.8 该使用运算符时再使用运算符
			4.4.9 理解Operators库的工作机制
			4.4.10 其他内容
		4.5 Operators库小结
	第5章 Regex库
		5.1 Regex库如何改进程序
		5.2 Regex库如何适用于标准库
		5.3 Regex库
			5.3.1 头文件
			5.3.2 成员
			5.3.3 自由函数
		5.4 使用方法
			5.4.1 输入验证
			5.4.2 查找
			5.4.3 替换
			5.4.4 使用者常见的误解
			5.4.5 关于重复和贪婪
			5.4.6 regex_iterator简介
			5.4.7 通过regex_token_iterator
			5.4.8 更多的正则表达式
			5.4.9 无效的正则表达式
		5.5 Regex库小结
第Ⅱ部分 容器和数据结构
	第6章 Any库
		6.1 Any库如何改进程序
		6.2 Any库如何适用于标准库
		6.3 Any库
			6.3.1 头文件
			6.3.2 成员
			6.3.3 自由函数
			6.3.4 异常
		6.4 使用方法
			6.4.1 存储任意的类型
			6.4.2 属性类
			6.4.3 any类其他成员函数的用法
			6.4.4 在any中存储指针
			6.4.5 一个更好的办法——使用智能指针shared_ptr
			6.4.6 没有输入和输出运算符的原因
			6.4.7 通过any_out增加对输出的支持
			6.4.8 谓词
			6.4.9 非空值计数
			6.4.10 从容器中提取特定类型的元素
			6.4.11 使用谓词和提取器
			6.4.12 适应标准库适配器的需求
		6.5 Any库小结
	第7章 Variant库
		7.1 Variant库如何改进程序
		7.2 Variant库如何适用于标准库
		7.3 Variant库
			7.3.1 头文件
			7.3.2 成员 
		7.4 使用方法
			7.4.1 使用Variant
			7.4.2 泛型访问器
			7.4.3 二元访问器
			7.4.4 其他功能
		7.5 Variant库小结
	第8章 Tuple库
		8.1 Tuple库如何改进程序
		8.2 Tuple库如何适用于标准库
		8.3 Tuple库
			8.3.1 头文件
			8.3.2 成员
			8.3.3 自由函数
			8.3.4 关系运算符
		8.4 使用方法
			8.4.1 元组的构造
			8.4.2 访问tuple的元素
			8.4.3 tuple的赋值和复制构造 
			8.4.4 tuple的比较
			8.4.5 将tuple的元素绑定到变量
			8.4.6 tuple的流操作
			8.4.7 关于tuple的更多知识
			8.4.8 tuple和for_each
		8.5 Tuple库小结
第Ⅲ部分 函数对象和高阶编程
	第9章 Bind库
		9.1 Bind库如何改进程序
		9.2 Bind库如何适用于标准库
		9.3 Bind库
		9.4 使用方法
			9.4.1 调用成员函数
			9.4.2 绑定的工作机制
			9.4.3 占位符和参数的更多介绍
			9.4.4 动态排序标准
			9.4.5 函数组合：第Ⅰ部分
			9.4.6 函数组合：第Ⅱ部分
			9.4.7 在bind表达式中选择值语义还是指针语义
			9.4.8 虚函数同样可以绑定
			9.4.9 绑定到成员变量
			9.4.10 绑定还是不绑定
			9.4.11 让绑定器处理状态
			9.4.12 Boost.Bind和Boost.Function之间的配合
		9.5 Bind库小结
	第10章 Lambda库
		10.1 Lambda库如何改进程序
		10.2 Lambda库如何适用于标准库
		10.3 Lambda库
		10.4 使用方法
			10.4.1 一个简单的开始
			10.4.2 当运算符不够使用时使用绑定
			10.4.3 如果不喜欢_1、_2和_3占位符，如何重命名它们
			10.4.4 常量和变量的命名
			10.4.5 ptr_fun和mem_fun何去何从
			10.4.6 无需<functional>的算术操作
			10.4.7 编写可读的谓词
			10.4.8 使函数对象适用于Boost.Lambda库
			10.4.9 lambda表达式中的控制结构
			10.4.10 lambda表达式中的转型 
			10.4.11 构造和析构
			10.4.12 异常的抛出和捕获
		10.5 Lambda库小结
	第11章 Function库
		11.1 Function库如何改进程序
		11.2 Function库如何适用于标准库
		11.3 Function库
			11.3.1 头文件
			11.3.2 使用首选语法的声明 
			11.3.3 使用兼容语法的声明
			11.3.4 成员 
		11.4 使用方法
			11.4.1 回调的基础
			11.4.2 类成员函数
			11.4.3 带状态的函数对象
			11.4.4 在Boost.Function中使用Boost.Bind
			11.4.5 在Boost.Function中使用Boost.Lambda
			11.4.6 代价的考虑
			11.4.7 幕后的细节
		11.5 Function库小结
	第12章 Signals库
		12.1 Signals库如何改进程序
		12.2 Signals库如何适用于标准库
		12.3 Signals库
			12.3.1 头文件
			12.3.2 类型
			13.3.3 成员 
		12.4 使用方法
			12.4.1 插槽分组
			12.4.2 带参数的signal
			12.4.3 对结果进行组合
			12.4.4 signal永远不能复制 
			12.4.5 管理连接
			12.4.6 使用Bind和Lambda创建插槽
		12.5 Signals库小结