C++ 编程基础（C++ A Dialog）

官方网站 
http://steveheller.com/ （已失效）、http://www.steveheller.org/

○
作者：Steve Heller

联系作者：
steve@steveheller.com

知识点 
1.	C++基础知识。
2.	C++基础知识练习。

代码 
1.  书籍代码。

前言
序言
	致谢
	关于本书附带光盘
来自新手的信
	C++中的更多奇遇
关于作者
第1章 编程简介
	1.1 定义
		1.1.1 如何编写程序
	1.2 起步
		1.2.1 继续
第2章 硬件基础知识
	2.1 定义
	2.2 本章目标
	2.3 主机箱内部的秘密
		2.3.1 磁盘
		2.3.2 17年间的改进
		2.3.3 随机存取存储器
		2.3.4 存储地址
		2.3.5 中央处理器
		2.3.6 调整缓存如何改进性能
		2.3.7 寄存器如何改进性能
	2.4 二进制记数系统
		2.4.1 有符号变量
		2.4.2 十六进制记数法简介
	2.5 习题
	2.6 使用16位寄存器名称
		2.6.1 再次了解分级存储器体系结构
		2.6.2 使用寄存器存在的优点和缺点
		2.6.3 寄存器对程序大小的影响
		2.6.4 预先将指令读入内存
	2.7 本章回顾
	2.8 小结
	2.9 习题答案
第3章 编程基础知识
	3.1 定义
	3.2 本章目标
	3.3 快而准的计算
		3.3.1 “计算机难题”的实际原因
		3.3.2 非数值变量
	3.4 编译程序
	3.5 CPU如何存储和操作内存中的数据
	3.6 内存中数据的布局
	3.7 习题
		3.7.1 运行编译程序
		3.7.2 执行该程序段
	3.8 char类型和string类型
	3.9 using、namespace和std
	3.10 int main()
		3.10.1 其他名称的字节
		3.10.2 非打印字符
	3.11 习题（第2套）
	3.12 输入/输出
	3.13 改变执行流程
	3.14 while循环
	3.15 习题（第3套）
	3.16 第一个比较实用的程序
		3.16.1 苏珊尝试独立编写南瓜程序
		3.16.2 尝试自己编写该程序
	3.17 习题（第4套）
	3.18 本章回顾
	3.19 小结
	3.20 习题答案
第4章 其他基础知识
	4.1 本章目标
	4.2 算法
		4.2.1 苏珊发现一个错误
		4.2.2 程序的简单更改也能引起错误
	4.3 颁发任意数量的奖项
		4.3.1 vector数据类型
		4.3.2 Vec数据类型
		4.3.3 基1索引示例
	4.4 下标变量
	4.5 选择排序
		4.5.1 选择排序详解
		4.5.2 假设有时是危险的
		4.5.3 为什么使用Vec类型而不是vector类型
		4.5.4 未初始化变量
	4.6 程序故障
		4.6.1 为什么需要显式初始化变量
		4.6.2 防止异常数据输入
	4.7 本章回顾
	4.8 习题
	4.9 小结
	4.10 习题答案
第5章 函数文化
	5.1 定义
	5.2 本章目标
	5.3 模块与函数
		5.3.1 使用函数的示例
		5.3.2 给主调函数返回数据
		5.3.3 函数参数
		5.3.4 Average函数如何工作
	5.4 使用函数
	5.5 软件是虚拟计算机
		5.5.1 目标文件
		5.5.2 操作系统工具程序
		5.5.3 库模块
		5.5.4 为什么不是自动初始化所有变量
		5.5.5 嵌套函数
		5.5.6 返回到主调函数
		5.5.7 栈中数据的布置
	5.6 变量的作用域
		5.6.1 自动地址分配和静态地址分配 
		5.6.2 作用域限定运算符
	5.7 全局变量的不足
		5.7.1 使用很原始的BASIC语言
		5.7.2 用BASIC解决问题
		5.7.3 作用域定义namespace
	5.8 关于使用栈的更多信息
	5.9 本章回顾
	5.10 习题
	5.11 小结
	5.12 习题答案
第6章 库存管理
	6.1 定义
	6.2 本章目标
	6.3 自定义数据类型
	6.4 StockItem类
	6.5 更多的定义
	6.6 具体数据类型
	6.7 class作用域
	6.8 StockItem类接口的更多信息
		6.8.1 在头文件中引用标准类库标识符
		6.8.2 需要多个构造函数
		6.8.3 用Vec类的变量处理大量StockItem变量
	6.9 使用标准类库
		6.9.1 StockItem接口的第二个版本
	6.10 引用参数
		6.10.1 栅栏柱错误
		6.10.2 另一种可能的库存管理事务
		6.10.3 试图访问private成员变量
		6.10.4 使程序更具用户友好性
		6.10.5 Inventory类
		6.10.6 使用空对象
	6.11 检查库存管理中的误放商品
	6.12 本章回顾
	6.13 习题
	6.14 小结
	6.15 习题答案
第7章 创建自己的string类
	7.1 本章目标
	7.2 C字符串直接量与string类的变量
		7.2.1 指针
	7.3 用new和delete进行动态内存分配
	7.4 从C字符串构造string类对象
		7.4.1 调用string(char*)构造函数
	7.5 赋值运算符
	7.6 解决赋值运算符问题
	7.7 引用参数的const修饰符
	7.8 调用operator=
		7.8.1 关键字this
		7.8.2 内存分配错误
		7.8.3 有关operator=的更多信息
		7.8.4 析构函数
	7.9 本章回顾
	7.10 习题
	7.11 小结
	7.12 习题答案
第8章 继续开发自己的string类
	8.1 本章目标
		8.1.1 为什么需要给operator=提供引用参数
		8.1.2 过早析构
		8.1.3 编译程序产生临时变量
	8.2 string复制构造函数
		8.2.1 屏幕输出
		8.2.2 数组
		8.2.3 数组和指针的等效性
		8.2.4 char类型的变量是很短的数值变量
		8.2.5 数组上溢
	8.3 有关private访问说明符的更多信息
		8.3.1 封装的好处
	8.4 本章初回顾
	8.5 给string类增加其他功能
		8.5.1 实现运算符operator<
		8.5.2 比较算法的细节
		8.5.3 “逻辑与”运算符
		8.5.4 比较的其他可能结果
		8.5.5 使用标准类库函数来简化代码
		8.5.6 实现operator==
		8.5.7 深入研究实现和声明 
		8.5.8 对用户自定义类型使用cout
		8.5.9 cout如何处理预存类型
		8.5.10 编写与标准类库兼容的operator<<
		8.5.11 friend关键字
		8.5.12 从istream对象读取string类型值
		8.5.13 初始化和赋值
		8.5.14 memset标准类库函数
	8.6 本章再回顾
	8.7 习题
	8.8 小结
	8.9 习题答案
第9章 继承
	9.1 定义
	9.2 本章目标
		9.2.1 使用继承的两个理由
	9.3 库存管理
	9.4 给Inventory类添加ReorderItems函数
	9.5 添加有效期
		9.5.1 通过继承减少维护
		9.5.2 关于真正面向对象设计的注释
		9.5.3 过载基类函数
	9.6 protected访问说明符
		9.6.1 public继承
		9.6.2 private继承
	9.7 静态成员函数
	9.8 stream类
	9.9 stringstream进阶
		9.9.1 控制输出格式 
		9.9.2 使用iostream操作程序
		9.9.3 基类构造函数
		9.9.4 DatedStockItem类的Reorder函数
	9.10 本章回顾
	9.11 本章习题
	9.12 小结
第10章 多态性
	10.1 定义
	10.2 本章目标
	10.3 多态性简介
		10.3.1 关键字virtual
		10.3.2 指针用于多态性引起的问题
		10.3.3 对I/O使用虚函数
		10.3.4 指针引用
	10.4 习题（第一套）
	10.5 多态对象
	10.6 更多定义 
	10.7 为什么需要多态对象
		10.7.1 使用基类指针
	10.8 实现安全的多态性
	10.9 重新实现新版StockItem的标准成员函数
	10.10 在构造过程中避免无限回归
	10.11 引用计数
	10.12 共享工人对象	
		10.12.1 析构函数调用次序
		10.12.2 跟踪多态对象的析构
	10.13 为什么在StockItem中需要m_Count
		10.13.1 执行main之前的代码
	10.14 本章回顾
	10.15 习题（第二套）
	10.16 小结
第11章 家庭物品清单项目
	11.1 定义
	11.2 本章目标
	11.3 家庭物品清单项目的数据项	
		11.3.1 选择商品类别
	11.4 再次使用“经理/工人”这个惯用语
		11.4.1 多态对象之间的异同
	11.5 向类用户隐藏不必要的信息
		11.5.1 最初的HomeItem测试程序
		11.5.2 在需要时创建局部变量
		11.5.3 索引变量的作用域
		11.5.4 值“0”的奇特点之一
		11.5.5 通过虚函数重用代码
		11.5.6 重复调用resize函数引起的问题
	11.6 将元素数量存储在文件中
		11.6.1 正确处理文件尾条件
	11.7 有计划地创建数据文件
		11.7.1 比较两个stream对象
		11.7.2 继承虚函数的实现
	11.8 增加编辑记录的能力
		11.8.1 operator>>的新实现
		11.8.2 减少代码重复
		11.8.3 enum类型
		11.8.4 自动从enum类型转换
		11.8.5 HomeItem::Read函数的实现
		11.8.6 HomeItemBasic::ReadInteractive函数的实现
		11.8.7 HomeItemBasic::ReadFromFile函数的实现
		11.8.8 HomeItemBasic::Edit函数的实现
		11.8.9 HomeItemBasic::FormattedDisplay函数的实现 
		11.8.10 HomeItemBasic::EditField函数的实现
	11.9 HomeItemMusic的新成员函数
		11.9.1 跟踪下一个字段号
	11.10 本章回顾
	11.11 习题
	11.12 小结
第12章 家庭物品清单项目深入开发
	12.1 定义
	12.2 本章目标
	12.3 扩充string类的功能
	12.4 如何实现新的string类功能
		12.4.1 选择设计xstring类的理由
		12.4.2 新的xstring类接口
	12.5 包含保护
		12.5.1 xstring类的构造函数
		12.5.2 自动从标准string类转换
		12.5.3 防止意外由0初始化
		12.5.4 explicit关键字
	12.6 xstring类的实现
		12.6.1 xstring类的更多设计 
	12.7 不区分大小写的搜索
	12.8 通过子串搜索
	12.9 将它集合到一起
		12.9.1 第1次测试：修改请求和问题报告
		12.9.2 第2次测试：修改要求和问题报告
		12.9.3 第3次测试：修改请求和问题报告
		12.9.4 第4次测试：修改请求和问题报告
		12.9.5 第5次测试：修改请求和问题报告
	12.10 到底怎样进行软件开发
	12.11 本章回顾
	12.12 小结
第13章 分析家庭物品清单项目
	13.1 定义
	13.2 本章目标
	13.3 家庭物品清单程序的最终版本
	13.4 使用名字空间来组织通用函数
		13.4.1 使用名字空间的优点
		13.4.2 默认参数
	13.5 HomeUtility名字空间中的函数
		13.5.1 从函数返回多个值
		13.5.2 读取日期字段
		13.5.3 从行定向文件读取数值数据
		13.5.4 权衡便利性与错误控制
		13.5.5 单键数据输入
		13.5.6 在屏幕上显示键入字符
		13.5.7 获得数值的其他部分
		13.5.8 清除屏幕上的部分内容
		13.5.9 HomeUtility::SelectItem的实现
	13.6 核对物品清单
		13.6.1 对物品清单进行排序
		13.6.2 按类别选择
	13.7 对HomeItem类进行最后处理
	13.8 我们是否开心
	13.9 本章回顾
	13.10 习题
	13.11 小结
附录
	附录A 遗留问题总结
		运算符优先级
		另一种自然数据类型
		小结
	附录B 术语表
	参考书目

