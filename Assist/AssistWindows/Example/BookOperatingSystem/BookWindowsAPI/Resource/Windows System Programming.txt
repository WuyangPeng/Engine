Windows 系统编程（Windows System Programming）
（第4版）

官方网站：
http://www.jmhartsoftware.com
 
★★★  
作者：Johnson M. Hart
联系作者：
jmh_assoc@hotmail.com和jmhart62@gmail.com

知识点 
1.	Windows基础知识。
2.	Windows文件管理基础知识。
3.	Windows进程、线程基础知识。
4.	Windows网络编程基础知识。
5.	Windows基础知识习题。

代码 
1.  书籍代码。 

前言
	目标和方法
	读者对象
	Windows自上个版本以来的发展
	第4版中的变化
	组织结构
	UNIX和C库的注释和表
	示例
	Web站点
	致谢
作者简介
第1章 Windows初步
	1.1 操作系统必备功能
	1.2 Windows的演化
	1.3 Windows版本
		1.3.1 过时的Windows先前版本
		1.3.2 Windows NT5和NT6
		1.3.3 处理器支持
	1.4	Windows的市场角色
	1.5 Windows、标准以及开放系统
	1.6 Windows准则
	1.7 32位和64位源代码可移植性
	1.8 标准C库：何时用它来处理文件
	1.9 使用本书所需的条件
		1.9.1 为什么使用C而不是C++
		1.9.2 使用示例
	1.10 示例：一个简单的顺序文件复制程序
		1.10.1 使用C库的文件复制
		1.10.2 使用Windows的文件复制
		1.10.3 使用Windows便利函数的文件复制
	1.11 小结
		1.11.1 前瞻
		1.11.2 附加阅读
	1.12 习题
第2章 使用Windows文件系统和字符I/O
	2.1 Windows文件系统
	2.2 文件命名
	2.3 文件的打开 、读取、写入和关闭
		2.3.1 文件的创建和打开
		2.3.2 关闭文件
		2.3.3 读文件
		2.3.4 写文件
	2.4 Unicode和通用字符
		2.4.1 另一种通用字符串处理函数
		2.4.2 通用Main函数
		2.4.3 函数定义
	2.5 Unicode策略
	2.6 示例：错误处理
	2.7 标准设备
	2.8 示例：将多个文件复制到标准输出
	2.9 示例：简单的文件加密
	2.10 文件和目录管理
		2.10.1 文件管理
		2.10.2 目录管理
	2.11 控制台I/O
	2.12 示例：打印和提示
	2.13 示例：打印当前目录
	2.14 小结
		2.14.1 前瞻
		2.14.2 附加阅读
	2.15 习题
第3章 高级文件、目录处理与注册表
	3.1 64位文件系统
	3.2 文件指针
		3.2.1 64位算术
		3.2.2 使用重叠结构来指定文件位置 
	3.3 获得文件尺寸
	3.4 示例：随机记录更新
	3.5 文件属性和目录处理
		3.5.1 路径名
		3.5.2 其他用于获得文件和目录属性的方法
		3.5.3 临时文件名
	3.6 示例：列出文件属性
	3.7 示例：设置文件时间
	3.8 文件处理策略
	3.9 文件锁
		3.9.1 释放文件锁
		3.9.2 锁逻辑的后果
	3.10 注册表
	3.11 注册表管理
		3.11.1 项管理
		3.11.2 值和数据管理
	3.12 示例：列出注册表项及其内容 
	3.13 小结
		3.13.1 前瞻
		3.13.2 附加阅读
	3.14 习题
第4章 异常处理
	4.1 异常及其处理程序
		4.1.1 Try和Except块
		4.1.2 过滤表达式及其值
		4.1.3 异常代码
		4.1.4 小结：异常处理顺序
	4.2 浮点异常
	4.3 错误和异常
	4.4 示例：以异常方式处理错误
	4.5 终止处理程序
		4.5.1 离开try块
		4.5.2 非正常终止
		4.5.3 执行并离开终止处理程序
		4.5.4 组合finally和except块
		4.5.5 全局和局部解开
		4.5.6 终止处理程序：进程和线程终止
		4.5.7 SEH和C++异常处理
	4.6 示例：使用终止处理程序来改进程序质量
	4.7 示例：使用过滤函数
	4.8 控制台控制处理程序
	4.9 示例：一个控制台控制处理程序
	4.10 向量化异常处理
	4.11 小结
	4.12 习题
第5章 内存管理、内存映射文件和DLL
	5.1 Windows内存管理架构
	5.2 堆
	5.3 管理堆内存
		5.3.1 HeapAlloc
		5.3.2 HeapFree
		5.3.3 HeapReAlloc
		5.3.4 HeapSize
		5.3.5 更多关于序列化与异常标志的信息
		5.3.6 其他堆函数
		5.3.7 小结：堆管理
	5.4 示例：使用二叉搜索树对文件进行排序
	5.5 内存映射文件
		5.5.1 文件映射对象
		5.5.2 将对象映射到进程地址空间
		5.5.3 文件映射的限制
		5.5.4 小结：文件映射
	5.6 示例：使用映射文件进行顺序文件处理
	5.7 示例：对内存映射文件排序
	5.8 基指针
	5.9 示例：使用基指针 
	5.10 动态链接库
		5.10.1 静态库和动态库
		5.10.2 隐式链接
		5.10.3 显式链接
	5.11 示例：显式链接文件转换函数
	5.12 DLL进入点
	5.13 DLL版本管理
	5.14 小结
		5.14.1 前瞻
		5.14.2 附加阅读
	5.15 习题
第6章 进程管理
	6.1 Windows进程和线程
	6.2 进程创建
		6.2.1 指定可执行映像和命令行
		6.2.2 可继承句柄
	6.3 进程标识
	6.4 复制句柄
	6.5 进程的退出与终止 
	6.6 等待进程终止 
	6.7 环境块和字符串
	6.8 示例：并行模式搜索
	6.9 多处理器环境中的进程 
	6.10 进程执行时间
	6.11 示例：进程执行时间
	6.12 生成控制台控制事件
	6.13 示例：简单的作业管理
		6.13.1 创建一个后台作业
		6.13.2 获取作业号
		6.13.3 列出背景作业
		6.13.4 在作业清单文件中查找作业
		6.13.5 作业对象
	6.14 示例：使用作业对象
	6.15 小结
	6.16 习题
第7章 线程和调度
	7.1 线程概述
	7.2 线程基础
	7.3 线程管理
		7.3.1 CreateThread
		7.3.2 ExitThread
		7.3.3 GetExitCodeThread
		7.3.4 线程标识
		7.3.5 更多线程管理函数
		7.3.6 挂起以及恢复线程
		7.3.7 等待线程终止
	7.4 在线程中使用C库
	7.5 示例：多线程的模式搜索
	7.6 性能影响
	7.7 老板/工人和其他线程模型
	7.8 示例：合并排序——利用多处理器
	7.9 程序并行性简介
	7.10 线程本地存储
	7.11 进程和线程优先级以及调度
	7.12 线程状态
	7.13 陷阱和常见错误
	7.14 计时等待
	7.15 纤程
	7.16 小结
		7.16.1 前瞻
		7.16.2 附加阅读
	7.17 习题
第8章 线程同步
	8.1	线程同步之需
		8.1.1 临界代码区域
		8.1.2 临界代码区域问题的有瑕疵的解决方案
		8.1.3 volatile存储
		8.1.4 内存架构和内存屏障
		8.1.5 互锁函数：介绍
		8.1.6 局部和全局存储
		8.1.7 小结：线程安全的代码
	8.2 线程同步对象
	8.3 CRITICAL_SECTION对象
	8.4 用于保护共享变量的CRITICAL_SECTION
	8.5 示例：一个简单的生产者/消费者系统
	8.6 互斥量
		8.6.1 被放弃的互斥量
		8.6.2 互斥量、CRITICAL_SECTION以及死锁
		8.6.3 复习：互斥量与CRITICAL_SECTION对比
		8.6.4 堆锁
	8.7 信号量
		8.7.1 使用信号量
		8.7.2 信号量的限制
	8.8 事件
	8.9 示例：一个生产者/消费者系统
		8.9.1 复习：Windows同步对象
		8.9.2 消息和对象等待
	8.10 更多互斥量和CRITICAL_SECTION的指导原则
	8.11 更多互锁函数
	8.12 内存管理性能的考虑
	8.13 小结
		8.13.1 前瞻
		8.13.2 附加阅读
	8.14 习题
第9章 锁、性能以及NT6增强
	9.1 同步性能影响
	9.2 用于性能试验的模型程序
	9.3 使用CS自旋数来调整多处理器性能
	9.4 NT6轻量级读/写锁
	9.5 减少线程竞争的线程池
	9.6 I/O完成端口
	9.7 NT6线程池
		9.7.1 CreateThreadpoolWork
		9.7.2 SubmitThreadpoolWork
		9.7.3 WaitForThreadpoolWorkCallbacks
		9.7.4 CloseThreadpoolWork
		9.7.5 回调函数
		9.7.6 将回调提交给线程池
		9.7.7 线程池环境
		9.7.8 进程线程池
		9.7.9 其他线程池回调类型
	9.8 小结：锁性能
	9.9 再论并行性
		9.9.1 更好的基础以及扩展中的并行程序技术
		9.9.2 并行编程的可选方法
		9.9.3 并行性框架
		9.9.4 不要忘了挑战的存在
	9.10 处理器亲和性
		9.10.1 系统、进程与线程亲和性掩码
		9.10.2 查找处理器数量
	9.11 性能指导原则和陷阱
	9.12 小结
		9.12.1 前瞻
		9.12.2 附加阅读
	9.13 习题
第10章 高级线程同步
	10.1 条件变量模型和安全性能
		10.1.1 一起使用事件和互斥量
		11.1.2 条件变量模型
		11.1.3 条件变量模型的使用
	10.2 使用SignalObjectAndWait
	10.3 示例：阀值屏障对象
	10.4 队列对象
	10.5 示例：在多阶段管线中使用队列 
	10.6 Windows NT6条件变量
	10.7 异步过程调用
	10.8 异步过程调用的排队
	10.9 可报警的等待状态
	10.10 安全的线程取消
	10.11 为了应用程序的移植而使用Pthreads
	10.12 线程堆栈和线程数
	10.13 关于设计、调试和测试的提示
	10.14 Windows API之外
	10.15 小结
		10.15.1 前瞻
		10.15.2 附加阅读
	10.16 习题
第11章 进程间通信
	11.1 匿名管道
	11.2 示例：使用匿名管道进行I/O重定向
	11.3 命名管道
		11.3.1 使用命名管道
		11.3.2 创建命名管道
		11.3.3 命名管道客户连接
		11.3.4 命名管道状态函数
		11.3.5 命名管道连接函数
		11.3.6 客户和服务器的命名管道连接
	11.4 命名管道事务函数
	11.5 示例：客户/服务器命令行处理程序
	11.6 关于客户/服务器命令行处理程序的注释
	11.7 邮槽
		11.7.1 使用邮槽
		11.7.2 创建和打开邮槽
	11.8 管道和邮槽的创建、连接和命名
	11.9 示例：客户可定位的服务器
	11.10 小结
	11.11 习题 
第12章 使用Windows套接字进行网络编程
	12.1 Windows套接字
		12.1.1 Winsock初始化
		12.1.2 创建套接字
	12.2 套接字服务器函数
		12.2.1 绑定套接字
		12.2.2 将绑定的套接字置于侦听状态
		12.2.3 接受客户连接
		12.2.4 断开以及关闭套接字
		12.2.5 示例：准备并接受客户连接
	12.3 套接字客户函数
		12.3.1 连接服务器
		12.3.2 示例：客户连接服务器
		12.3.3 发送和接收数据
	12.4 命名管道和套接字之对比 
		12.4.1 命名管道与套接字服务器之比较
		12.4.2 命名管道与套接字客户之比较
	12.5 示例：套接字消息接收函数
	12.6 示例：基于套接字的客户
	12.7 示例：基于套接字的、带有新特性的服务器
		12.7.1 主程序
		12.7.2 服务器线程
		12.7.3 运行套接字服务器
		12.7.4 安全注释
	12.8 进程内服务器
	12.9 面向行的消息、DLL进入点以及TLS
	12.10 示例：线程安全的套接字消息DLL
	12.11 示例：另一种线程安全的DLL策略
	12.12 数据报
		12.12.1 数据报广播
		12.12.2 使用数据报进行远程过程调用
	12.13 Berkeley套接字和Windows套接字的比较
	12.14 Windows套接字使用重叠I/O
	12.15 Windows套接字的额外特性
	12.16 小结
		12.16.1 前瞻
		12.16.2 附加阅读
	12.17 习题
第13章 Windows服务
	13.1 概述：编写Windows服务
	13.2 main()函数
	13.3 ServiceMain()函数
		13.3.1 注册服务控制处理程序
		13.3.2 设置服务状态
		13.3.3 SERVICE_STATUS结构
		13.3.4 服务特定的代码
	13.4 服务控制处理程序
	13.5 事件记录
	13.6 示例：服务“包装器”
	13.7 管理Windows服务
		13.7.1 打开SCM
		13.7.2 创建和删除服务
		13.7.3 启动服务
		13.7.4 控制服务
		13.7.5 查询服务状态
		13.7.6 小结：服务操作和管理
	13.8 示例：服务控制Shell
	13.9 与服务共享内核对象
	13.10 调试服务时的注意事项
	13.11 小结
		13.11.1 前瞻
		13.11.2 附加阅读
	13.12 习题
第14章 异步输入/输出与完成端口
	14.1 Windows异步I/O
	14.2 重叠I/O
		14.2.1 重叠I/O的后果
		14.2.2 重叠结构
		14.2.3 重叠I/O状态
		14.2.4 取消重叠I/O操作
	14.3 示例：在一个文件句柄之上同步
	14.4 示例：使用重叠I/O和多缓冲区进行文件转换
	14.5 使用完成例程的扩展I/O
		14.5.1 ReadFileEx、WriteFileEx和完成例程
		14.5.2 可报警的等待函数
		14.5.3 完成例程的执行和可报警等待的返回
	14.6 示例：使用扩展I/O的文件转换
	14.7 使用线程的异步I/O
	14.8 可等待定时器
	14.9 示例：使用可等待定时器
		14.9.1 可等待定时器示例的注释 
		14.9.2 线程池定时器
	14.10 I/O完成端口
		14.10.1 管理I/O完成端口
		14.10.2 等待I/O完成端口
		14.10.3 邮发给I/O完成端口
		14.10.4 I/O完成端口的替代
	14.11 示例：使用I/O完成端口的服务器
	14.12 小结
	14.13 习题
第15章 Windows对象的安全
	15.1 安全属性
	15.2 安全性概述：安全描述符
		15.2.1 访问控制列表
		15.2.2 使用Windows对象安全性
		15.2.3 对象权限和对象访问
		15.2.4 安全描述符初始化
	15.3 安全描述符控制标志 
	15.4 安全标识符
	15.5 管理ACL
	15.6 示例：NTFS文件的UNIX风格的权限
	15.7 示例：初始化安全属性
	15.8 安全描述符的读与更改
	15.9 示例：读取文件权限
	15.10 示例：更改文件权限
	15.11 给内核和通信对象施加安全
		15.11.1 给命名管道施加安全
		15.11.2 内核与私有对象的安全性
		15.11.3 ACE掩码值
	15.12 示例：给进程及其线程施加安全
	15.13 其他安全特性的概述
		15.13.1 移除ACE
		15.13.2 绝对的和自相关的安全描述符
		15.13.3 系统ACL
		15.13.4 访问令牌令牌
		15.13.5 SID管理
	15.14 小结
		15.14.1 前瞻
		15.14.2 附加阅读
	15.15 习题
附录A 使用示例程序
附录B 源代码可移植性：Windows、UNIX和Linux
附录C 性能结果