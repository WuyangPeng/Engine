C++ 代码设计与重用 （Designing and Coding Reusable C++）

★
作者：Martin D.Carroll、Margaret A.Ellis

知识点 
1.	C++ 基础知识。 

前言
	关于本书
	选择与建议
	代码例子
	致谢
第1章 重用性介绍
	1.1 什么是重用性
		1.1.1 提取代码来作为重用
		1.1.2 可重用代码的基本特性
	1.2 重用的神话
	1.3 重用的障碍
		1.3.1 非技术障碍
		1.3.2 技术障碍
	1.4 希望是否尚存
	1.5 这本书能给我们带来什么
	l.6 练习
	1.7 参考文献和相关资料
第2章 类的设计 
	2.1 抽象性
	2.2 正规函数
	2.3 Nice类
	2.4 存在最小标准接口吗
		2.4.1 缺省构造函数
		2.4.2 赋值运算符
		2.4.3 拷贝构造函数
		2.4.4 相等运算符
		2.4.5 析构函数
	2.5 浅拷贝和深拷贝
	2.6 接口一致性
	2.7 转型
		2.7.1 多重所有权
		2.7.2 敏感转型
		2.7.3 不敏感转型
		2.7.4 转型数目
	2.8 const关键字的使用
		2.8.1 抽象const对比位元const
		2.8.2 大限度地使用const
		2.8.3 对const不安全的解释
	2.9 总结
	2.10 练习
	2.11 参考文献和相关资料
第3章 扩展性
	3.1 扩展性的权衡
	3.2 扩展性和继承
		3.2.1 只继承基类的接口
		3.2.2 只继承基类的实现
		3.2.3 同时继承基类的接口和实现
	3.3 继承语义
	3.4 继承的障碍
		3.4.1 非虚成员函数
		3.4.2 过度保护
		3.4.3 模块化不足
		3.4.4 friend关键字的使用
		3.4.5 成员变量过多
		3.4.6 非虚派生
		3.4.7 妨碍继承的成员函数
	3.5 派生赋值问题
	3.6 允许入侵（用户修改源代码）继承
	3.7 总结
	3.8 练习
	3.9 参考文献和相关资料
第4章 效率
	4.1 效率和重用性
	4.2 程序创建时间
		4.2.1 编译时间
		4.2.2 实例化时间
	4.3 代码大小
		4.3.1 源文件分割
		4.3.2 外联的inline
		4.3.3 模板特化大小
	4.4 运行时间
		4.4.1 内联
		4.4.2 虚函数
		4.4.3 返回引用 
	4.5 空闲存储空间和规模空间
		4.5.1 使用高效的算法 
		4.5.2 尽可能快地释放空闲资源
		4.5.3 静态对象
		4.5.4 庞大的对象
	4.6 效率的权衡
		4.6.1 实现更加困难
		4.6.2 使用更加困难
	4.7 总结
	4.8 练习
	4.9 参考文献和相关资料
第5章 错误
	5.1 可重用代码中的错误
	5.2 错误检测
		5.2.1 函数前提条件
		5.2.2 表示不变性
	5.3 处理错误
		5.3.1 程序库变量
		5.3.2 解决问题
		5.3.3 程序退出或者程序中止
		5.3.4 抛出异常
		5.3.5 返回错误值
		5.3.6 创建Nil值
		5.3.7 把无效的数据解释为有效的数据
		5.3.8 允许不确定的行为
	5.4 资源限制错误
		5.4.1 堆栈溢出
		5.4.2 用完空闲存储空间
		5.4.3 文件系统限制
	5.5 异常安全性
		5.5.1 不一致的状态
		5.5.2 资源泄漏
	5.6 总结
	5.7 练习
	5.8 参考文献和相关资料
第6章 冲突
	6.1 全局名称
		6.1.1 翻译单元
		6.1.2 类的定义
		6.1.3 函数和数据的定义
		6.1.4 程序库的蕴涵意义
		6.1.5 命名约定
		6.1.6 名字空间结构
	6.2 宏名称
		6.2.1 宏名称冲突
		6.2.2 去掉宏
		6.2.3 宏的命名约定
	6.3 环境名称
	6.4 Unclean程序库
	6.5 Good-citizen程序库
	6.6 总结
	6.7 练习
	6.8 参考文献和相关资料
第7章 兼容性
	7.1 向后和向前兼容性
	7.2 兼容性的形式
	7.3 理论源代码兼容性
	7.4 实际源代码兼容性
	7.5 链接兼容性
	7.6 运行兼容性
	7.7 进程兼容性
	7.8 文档化不兼容性
	7.9 非文档化特性
	7.10 总结
	7.11 练习
	7.12 参考文献和相关资料
第8章 继承体系
	8.1 根数目、深度和扇出数
	8.2 体系类型
		8.2.1 直接体系
		8.2.2 接口体系
		8.2.3 对象工厂
		8.2.4 句柄体系
	8.3 模板还是继承
		8.3.1 指针操纵
		8.3.2 派生要求
		8.3.3 实现不需要的函数
	8.4 总结
	8.5 练习
	8.6 参考文献和相关资料
第9章 移植性
	9.1 有编写可移植代码的必要吗
		9.1.1 可移植性的优缺点
		9.1.2 目标代码和创建过程的可移植性
	9.2 不断发展的语言定义
		9.2.1 冲突
		9.2.2 实现的完整性
	9.3 不确定的行为
		9.3.1 排列方式和补全
		9.3.2 地址操纵
	9.4 合法但不可移植的代码
		9.4.1 实现性定义的行为
		9.4.2 未经指定的行为
	9.5 实现依赖性
	9.6 可移植的数据文件
	9.7 模板实例化
		9.7.1 自动的实例化器
		9.7.2 人工实例化
	9.8 运行期程序库
	9.9 其他移植性问题
	9.10 总结
	9.11 练习
	9.12 参考文献和相关资料
第10章 使用其他程序库
	10.1 为何要重用其他程序库
	10.2 使用其他程序库的缺点
		10.2.1 获得可重用程序库
		10.2.2 效率
		10.2.3 冲突
		10.2.4 版本同步
	10.3 自含式程序库
		10.3.1 实现困难
		10.3.2 使用困难
		10.3.3 效率
		10.3.4 隔离
	10.4 总结
	10.5 练习
第11章 文档编制
	11.1 文档编制和重用性
	11.2 设计文档 
	11.3 使用指南
		11.3.1 对读者的背景知识了如指掌
		11.3.2 用抽象的观点来编写
		11.3.3 先解释普通用法
		11.3.4 一次中解释一个事物
		11.3.5 解释用法，不解释设计思路
		11.3.6 简单清楚地编写
		11.3.7 准确地使用语言
		11.3.8 使用普遍接受的术语
		11.3.9 深刻理解重载的术语
		11.3.10 给出合法的、无错误的代码
		11.3.11 保持简短的代码段
		11.3.12 避免使用太大的函数
		11.3.13 提供在线实例
	11.4 参考手册
		11.4.1 抽象化
		11.4.2 语法接口
		11.4.3 函数语义
		11.4.4 模板参数约束
	11.5 总结
	11.6 练习
	11.7 参考文献和相关资料
第12章 其他话题
	12.1 静态初始化问题
		12.1.1 构造的析构的时刻
		12.1.2 程序库的蕴含意义
		12.1.3 初始化函数
		12.1.4 初始化检查 
		12.1.5 初始化对象
		12.1.6 双构造 
	12.2 局部化开销原则
		12.2.1 局部化开销和C++
		12.2.2 局部化开销和程序库
	12.3 内生类和外生类
	12.4 迭代器
	12.5 类耦合
	12.6 推迟决定 
	12.7 总结
	12.8 练习
	12.9 参考文献和相关资料