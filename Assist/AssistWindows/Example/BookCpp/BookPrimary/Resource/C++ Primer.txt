C++ Primer

官方网站 
http://www.informit.com/store/product.aspx?isbn=0201721481 、
http://www.informit.com/title/0321714113。

第4版
★★★
作者：Stanley B.Lippman、Josee Lajoie、Barbara E.Moo。
其他书籍：Stanley B.Lippman《Essential C++》、《深度探索C++对象模型》，Barbara E.Moo《Accelerated C++》、《C++ 沉思录》。

知识点 
1.	C++基础知识。
2.	C++基础知识练习。
3.	C++标准库知识。

代码 
1.  书籍代码。

要点 
1.	删除0值的指针是安全的（5.11	new和delete表达式）。
2.	通常来说，除非找到选择使用其他容器的更好理由，否则vector容器都是最佳选择（9.5 容器的选用）。
3.	在处理算法时，最好将关联容器上的迭代器视为支持自减运算的输入迭代器，
	而不是完整的双向迭代器（11.3 再谈迭代器）。
4.	按照与成员声明一致的次序编写构造函数初始化列表是个好主意。
	此外，尽可能避免使用成员来初始化其他成员（12.4 构造函数）。
5.	编写模板代码时，对实参类型的要求尽可能少是很有益的（16.1 模板定义）。
6.	抛出指针通常是个坏主意：抛出指针要求在对应处理代码存在的任意地方存在指针所指向的对象（17.1 异常处理）。

前言
	★	C++语言的发展方向以及C++程序员的关注点，已经从以往注重运行的效率，转到千方百计地提高程序员的编程效率上。
	第4版的改动
	本书结构
	致谢
第1章 快速入门
	1.1 编写简单的C++程序
	1.2 初窥输入/输出
		1.2.1 标准输入与输出对象
		1.2.2 一个使用IO库的程序
	1.3 关于注释
	1.4 控制结构
		1.4.1 while语句
		1.4.2 for语句
		1.4.3 if语句
		1.4.4 讲入未知数目的输入
	1.5 类的简介
		1.5.1 Sales_item类
		1.5.2 初窥成员函数
	1.6 C++程序
	小结
	术语
第一部分 基本语言
	第2章 变量和基本类型
		2.1 基本内置类型
			2.1.1 整型
			2.1.2 浮点型
		2.2 字面值常量
		2.3 变量
			2.3.1 什么是变量
			2.3.2 变量名
			2.3.3 定义对象
			2.3.4 变量初始化规则
			2.3.5 声明和定义
			2.3.6 名字的作用域
			2.3.7 在变量使用处定义变量
		2.4 const限定符
		2.5 引用 
		2.6 typedef名字
		2.7 枚举
		2.8 类类型
		2.9 编写自己的头文件 
			2.9.1 设计自己的头文件
			2.9.2 预处理器的简单介绍
		小结
		术语
	第3章 标准库类型
		3.1 命名空间的using声明
		3.2 标准库string类型
			3.2.1 string对象的定义和初始化
			3.2.2 string对象的读写
			3.2.3 string对象的操作
			3.2.4 string对象中字符的处理
		3.3 标准库vector类型
			3.3.1 vector对象的定义和初始化
			3.3.2 vector对象的操作
		3.4 迭代器简介
		3.5 标准库bitset类型
			3.5.1 bitset的定义和初始化
			3.5.2 bitset对象上的操作
		小结
		术语
	第4章 数组和指针
		4.1 数组
			4.1.1 数组的定义和初始化
			4.1.2 数组操作
		4.2 指针的引入
			4.2.1 什么是指针
			4.2.2 指针的定义和初始化
			4.2.3 指针操作
			4.2.4 使用指针访问数组元素
			4.2.5 指针和const限定符
		4.3 C风格字符串
			4.3.1 创建动态数组
			4.3.2 新旧代码的兼容
		4.4 多维数组
		小结
		术语
	第5章 表达式
		5.1 算术操作符
		5.2 关系操作符和逻辑操作符
		5.3 位操作符
			5.3.1 bitset对象或整型值的使用
			5.3.2 将移位操作符用于IO
		5.4 赋值操作符
			5.4.1 赋值操作的右结合性
			5.4.2 赋值操作具有低优先级
			5.4.3 复合赋值操作符
		5.5 自增和自减操作符
		5.6 箭头操作符
		5.7 条件操作符
		5.8 sizeof操作符
		5.9 逗号操作符
		5.10 复合表达式的求值
			5.10.1 优先级
			5.10.2 结合性
			5.10.3 求值顺序
		5.11 new和delete表达式
		5.12 类型转换
			5.12.1 何时发生隐式类型转换
			5.12.2 算术转换
			5.12.3 其他隐式转换
			5.12.4 显式转换
			5.12.5 何时需要强制类型转换
			5.12.6 命名的强制类型转换
			5.12.7 旧式强制类型转换
		小结
		术语
	第6章 语句
		6.1 简单语句
		6.2 声明语句
		6.3 复合语句（语句块）
		6.4 语句作用域
		6.5 if语句
		6.6 switch语句
			6.6.1 使用switch
			6.6.2 switch中的控制流
			6.6.3 default标号
			6.6.4 switch表达式与case标号
			6.6.5 switch内部的变量定义
		6.7 while语句
		6.8 for循环语句
			6.8.1 省略for语句头的某些部分
			6.8.2 for语句头中的多个定义
		6.9 do while语句
		6.10 break语句
		6.11 continue语句
		6.12 goto语句
		6.13 try块和异常处理
			6.13.1 throw表达式
			6.13.2 try块
			6.13.3 标准异常
		6.14 使用预处理器里德调试
		小结
		术语
	第7章 函数
		7.1 函数的定义
			7.1.1 函数返回类型
			7.1.2 函数形参表
		7.2 参数传递
			7.2.1 非引用形参
			7.2.2 引用形参
			7.2.3 vector和其他容器类型的形参
			7.2.4 数组形参
			7.2.5 传递给函数的数组的处理
			7.2.6 main：处理命令行选项
			7.2.7 含有可变形参的函数
		7.3 return语句
			7.3.1 没有返回值的函数
			7.3.2 具有返回值的函数
			7.3.3 递归
		7.4 函数声明 
		7.5 局部对象
			7.5.1 自动对象
			7.5.2 静态局部对象
		7.6	内联函数
		7.7 类的成员函数
			7.7.1 定义成员函数的函数体
			7.7.2 在类外定义成员函数
			7.7.3 编写Sales_item类的构造函数
			7.7.4 类代码文件的组织
		7.8 重载函数
			7.8.1 重载与作用域
			7.8.2 函数匹配与实参转换
			7.8.3 重载确定的三个步骤
			7.8.4 实参类型转换
		7.9 指向函数的指针
		小结
		术语
	第8章 标准IO库
		8.1 面向对象的标准库
		8.2 条件状态
		8.3 输出缓冲区的管理
		8.4 文件的输入和输出
			8.4.1 文件流对象的使用
			8.4.2 文件模式
			8.4.3 一个打开并检查输入文件的程序
		8.5 字符串流
		小结
		术语
第二部分 容器和算法
	第9章 顺序容器
		9.1 顺序容器的定义
			9.1.1 容器元素的初始化
			9.1.2 容器内元素的类型约束
		9.2 迭代器和迭代器范围
			9.2.1 迭代器范围
			9.2.2 使迭代器失效的容器操作
		9.3 顺序容器的操作
			9.3.1 容器定义的类型别名
			9.3.2 begin和end成员
			9.3.3 在顺序容器中添加元素
			9.3.4 关系操作符
			9.3.5 容器大小的操作
			9.3.6 访问元素
			9.3.7 删除元素
			9.3.8 赋值与swap
		9.4 vector容器的自增长
		9.5 容器的选用
		9.6 再谈string类型
			9.6.1 构造string对象的其他方法
			9.6.2 修改string对象的其他方法
			9.6.3 只适用于string类型的操作
			9.6.4 string类型的查找操作
			9.6.5 string对象的比较
		9.7 容器适配器
			9.7.1 栈适配器
			9.7.2 队列和优先级队列
		小结
		术语
	第10章 关联容器
		10.1 引言：pair类型
		10.2 关联容器
		10.3 map类型
			10.3.1 map对象的定义
			10.3.2 map定义的类型
			10.3.3 给map添加元素
			10.3.4 使用下标访问map对象
			10.3.5 map::insert的使用
			10.3.6 查找并读取map中的元素
			10.3.7 从map对象中删除元素
			10.3.8 map对象的迭代遍历
			10.3.9 “单词转换”map对象
		10.4 set类型
			10.4.1 set容器的定义和使用
			10.4.2 创建“单词排除集”
		10.5 multimap和multiset类型
			10.5.1 元素添加和删除
			10.5.2 在multimap和multiset中查找元素
		10.6 容器的综合应用：文本查询程序
			10.6.1 查询程序的设计
			10.6.2 TextQuery类
			10.6.3 TestQuery类的使用
			10.6.4 编写成员函数
		小结
		术语
	第11章 泛型算法
		11.1 概述
		11.2 初窥算法
			11.2.1 只读算法
			11.2.2 写容器元素的算法
			11.2.3 对容器元素重新排序的算法
		11.3 迭代器回顾
			11.3.1 插入迭代器
			11.3.2 iostream迭代器
			11.3.3 反向迭代器
			11.3.4 const迭代器
			11.3.5 五种迭代器
		11.4 泛型算法的结构
			11.4.1 算法的形参模式
			11.4.2 算法的命名规范
		11.5 容器特有的算法
		小结
		术语
第三部分 类和数据抽象
	第12章 类
		12.1 类的定义和声明 
			12.1.1 类定义：扼要重述
			12.1.2 数据抽象和封装
			12.1.3 关于类定义的更多内容
			12.1.4 类声明与类定义
			12.1.5 类对象
		12.2 隐含的this指针
		12.3 类作用域
		12.4 构造函数
			12.4.1 构造函数初始化式
			12.4.2 默认实参与构造函数
			12.4.3 默认构造函数
			12.4.4 隐式类类型转换
			12.4.5 类成员的显式初始化
		12.5 友元
		12.6 static类成员
			12.6.1 static成员函数
			12.6.2 static数据成员
		小结
		术语
	第13章 复制控制
		13.1 复制构造函数
			13.1.1 合成的复制构造函数
			13.1.2 定义自己的复制构造函数
			13.1.3 禁止复制
		13.2 赋值操作符
		13.3 析构函数
		13.4 消息处理示例
		13.5 管理指针成员
			13.5.1 定义智能指针类
			13.5.2 定义值型类
		小结
		术语
	第14章 重载操作符与转换
		14.1 重载操作符与转换
		14.2 输入和输出操作符
			14.2.1 输出操作符<<的重载
			14.2.2 输入操作符>>的重载
		14.3 算术操作符和关系操作符
			14.3.1 相等操作符
			14.3.2 关系操作符
		14.4 赋值操作符
		14.5 下标操作符
		14.6 成员访问操作符
		14.7 自增操作符和自减操作符
		14.8 调用操作符和函数对象
			14.8.1 将函数对象用于标准库算法
			14.8.2 标准库定义的函数对象
			14.8.3 函数对象的函数适配器
		14.9 转换与类类型
			14.9.1 转换为什么有用
			14.9.2 转换操作符
			14.9.3 实参匹配和转换
			14.9.4 重载确定和类的实参
			14.9.5 重载、转换和操作符
		小结
		术语
第四部分 面向对象编程与泛型编程
	第15章 面向对象编程
		15.1 面向对象编程：概述
		15.2 定义基类和派生类
			15.2.1 定义基类
			15.2.2 protected成员
			15.2.3 派生类
			15.2.4 virtual与其他成员函数
			15.2.5 公用、私有和受保护的继承
			15.2.6 友元关系与继承
			15.2.7 继承与静态成员
		15.3 转换与继承
			15.3.1 派生类到基类的转换
			15.3.2 基类到派生类的转换
		15.4 构造函数和复制控制
			15.4.1 基类构造函数和复制控制
			15.4.2 派生类构造函数
			15.4.3 复制控制和继承
			15.4.4 虚析构函数
			15.4.5 构造函数和析构函数中的虚函数
		15.5 继承情况下的类作用域
			15.5.1 名字查找在编译时发生
			15.5.2 名字冲突与继承
			15.5.3 作用域与成员函数
			15.5.4 虚函数与作用域
		15.6 纯虚函数
		15.7 容器与继承
		15.8 句柄类与继承
			15.8.1 指针型句柄
			15.8.2 复制未知类型
			15.8.3 使用句柄
		15.9 再谈文本查询示例
			15.9.1 面向对象的解决方案
			15.9.2 值型句柄
			15.9.3 Query_base类
			15.9.4 Query句柄类
			15.9.5 派生类
			15.9.6 eval函数
		小结
		术语
	第16章 模板与泛型编程
		16.1 模板定义
			16.1.1 定义函数模板
			16.1.2 定义类模板
			16.1.3 模板形参
			16.1.4 模板类型形参
			16.1.5 非类型模板形参
			16.1.6 编写泛型程序
		16.2 实例化
			16.2.1 模板实参推断
			16.2.2 函数模板的显示实参
		16.3 模板编译模型
		16.4 类模板成员
			16.4.1 类模板成员函数
			16.4.2 非类型形参的模板实参
			16.4.3 类模板中的友元声明
			16.4.4 Queue和QueueItem的友元声明 
			16.4.5 成员模板
			16.4.6 完整的Queue类
			16.4.7 类模板的static成员
		16.5 一个泛型句柄类
			16.5.1 定义句柄类
			16.5.2 使用句柄 
		16.6 模板特化
			16.6.1 函数模板的特化
			16.6.2 类模板的特化
			16.6.3 特化成员而不特化类
			16.4.4 类模板的部分特化
		16.7 重载与函数模板
		小结
		术语
第五部分 高级主题
	第17章 用于大型程序的工具
		17.1 异常处理
			17.1.1 抛出类类型的异常
			17.1.2 栈展开
			17.1.3 捕获异常
			17.1.4 重新抛出
			17.1.5 捕获所有异常的处理代码
			17.1.6 函数测试块与构造函数
			17.1.7 异常类层次
			17.1.8 自动资源释放
			17.1.9 auto_ptr类
			17.1.10 异常说明 
			17.1.11 函数指针的异常说明 
		17.2 命名空间
			17.2.1 命名空间的定义
			17.2.2 嵌套命名空间
			17.2.3 未命名的命名空间
			17.2.4 命名空间成员的使用
			17.2.5 类、命名空间和作用域
			17.2.6 重载与命名空间
			17.2.7 命名空间与模板
		17.3 多重继承与虚继承
			17.3.1 多重继承
			17.3.2 转换与多个基类
			17.3.3 多重继承派生类的复制控制
			17.3.4 多重继承下的类作用域
			17.3.5 虚继承
			17.3.6 虚基类的声明
			17.3.7 特殊的初始化语义
		小结
		术语
	第18章 特殊工具与技术
		18.1 优化内存分配
			18.1.1 C++中的内存分配
			18.1.2 allocator类
			18.1.3 operator new函数和operator delete函数
			18.1.4 定位new表达式
			18.1.5 显示析构函数的调用
			18.1.6 类特定的new和delete
			18.1.7 一个内存分配器基类
		18.2 运行时类型识别
			18.2.1 dynamic_cast操作符
			18.2.2 typeid操作符
			18.2.3 RTTI的使用
			18.2.4 type_info类
		18.3 类成员的指针
			18.3.1 声明成员指针
			18.3.2 使用类成员的指针
		18.4 嵌套类
			18.4.1 嵌套类的实现
			18.4.2 嵌套类作用域中的名字查找 
		18.5 联合：节省空间的类
		18.6 局部类
		18.7 固有的不可移植的特征
			18.7.1 位域
			18.7.2 volatile限定符
			18.7.3 链接指示：extern"C"
		小结
		术语
附录 标准库
	A.1 标准库名字和头文件
	A.2 算法简介
	A.3 再谈IO库
索引

第5版
★★★★
作者：Stanley B.Lippman、Josee Lajoie、Barbara E.Moo。
其他书籍：Stanley B.Lippman《Essential C++》、《深度探索C++对象模型》，Barbara E.Moo《Accelerated C++》、《C++ 沉思录》。

知识点 
1.	C++基础知识。
2.	C++基础知识练习。
3.	C++11基础知识。
4.	C++标准库知识（附录A）。
5.	decltype类型指示符（2.5.3 decltype类型指示符）。
6.	确定使用哪种顺序容器（9.1 顺序容器概述）。
7.	无序容器（11.4 无序容器）。
8.	三/五法则（13.1.4 三/五法则）。
9.	对象移动（13.6 对象移动）。
10.	文本查询程序。
11.	转发（16.2.7 转发）。
12.	sizeof...运算符（16.4 可变参数模板）。
13.	正则表达式（17.3 正则表达式）。

代码
1.	书籍代码。

要点 
1.	切勿混用带符号类型和无符号类型（2.1.2 类型转换）。
2.	动态分配一个空数组是合法的（12.2 动态数组）。
3.	使用move的代码应该使用std::move而不是move。这样做可以避免潜在的名字冲突（13.6 对象移动）。
4.	不抛出异常的移动构造函数和移动赋值运算符必须标记为noexcept（13.6 对象移动）。

前言
	★	语言本身的关注点和程序设计社区的关注点都已大大开阔，已经从主要关注机器效率转变为更多地关注编程效率。
	★	新标准的主要目标是：
		1.	使语言更为统一，更易于教学。
		2.	使标准库更简单、安全、使用更高效。
		3.	使编写高效率的抽象和库变得更简单。
	为什么选择这本书？
	第5版变化的内容
	本书的结构
	读者帮助 
	关于编译器的注意事项
	致谢
第1章 开始
	1.1 编写一个简单的C++程序
		1.1.1 编译、运行程序
	1.2 初识输入/输出 
	1.3 注释简介
	1.4 控制流
		1.4.1 while语句
		1.4.2 for语句
		1.4.3 读取数量不定的输入数据
		1.4.4 if语句
	1.5 类简介
		1.5.1 Sales_item类
		1.5.2 初识成员函数
	1.6 书店程序
	小结
	术语表
第Ⅰ部分 C++基础
	第2章 变量和基本类型
		2.1 基本内置类型
			2.1.1 算术类型
			2.1.2 类型转换
			2.1.3 字面值常量 
		2.2 变量
			2.2.1 变量定义
			2.2.2 变量声明和定义类型
			2.2.3 标识符
			2.2.4 名字作用域
		2.3 复合类型
			2.3.1 引用 
			2.3.2 指针
			2.3.3 理解复合类型的声明 
		2.4 const限定符
			2.4.1 const的引用
			2.4.2 指针和const 
			2.4.3 顶层const
			2.4.4 constexpr和常量表达式
		2.5 处理类型
			2.5.1 类型别名
			2.5.2 auto类型说明符
			2.5.3 decltype类型指针符
		2.6 自定义数据结构 
			2.6.1 定义Sales_data类型
			2.6.2 使用Sales_data类
			2.6.3 编写自己的头文件
		小结
		术语表
	第3章 字符串、向量和数组
		3.1 命名空间的using声明
		3.2 标准库string类型
			3.2.1 定义和初始化string对象 
			3.2.2 string对象上的操作
			3.2.3 处理string对象中的字符
		3.3 标准库类型vector
			3.3.1 定义和初始化vector对象
			3.3.2 向vector对象中添加元素
			3.3.3 其他vector操作
		3.4 迭代器简介
			3.4.1 使用迭代器
			3.4.2 迭代器运算
		3.5 数组
			3.5.1 定义和初始化内置数组
			3.5.2 访问数组元素
			3.5.3 指针和数组
			3.5.4 C风格字符串
			3.5.5 与旧代码的接口
		小结
		术语表
	第4章 表达式
		4.1 基础
			4.1.1 基本概念
			4.1.2 优先级和结合律
			4.1.3 求值顺序
		4.2 算术运算符
		4.3 逻辑和关系运算符
		4.4 赋值运算符
		4.5 递增和递减运算符
		4.6 成员访问运算符
		4.7 条件运算符
		4.8 位运算符
		4.9 sizeof运算符
		4.10 逗号运算符
		4.11 类型转换
			4.11.1 算术转换
			4.11.2 其他隐式类型转换
			4.11.3 显式转换
		4.12 运算符优先级
		小结
		术语表
	第5章 语句
		5.1 简单语句
		5.2 语句作用域
		5.3 条件语句
			5.3.1 if语句
			5.3.2 switch语句
		5.4 迭代语句
			5.4.1 while语句 
			5.4.2 传统的for语句
			5.4.3 范围for语句
			5.4.4 do while语句
		5.5 跳转语句
			5.5.1 break语句
			5.5.2 continue语句
			5.5.3 goto语句
		5.6 try语句块和异常处理
			5.6.1 throw表达式
			5.6.2 try语句块
			5.6.3 标准异常
		小结
		术语表
	第6章 函数
		6.1 函数基础
			6.1.1 局部对象
			6.1.2 函数声明
			6.1.3 分离式编译
		6.2 参数传递
			6.2.1 传值参数
			6.2.2 传引用参数
			6.2.3 const形参和实参
			6.2.4 数组形参
			6.2.5 main：处理命令行选项
			6.2.6 含有可变形参的函数
		6.3 返回类型和return语句
			6.3.1 无返回值函数
			6.3.2 有返回值函数
			6.3.3 返回数组指针
		6.4 函数重载
			6.4.1 重载与作用域
		6.5 特殊用途语言特性
			6.5.1 默认实参
			6.5.2 内联函数和constexpr函数
			6.5.3 调试帮助
		6.6 函数匹配
			6.6.1 实参类型转换
		6.7 函数指针
		小结
		术语表
	第7章 类
		7.1 定义抽象数据类型
			7.1.1 设计Sales_data类
			7.1.2 定义改进的Sales_data类
			7.1.3 定义类相关的非成员函数
			7.1.4 构造函数
			7.1.5 拷贝、赋值和析构
		7.2 访问控制与封装
			7.2.1 友元
		7.3 类的其他特性
			7.3.1 类成员再探
			7.3.2 返回*this的成员函数
			7.3.3 类类型
			7.3.4 友元再探
		7.4 类的作用域
			7.4.1 名字查找与类的作用域
		7.5 构造函数再探
			7.5.1 构造函数初始值列表
			7.5.2 委托构造函数
			7.5.3 默认构造函数的作用
			7.5.4 隐式的类类型转换
			7.5.5 聚合类
			7.5.6 字面值常量类
		7.6 类的静态成员
		小结
		术语表
第Ⅱ部分 C++标准库
	第8章 IO库
		8.1 IO类
			8.1.1 IO对象无拷贝或赋值
			8.1.2 条件状态
			8.1.3 管理输出缓冲
		8.2 文件输入输出
			8.2.1 使用文件流对象
			8.2.2 文件模式
		8.3 string流
			8.3.1 使用istringstream
			8.3.2 使用ostringstream
		小结
		术语表
	第9章 顺序容器
		9.1 顺序容器概述
		9.2 容器库概述
			9.2.1 迭代器
			9.2.2 容器类型成员
			9.2.3 begin和end成员
			9.2.4 容器定义和初始化
			9.2.5 赋值和swap
			9.2.6 容器大小操作
			9.2.7 关系运算符
		9.3 顺序容器操作
			9.3.1 向顺序容器添加元素
			9.3.2 访问元素
			9.3.3 删除元素
			9.3.4 特殊的forward_list操作
			9.3.5 改变容器大小
			9.3.6 容器操作可能使迭代器失效
		9.4 vector对象是如何增长的
		9.5 额外的string操作
			9.5.1 构造string的其他方法
			9.5.2 改变string的其他方法
			9.5.3 string搜索操作
			9.5.4 compare函数
			9.5.5 数值转换
		9.6 容器适配器
		小结
		术语表
	第10章 泛型算法
		10.1 概述
		10.2 初识泛型算法
			10.2.1 只读算法
			10.2.2 写容器元素的算法
			10.2.3 重排容器元素的算法
		10.3 定制操作
			10.3.1 向算法传递函数
			10.3.2 lambda表达式
			10.3.3 lambda捕获和返回
			10.3.4 参数绑定
		10.4 再探迭代器
			10.4.1 插入迭代器
			10.4.2 iostream迭代器
			10.4.3 反向迭代器
		10.5 泛型算法结构
			10.5.1 5类迭代器
			10.5.2 算法形参模式
			10.5.3 算法命名规范
		10.6 特定容器算法
		小结
		术语表
	第11章 关联容器
		11.1 使用关联容器
		11.2 关联容器概述
			11.2.1 定义关联容器
			11.2.2 关键字类型的要求
			11.2.3 pair类型
		11.3 关联容器操作
			11.3.1 关联容器迭代器
			11.3.2 添加元素
			11.3.3 删除元素
			11.3.4 map的下标操作
			11.3.5 访问元素
			11.3.6 一个单词转换的map
		11.4 无序容器
		小结
		术语表
	第12章 动态内存
		12.1 动态内存与智能指针
			12.1.1 shared_ptr类
			12.1.2 直接管理内存
			12.1.3 shared_ptr和new结合使用
			12.1.4 智能指针和异常
			12.1.5 unique_ptr
			12.1.6 weak_ptr
		12.2 动态数组
			12.1.2 new和数组
			12.1.2 allocator类
		12.3 使用标准库：文本查询程序
			12.3.1 文本查询程序设计
			12.3.2 文本查询程序类的定义
		小结
		术语表
第Ⅲ部分 类设计者的工具
	第13章 拷贝控制
		13.1 拷贝、赋值与销毁
			13.1.1 拷贝构造函数
			13.1.2 拷贝赋值运算符
			13.1.3 析构函数
			13.1.4 三/五法则
			13.1.5 使用=default
			13.1.6 阻止拷贝
		13.2 拷贝控制和资源管理
			13.2.1 行为像值的类
			13.2.2 定义行为像指针的类
		13.3 交换操作
		13.4 拷贝控制示例
		13.5 动态内存管理类
		13.6 对象移动
			13.6.1 右值引用 
			13.6.2 移动构造函数和移动赋值运算符
			13.6.3 右值引用和成员函数
		小结
		术语表
	第14章 重载运算与类型转换
		14.1 基本概念
		14.2 输入和输出运算符
			14.2.1 重载输出运算符<<
			14.2.2 重载输入运算衔>>
		14.3 算术和关系运算符
			14.3.1 相等运算符
			14.3.2 关系运算符
		14.4 赋值运算符
		14.5 下标运算符
		14.6 递增和递减运算符
		14.7 成员访问运算符
		14.8 函数调用运算符
			14.8.1 lambda是函数对象
			14.8.2 标准库定义的函数对象
			14.8.3 可调用对象与function
		14.9 重载、类型转换与运算符
			14.9.1 类型转换运算符
			14.9.2 避免有二义性的类型转换
			14.9.3 函数匹配与重载运算符
		小结
		术语表
	第15章 面向对象程序设计
		15.1 OOP：概述
		15.2 定义基类和派生类
			15.2.1 定义基类
			15.2.2 定义派生类
			15.2.3 类型转换与继承
		15.3 虚函数
		15.4 抽象基类
		15.5 访问控制与继承
		15.6 继承中的类作用域
		15.7 构造函数与拷贝控制 
			15.7.1 虚析构函数
			15.7.2 合成拷贝控制与继承
			15.7.3 派生类的拷贝控制成员
			15.7.4 继承的构造函数
		15.8 容器与继承
			15.8.1 编写Basket类
		15.9 文本查询程序再探
			15.9.1 面向对象的解决方案
			15.9.2 Query_base类和Query类
			15.9.3 派生类
			15.9.4 eval函数
		小结
		术语表
	第16章 模板与泛型编程
		16.1 定义模板
			16.1.1 函数模板
			16.1.2 类模板
			16.1.3 模板参数
			16.1.4 成员模板
			16.1.5 控制实例镪
			16.1.6 效率与灵活性
		16.2 模板实参推断
			16.2.1 类型转换与模板类型参数
			16.2.2 函数模板显式实参
			16.2.3 尾置返回类型与类型转换
			16.2.4 函数指针和实参推断
			16.2.5 模板实参推断和引用 
			16.2.6 理解std::move
			16.2.7 转发
		16.3 重载与模板
		16.4 可变参数模板
			16.4.1 编写可变参数函数模板
			16.4.2 包扩展
			16.4.3 转发参数包
		16.5 模板特例化
		小结
		术语表
第Ⅳ部分 高级主题
	第17章 标准库特殊设施
		17.1 tuple类型
			17.1.1 定义和初始化tuple
			17.1.2 使用tuple返回多个值
		17.2 bitset类型
			17.2.1 定义和初始化bitset
			17.2.2 bitset操作
		17.3 正则表达式
			17.3.1 使用正则表达式库
			17.3.2 匹配与Regex迭代器类型
			17.3.3 使用子表达式
			17.3.4 使用regex_replace
		17.4 随机数 
			17.4.1 随机数引擎和分布
			17.4.2 其他随机数分布
		17.5 IO库再探
			17.5.1 格式化输入与输出
			17.5.2 未格式化的输入/输出操作
			17.5.3 流随机访问 
		小结
		术语表
	第18章 用于大型程序的工具
		18.1 异常处理
			18.1.1 抛出异常
			18.1.2 捕获异常
			18.1.3 函数try语句块与构造函数
			18.1.4 noexcept异常说明 
			18.1.5 异常类层次
		18.2 命名空间
			18.2.1 命名空间定义
			18.2.2 使用命名空间成员
			18.2.3 类、命名空间与作用域
			18.2.4 重载与命名空间
		18.3 多重继承与虚继承
			18.3.1 多重继承
			18.3.2 类型转换与多个基类
			18.3.3 多重继承下的类作用域
			18.3.4 虚继承
			18.3.5 构造函数与虚继承
		小结
		术语表
	第19章 特殊工具与技术
		19.1 控制内存分配 
			19.1.1 重载new和delete
			19.1.2 定位new表达式
		19.2 运行时类型识别
			19.2.1 dynamic_cast运算符
			19.2.2 typeid运算符
			19.2.3 使用RTTI
			19.2.4 type_info类
		19.3 枚举类型
		19.4 类成员指针
			19.4.1 数据成员指针
			19.4.2 成员函数指针
			19.4.3 将成员函数用作可调用对象
		19.5 嵌套类
		19.6 union：一种节省空间的类
		19.7 局部类
		19.8 因有的不可移植的特性
			19.8.1 位域
			19.8.2 volatile限定符
			19.8.3 链接指示：extern"C"
		小结
		术语表
附录A 标准库
	A.1 标准库名字和头文件
	A.2 算法概览
		A.2.1 查的对象的算法
		A.2.2 其他只读算法
		A.2.3 二分搜索算法
		A.2.4 写容器元素的算法
		A.2.5 划分与排序算法
		A.2.6 通用重排操作
		A.2.7 排列算法
		A.2.8 有序序列的集合算法
		A.2.9 最小值和最大值 
		A.2.10 数值算法
	A.3 随机数
		A.3.1 随机数分布
		A.3.2 随机数引擎
索引