术语，术语，术语

这不是STL的入门书，所以我认为你知道基本的东西。仍然，下面的术语十分重要，我感到需要强迫复习它们：

● vector、string、deque和list被称为标准序列容器。标准关联容器被是set、multiset、map和multimap。

● 迭代器被分成五个种类，基于它们支持的操作。简要地说，输入迭代器是每个迭代位置只能被读一次的只读迭代器。输出迭代器是每个迭代位置只能被写一次的只写迭代器。输入和输出迭代器被塑造为读和写输入和输出流（例如，文件）。因此并不奇怪输入和输出迭代器最通常的表现分别是istream_iterator和ostream_iterator。

前向迭代器有输入和输出迭代器的能力，但是它们可以反复读或写一个位置。它们不支持operator--，所以它们可以高效地向前移动任意次数。所有标准STL容器都支持比前向迭代器更强大的迭代器，但是，正如你可以在条款25看到的，散列容器的一种设计可以产生前向迭代器。单链表容器（在条款50提到）也提供前向迭代器。

双向迭代器就像前向迭代器，除了它们的后退可以像前进一样容易。标准关联容器都提供双向迭代器。list也有。

随机访问迭代器可以做双向迭代器做的一切事情，但它们也提供“迭代器算术”，即，有一步向前或向后跳的能力。vector、string和deque都提供随机访问迭代器。指进数组的指针可以作为数组的随机访问迭代器。

● 重载了函数调用操作符（即，operator()）的任何类叫做仿函数类。从这样的类建立的对象称为函数对象或仿函数。STL中大部分可以使用函数对象的地方也都可以用真函数，所以我经常使用术语“函数对象”来表示C++函数和真的函数对象。

● 函数bind1st和bind2nd称为绑定器。
STL的一个革命性方面是它的复杂度保证。这些保证约束了任何STL操作允许表现的工作量。这极好，因为它可以帮你确定同一问题不同方法的相对效率，不论你使用的是什么STL平台。不幸的是，如果你不了解计算机科学的行话，在复
杂度保证后面的专有名词可能会把你弄糊涂。这里有一个关于我在本书里使用的复杂度术语的快速入门。每个都引用了它作为n的函数做一件事情要多久，n是容器或区间的元素数目。

● 以常数时间执行的操作的性能不受n的改变而影响，例如，向list中插入一个元素是一个常数时间操作。不管list有一个还是一百万个元素，插入都花费同样数量的时间。
不要太照字面理解占用“常数时间”。 它不意味着做某些事情所花费时间的数量是字面上的常数，它只表明不被n影响。例如，两个STL平台可能花费非常不同数量的时间执行相同的“常数时间”操作。如果一个库比另一个有更复杂的实现，或如果一个编译器执行了充分的更积极优化的时候，这就会发生。
常数时间复杂度的一个变体是分摊常数时间。以分摊常数时间运行的操作通常是常数时间的操作，但偶尔它们花的时间也取决于n。分摊常数时间操作通常以常数时间运行。

● 当n变大时，以对数时间运行的操作需要更多的时间运行，但它需要的时间以与n的对数成正比的比率增长。例如，在一百万个项上的一次操作预计花费大约在一百个项上三倍的时间，因为log n3 = 3 log n。在关联容器上的大多数搜寻操作（例如，set::find）是对数时间操作。

● 以线性时间运行的操作需要的时间以与n成正比的比率增长。标准算法count以线性时间运行，因为它必须查看给定区间中的每个元素。如果区间的大小扩大了三倍，它也必须做三倍的工作，而且我们期望它大约花费三倍时间来完成。

通常，常数时间操作运行得比要求对数时间的快，而对数时间操作运行得比线性的快。当n变得足够大时，这总是真的，但对于n相对小的值，有时候更差理论复杂度的操作可能或胜过更好理论复杂度的操作。如果你想对知道更多STL
复杂度保证的东西，转向Josuttis的《The C++ Standard Library》[3]。

术语的最后一个要注意的东西是，记住map或multimap里的每个元素都有两个组件。我一般叫第一个组件键，叫第二个组件值。以

map<string, double> m;

为例，string是键，double是值。