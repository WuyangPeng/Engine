C++ 编程艺术（The Art of C++）

官方网站：
http://www.osborne.com 

★
作者：Herbert Schildt

知识点 
1.	C++ 基础知识。 

前言
	0.1 本书内容
	0.2 预备知识
	0.3 源代码
第1章 C++功能
	1.1	简洁而丰富的语法
	1.2 功能强大的库
	1.3 STL
	1.4 程序员控制一切
	1.5 细节控制
	1.6 运算符重载
	1.7 一种简洁精练的对象模型
	1.8 C++发展史
第2章 简单的C++垃圾回收器
	2.1 两种内存管理方法的比较
		2.1.1 手工内存管理的优缺点
		2.1.2 垃圾回收的优缺点
		2.1.3 两种方法都可以使用
	2.2 在C++中创建垃圾回收器
	2.3 选择垃圾回收的算法 
		2.3.1 引用计数
		2.3.2 标记并清除
		2.3.3 复制
		2.3.4 采用哪种算法 
		2.3.5 实现垃圾回收器
		2.3.6 是否使用多线程
		2.3.7 何时回收垃圾
		2.3.8 关于auto_ptr
	2.4 一个简单的C++垃圾回收器
	2.5 详细讨论GCPtr
		2.5.1 GCPtr的数据成员
		2.5.2 函数findPtrInfo()
		2.5.3 GCIterator typedef
		2.5.4 GCPtr的构造函数
		2.5.5 GCPtr的析构函数
		2.5.6 回收垃圾函数collect()
		2.5.7 重载赋值运算符
		2.5.8 GCPtr的复制构造函数
		2.5.9 指针运算符和转换函数
		2.5.10 begin()和end()函数
		2.5.11 shutdown()函数
		2.5.12 两个实用函数
	2.6 GCInfo
	2.7 Iter
	2.8 如何使用GCPtr
		2.8.1 处理分配异常
		2.8.2 一个更有趣的示例
		2.8.3 对象的分配和丢弃
		2.8.4 分配数组
		2.8.5 使用具有类类型的GCPtr
		2.8.6 一个比较大的演示程序
		2.8.7 加载测试
		2.8.8 一些限制
	2.9 试着完成下面的任务
第3章 C++中的多线程
	3.1 什么是多线程
	3.2 为什么C++没有内建支持多线程
	3.3 选用什么样的操作系统和编译器
	3.4 Windows线程函数概述
		3.4.1 线程的创建和终止
		3.4.2 Visual C++对CreateThread()和ExitThread()的替换
		3.4.3 线程的挂起和恢复
		3.4.4 改变线程的优先级
		3.4.5 获取主线程的句柄
		3.4.6 同步
	3.5 创建线程控制面板
		3.5.1 线程控制面板
		3.5.2 线程控制面板的详细分析
		3.5.3 控制面板的演示
	3.6 一个多线程的垃圾回收器
		3.6.1 附加的成员变量
		3.6.2 多线程的GCPtr构造函数
		3.6.3 TimeOutExc异常
		3.6.4 多线程的GCPtr析构函数
		3.6.5 gc()函数
		3.6.6 isRunning()函数
		3.6.7 gclist的同步访问
		3.6.8 其他两个改变
		3.6.9 完整的多线程垃圾回收器
		3.6.10 多线程垃圾回收器的使用
	3.7 试着完成下面的任务
第4章 C++的扩展
	4.1 为什么使用译码器
	4.2 实验性的关键字
		4.2.1 foreach 循环
		4.2.2 cases语句
		4.2.3 typeof运算符
		4.2.4 repeat/until循环
	4.3 试验C++新特性的译码器
	4.4 使用译码器
	4.5 译码器的运行方式 
		4.5.1 全局声明
		4.5.2 main()函数
		4.5.3 gettoken()和skipspaces()函数
		4.5.4 转换foreach循环
		4.5.5 转换cases语句 
		4.5.6 转换typeof运算符
		4.5.7 转换repeat/until循环
	4.6 演示程序
	4.7 尝试完成以下任务
第5章 Internet文件下载工具
	5.1 WinINet库
	5.2 文件下载工具子系统
		5.2.1 操作的一般理论
		5.2.2 download()函数
		5.2.3 ishttp()函数
		5.2.4 httpverOK()函数
		5.2.5 getfname()函数
		5.2.6 openfile()函数
		5.2.7 update()函数
	5.3 Download头文件
	5.4 文件下载工具的演示
	5.5 基于GUI的下载工具
		5.5.1 WinDL代码
		5.5.2 WinDL的运行方式
	5.6 尝试完成以下任务
第6章 使用C++的财务计算
	6.1 计算货款的定期偿还
	6.2 计算抽奖的预期价值
	6.3 计算为了获得预期的价值所需的原始投资
	6.4 为了获得预期的养老金所需的原始投资
	6.5 计算给定投资所能得到的养老金的最大值 
	6.6 计算货款余额
	6.7 尝试完成以下任务
第7章 基于AI的问题求解
	7.1 表示法和术语
	7.2 组合爆炸
	7.3 搜索方法
	7.4 需要解决的问题
	7.5 FlightInfo结构和Search类
	7.6 深度优先搜索
		7.6.1 match()函数
		7.6.2 find()函数
		7.6.3 findroute()函数
		7.6.4 显示路线
		7.6.5 深度优先搜索分析
	7.7 广度优先搜索
	7.8 添加启发信息
		7.8.1 爬山搜索法
		7.8.2 爬山法分析
	7.9 最低成本搜索
	7.10 寻找多解
		7.10.1 路径删除
		7.10.2 节点删除
	7.11 寻找“最优”解决方案
	7.12 回到丢失钥匙的问题
	7.13 尝试完成以下任务
第8章 定制STL容器
	8.1 STL的简要回顾
		8.1.1 容器
		8.1.2 算法
		8.1.3 迭代器
	8.2 其他的STL实体
	8.3 定制容器的要求
		8.3.1 一般要求
		8.3.2 序列式容器的其他要求
		8.3.3 关联式容器的要求
	8.4 创建范围可选的动态数组容器
		8.4.1 RangeArray的运行方式
		8.4.2 完整的RangeArray类
		8.4.3 详细讨论RangeArray类
		8.4.4 一些RangeArray示例程序
		8.4.5 尝试完成以下任务
第9章 Mini C++解释程序
	9.1 解释程序和编译器
	9.2 Mini C++纵览
	9.3 Mini C++说明
	9.4 非正式的C++理论
		9.4.1 C++表达式
		9.4.2 定义表达式
	9.5 表达式解析器
		9.5.1 解析器代码
		9.5.2 分解源代码
		9.5.3 显示语法错误
		9.5.4 表达式求值
	9.6 Mini C++解释程序
		9.6.1 main()函数
		9.6.2 解释程序的预扫描程序
		9.6.3 interp()函数
		9.6.4 处理局部变量
		9.6.5 调用用户自定义的函数
		9.6.6 给变量赋值
		9.6.7 执行if语句
		9.6.8 switch语句和break语句
		9.6.9 处理while循环
		9.6.10 处理do-while循环
		9.6.11 for循环
		9.6.12 处理cin和cout语句
	9.7 Mini C++的库函数
	9.8 mccommon.h头文件
	9.9 编译并链接Mini C++解释程序
	9.10 演示Mini C++
	9.11 改进Mini C++
	9.12 扩展Mini C++
		9.12.1 添加新的C++特性
		9.12.2 添加辅助特性
		