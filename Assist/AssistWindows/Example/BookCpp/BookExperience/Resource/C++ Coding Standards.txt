C++ 编程规范（C++ Coding Standards）

★★
作者：Herb Sutter、Andrei Alexandrescu
其他书籍：Herb Sutter 《Exceptional C++》、《More Exceptional C++》、《C++ 编程剖析》，Andrei Alexandrescu 《C++ 设计新思维》

知识点 
1.	C++ 基础知识。 

前言
	★	尽早进入正轨：以同样的方式实施同样的过程。不断积累惯用语。将其标准化。
		如此，你与莎士比亚之间的惟一区别将只是掌握惯用法的多少——而非词汇的多少。
	★	编程规范应该反映业界最久经考验的经验：它应该包含凝聚了经验和对语言的深刻理解的公认的惯用法。
		具体而言，编程规范应该牢固地建立在大量丰富的软件开发文献的基础之上，把散布在各种来源的规则、准则和最佳实践汇集在一起。
	★	许多糟糕的编程规范都是由一些没有很好地理解语言、没有很好地理解软件开发或者试图标准化过多东西的人制定的。
	如何使用本书
	编程规范与人的关系
		★	好的编程规范能够带来下列许多相互关联的优点：
			1.	改善代码质量。
			2.	提高开发速度。
			3.	增进团队精神。
			4.	在正确的方向上取得一致。
	关于本书
	致谢
组织和策略问题
	第0条 不要拘泥于小节
	第1条 在高警告级别干净利落地进行编译
	第2条 使用自动构建系统
	第3条 使用版本控制系统
	第4条 在代码审查上投入
设计风格
	第5条 一个实体应该只有一个紧凑的职责
	第6条 正确、简单和清晰第一
	第7条 编程中应知道何时和如何考虑可伸缩性
	第8条 不要进行不成熟的优化
	第9条 不要进行不成熟的劣化
	第10条 尽量减少全局和共享数据
	第11条 隐藏信息
	第12条 懂得何时和如何进行并发性编程
	第13条 确保资源为对象所拥有。使用显式的RAII和智能指针
编程风格
	第14条 宁要编译时和连接时错误，也不要运行时错误
	第15条 积极使用const
	第16条 避免使用宏
	第17条 避免使用“魔数”
	第18条 尽可能局部地声明变量
	第19条 总是初始化变量
	第20条 避免函数过长，避免嵌套过深
	第21条 避免跨编译单元的初始化依赖
	第22条 尽量减少定义性依赖。避免循环依赖
	第23条 头文件应该自给自足
	第24条 总是编写内部#include保护符，决不要编写外部#include保护符
函数和操作符
	第25条 正确地选择通过值、（智能）指针或者引用传递参数
	第26条 保持重载操作符的自然语义
	第27条 优先使用算术操作符和赋值操作符的标准形式
	第28条 优先使用++和--的标准形式。优先调用前缀形式
	第29条 考虑重载以避免隐含类型转换
	第30条 避免重载&&、||或,（逗号）
	第31条 不要编写依赖于函数参数求值顺序的代码
类的设计与继承
	第32条 弄清所要编写的是哪种类
	第33条 用小类代替巨类
	第34条 用组合代替继承
	第35条 避免从并非要设计成基类的类中继承
	第36条 优先提供抽象接口
	第37条 公用继承即可替换性。继承，不是为了重用，而是为了被重用
	第38条 实施安全的改写
	第39条 考虑将虚拟函数声明为非公用的，将公用函数声明为非虚拟的
	第40条 要避免提供隐式转换
	第41条 将数据成员设为私有的，无行为的聚集除外
	第42条 不要公开内部数据
	第43条 明智地使用Pimpl
	第44条 优先编写非成员非友元函数
	第45条 总是一起提供new和delete
	第46条 如果提供类专门的new，应该提供所有标准形式（普通、就地和不抛出）
构造、析构与复制
	第47条 以同样的顺序定义和初始化成员变量
	第48条 在构造函数中用初始化代替赋值
	第49条 避免在构造函数和析构函数中调用虚拟函数
	第50条 将基类析构函数设为公用且虚拟的，或者保护且非虚拟的
	第51条 析构函数、释放和交换绝对不能失败
	第52条 一致地进行复制和销毁
	第53条 显式地启用或者禁止复制
	第54条 避免切片。在基类中考虑用克隆代替复制
	第55条 使用赋值的标准形式
	第56条 只要可行，就提供不会失败的swap
名字空间与模块
	第57条 将类型及其非成员函数接口置于同一名字空间中
	第58条 应该将类型和函数分别置于不同的名字空间中，除非有意想让它们一起工作
	第59条 不要在头文件中或者#include之前编写名字空间using 
	第60条 要避免在不同的模块中分配和释放内存
	第61条 不要在头文件中定义具有链接的实体
	第62条 不要允许异常跨越模块边界传播
	第63条 在模块的接口中使用具有良好可移植性的类型
模板与泛型
	第64条 理智地结合静态多态性和动态多态性
	第65条 有意地进行显示自定义
	第66条 不要特化函数模板
	第67条 不要无意地编写不通用的代码
错误处理与异常
	第68条 广泛地使用断言记录内部假设和不变式
	第69条 建立合理的错误处理策略，并严格遵守
	第70条 区别错误与非错误
	第71条 设计和编写错误安全代码
	第72条 优先使用异常报告错误
	第73条 通过值抛出，通过引用捕获
	第74条 正确地报告、处理和转换错误
	第75条 避免使用异常规范
STL：容器
	第76条 默认时使用vector。否则，选择其他合适的容器
	第77条 用vector和string代替数组
	第78条 使用vector（和string::c_str）与非C++ API交换数据
	第79条 在容器中只存储值和智能指针
	第80条 用push_back代替其他扩展序列的方式
	第81条 多用范围操作，少用单元素操作
	第82条 使用公认的惯用法直正地压缩容量，真正地删除元素
STL：算法
	第83条 使用带检查的STL实现
	第84条 用算法调用代替手工编写的循环
	第85条 使用正确的STL查找算法 
	第86条 使用正确的STL排序算法 
	第87条 使谓词成为纯函数
	第88条 算法和比较器的参数应多用函数对象少用函数
	第89条 正确编写函数对象
类型安全
	第90条 避免使用类型分支，多使用多态
	第91条 依赖类型，而非其表示方式
	第92条 避免使用reinterpret_cast
	第93条 避免对指针使用static_cast
	第94条 避免强制转换const 
	第95条 不要使用C风格的强制转换
	第96条 不要对非POD进行memcpy操作或者memcmp操作
	第97条 不要使用联合重新解释表示方式
	第98条 不要使用可变长参数
	第99条 不要使用失效对象。不要使用不安全函数
	第100条 不要多态地处理数组
摘要汇总