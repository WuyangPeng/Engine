现代操作系统（Modern Operating Systems）
（第4版）

★
作者：  Andrew S.Tanenbaum、Herbert Bos

前言
作者简介
第1章 引论
	1.1 什么是操作系统
		1.1.1 作为扩展机器的操作系统
		1.1.2 作为资源管理者的操作系统
	1.2 操作系统的历史
		1.2.1 第一代（1945～1955）：真空管和穿孔卡片
		1.2.2 第二代（1955～1965）：晶体管和批处理系统
		1.2.3 第三代（1965～1980）：集成电路和多道程序设计
		1.2.4 第四代（1980年至今）：个人计算机
		1.2.5 第五代（1990年至今）：移动计算机
	1.3 计算机硬件简介
		1.3.1 处理器
		1.3.2 存储器
		1.3.3 磁盘
		1.3.4 I/O设备
		1.3.5 总线
		1.3.6 启动计算机
	1.4 操作系统大观园
		1.4.1 大型机操作系统
		1.4.2 服务器操作系统
		1.4.3 多处理器操作系统
		1.4.4 个人计算机操作系统
		1.4.5 掌上计算机操作系统
		1.4.6 嵌入式操作系统
		1.4.7 传感器节点操作系统
		1.4.8 实时操作系统
		1.4.9 智能卡操作系统
	1.5 操作系统概念
		1.5.1 进程
		1.5.2 地址空间
		1.5.3 文件
		1.5.4 输入/输出
		1.5.5 保护
		1.5.6 shell
		1.5.7 个体重复系统发育
	1.6 系统调用
		1.6.1 用于进程管理的系统调用
		1.6.2 用于文件管理的系统调用
		1.6.3 用于目录管理的系统调用
		1.6.4 各种系统调用
		1.6.5 Windows Win32 API
	1.7 操作系统结构
		1.7.1 单体系统
		1.7.2 层次式系统
		1.7.3 微内核
		1.7.4 客户端C服务器模式
		1.7.5 虚拟机
		1.7.6 外核
	1.8 依靠C的世界
		1.8.1 C语言
		1.8.2 头文件
		1.8.3 大型编程项目
		1.8.4 运行模型
	1.9 有关操作系统的研究
	1.10 本书其他部分概要
	1.11 公制单位
	1.12 小结
	习题
第2章 进程与线程
	2.1 进程
		2.1.1 进程模型
		2.1.2 进程的创建
		2.1.3 进程的终止
		2.1.4 进程的层次结构
		2.1.5 进程的状态
		2.1.6 进程的实现
		2.1.7 多道程序设计模型
	2.2 线程
		2.2.1 线程的使用
		2.2.2 经典的线程模型
		2.2.3 POSIX线程
		2.2.4 在用户空间中实现线程
		2.2.5 在内核中实现线程
		2.2.6 混合实现
		2.2.7 调度程序激活机制
		2.2.8 弹出式线程
		2.2.9 使单线程代码多线程化
	2.3 进程间通信
		2.3.1 竞争条件
		2.3.2 临界区
		2.3.3 忙等待的互斥
		2.3.4 睡眠与唤醒
		2.3.5 信号量
		2.3.6 互斥量
		2.3.7 管程
		2.3.8 消息传递
		2.3.9 屏障
		2.3.10 避免锁：读C复制C更新
	2.4 调度
		2.4.1 调度简介
		2.4.2 批处理系统中的调度
		2.4.3 交互式系统中的调度
		2.4.4 实时系统中的调度
		2.4.5 策略和机制
		2.4.6 线程调度
	2.5 经典的IPC问题
		2.5.1 哲学家就餐问题
		2.5.2 读者C写者问题
	2.6 有关进程与线程的研究
	2.7 小结
	习题
第3章 内存管理
	3.1 无存储器抽象
	3.2 一种存储器抽象：地址空间
		3.2.1 地址空间的概念
		3.2.2 交换技术
		3.2.3 空闲内存管理
	3.3 虚拟内存
		3.3.1 分页
		3.3.2 页表
		3.3.3 加速分页过程
		3.3.4 针对大内存的页表
	3.4 页面置换算法
		3.4.1 页面置换算法
		3.4.2 近未使用页面置换算法
		3.4.3 先进先出页面置换算法
		3.4.4 第二次机会页面置换算法
		3.4.5 时钟页面置换算法
		3.4.6 近少使用页面置换算法
		3.4.7 用软件模拟LRU
		3.4.8 工作集页面置换算法
		3.4.9 工作集时钟页面置换算法
		3.4.10 页面置换算法小结
	3.5 分页系统中的设计问题
		3.5.1 局部分配策略与全局分配策略
		3.5.2 负载控制
		3.5.3 页面大小
		3.5.4 分离的指令空间和数据空间
		3.5.5 共享页面
		3.5.6 共享库
		3.5.7 内存映射文件
		3.5.8 清除策略
		3.5.9 虚拟内存接口
	3.6 有关实现的问题
		3.6.1 与分页有关的工作
		3.6.2 缺页中断处理
		3.6.3 指令备份
		3.6.4 锁定内存中的页面
		3.6.5 后备存储
		3.6.6 策略和机制的分离
	3.7 分段
		3.7.1 纯分段的实现
		3.7.2 分段和分页结合：MULTICS
		3.7.3 分段和分页结合：Intel x86
	3.8 有关内存管理的研究
	3.9 小结
	习题
第4章 文件系统
	4.1 文件
		4.1.1 文件命名
		4.1.2 文件结构
		4.1.3 文件类型
		4.1.4 文件访问
		4.1.5 文件属性
		4.1.6 文件操作
		4.1.7 使用文件系统调用的一个示例程序
	4.2 目录
		4.2.1 一级目录系统
		4.2.2 层次目录系统
		4.2.3 路径名
		4.2.4 目录操作
	4.3 文件系统的实现
		4.3.1 文件系统布局
		4.3.2 文件的实现
		4.3.3 目录的实现
		4.3.4 共享文件
		4.3.5 日志结构文件系统
		4.3.6 日志文件系统
		4.3.7 虚拟文件系统
	4.4 文件系统管理和优化
		4.4.1 磁盘空间管理
		4.4.2 文件系统备份
		4.4.3 文件系统的一致性
		4.4.4 文件系统性能
		4.4.5 磁盘碎片整理
	4.5 文件系统实例
		4.5.1 MS-DOS文件系统
		4.5.2 UNIX V7文件系统
		4.5.3 CD-ROM文件系统
	4.6 有关文件系统的研究
	4.7 小结
	习题
第5章 输入/输出
	5.1 I/O硬件原理
		5.1.1 I/O设备
		5.1.2 设备控制器
		5.1.3 内存映射I/O
		5.1.4 直接存储器存取
		5.1.5 重温中断
	5.2 I/O软件原理 
		5.2.1 I/O软件的目标
		5.2.2 程序控制I/O
		5.2.3 中断驱动I/O
		5.2.4 使用DMA的I/O
	5.3 I/O软件层次
		5.3.1 中断处理程序
		5.3.2 设备驱动程序
		5.3.3 与设备无关的I/O软件 
		5.3.4 用户空间的I/O软件
	5.4 盘
		5.4.1 盘的硬件
		5.4.2 磁盘格式化
		5.4.3 磁盘臂调度算法 
		5.4.4 错误处理
		5.4.5 稳定存储器
	5.5 时钟
		5.5.1 时钟硬件
		5.5.2 时钟软件
		5.5.3 软定时器
	5.6 用户界面：键盘、鼠标和监视器
		5.6.1 输入软件
		5.6.2 输出软件
	5.7 瘦客户机
	5.8 电源管理
		5.8.1 硬件问题
		5.8.2 操作系统问题
		5.8.3 应用程序问题
	5.9 有关输入/输出的研究
	5.10 小结
	习题
第6章 死锁
	6.1 资源
		6.1.1 可抢占资源和不可抢占资源
		6.1.2 资源获取
	6.2 死锁简介
		6.2.1 资源死锁和条件
		6.2.2 死锁建模
	6.3 鸵鸟算法
	6.4 死锁检测和死锁恢复
		6.4.1 每种类型一个资源的死锁检测
		6.4.2 每种类型多个资源的死锁检测
		6.4.3 从死锁中恢复
	6.5 死锁避免
		6.5.1 资源轨迹图
		6.5.2 安全状态和不安全状态
		6.5.3 单个资源的银行家算法 
		6.5.4 多个资源的银行家算法 
	6.6 死锁预防 
		6.6.1 破坏互斥条件
		6.6.2 破坏占有并等待条件
		6.6.3 破坏不可抢占条件
		6.6.4 破坏环路等待条件
	6.7 其他问题
		6.7.1 两阶段加锁
		6.7.2 通信死锁
		6.7.3 活锁
		6.7.4 饥饿
	6.8 有关死锁的研究
	6.9 小结
	习题
第7章 虚拟化和云
	7.1 历史
	7.2 虚拟化的必要条件
	7.3 第一类和第二类虚拟管理程序
	7.4 高效虚拟化技术
		7.4.1 在不支持虚拟化的平台上实现虚拟化
		7.4.2 虚拟化的开销
	7.5 虚拟机管理程序是正确的微内核吗
	7.6 内存虚拟化
	7.7 I/O虚拟化
	7.8 虚拟装置
	7.9 多核CPU上的虚拟机
	7.10 授权问题
	7.11 云
		7.11.1 云即服务
		7.11.2 虚拟机迁移
		7.11.3 检查点
	7.12 案例研究：VMware
		7.12.1 VMware的早期历史
		7.12.2 VMware Workstation
		7.12.3 将虚拟化引入x86的挑战
		7.12.4 VMware Workstation解决方案概览
		7.12.5 VMware Workstation的演变
		7.12.6 VMware的第一类虚拟机管理程序ESX Server
	7.13 有关虚拟化和云的研究
	习题
第8章 多处理机系统
	8.1 多处理机
		8.1.1 多处理机硬件
		8.1.2 多处理机操作系统类型
		8.1.3 多处理机同步
		8.1.4 多处理机调度
	8.2 多计算机
		8.2.1 多计算机硬件
		8.2.2 低层通信软件
		8.2.3 用户层通信软件
		8.2.4 远程过程调用
		8.2.5 分布式共享存储器
		8.2.6 多计算机调度
		8.2.7 负载平衡
	8.3 分布式系统
		8.3.1 网络硬件
		8.3.2 网络服务和协议
		8.3.3 基于文档的中间件
		8.3.4 基于文件系统的中间件
		8.3.5 基于对象的中间件
	8.4 有关多处理机系统的研究
	8.5 小结
	习题 
第9章 安全
	9.1 环境安全
		9.1.1 威胁
		9.1.2 入侵者
	9.2 操作系统完全
		9.2.1 可信系统
		9.2.2 可信计算基
	9.3 保护机制
		9.3.1 保护域
		9.3.2 访问控制列表
		9.3.3 权能字
	9.4 安全系统的形式化模型
		9.4.1 多级安全
		9.4.2 隐蔽信道 
	9.5 密码学原理
		9.5.1 私钥加密技术
		9.5.2 公钥加密技术
		9.5.3 单向函数
		9.5.4 数字签名
		9.5.5 可信平台模块
	9.6 认证
		9.6.1 使用物理识别的认证方式
		9.6.2 使用生物识别的认证方式
	9.7 软件漏洞
		9.7.1 缓冲区溢出攻击
		9.7.2 格式化字符串攻击
		9.7.3 悬垂指针
		9.7.4 空指针间接引用攻击
		9.7.5 整数溢出攻击
		9.7.6 命令注入攻击
		9.7.7 检查时间/使用时间攻击
	9.8 内部攻击
		9.8.1 逻辑炸弹
		9.8.2 后门陷阱
		9.8.3 登录欺骗
	9.9 恶意软件
		9.9.1 特洛伊木马
		9.9.2 病毒
		9.9.3 蠕虫
		9.9.4 间谍软件
		9.9.5 rootkit
	9.10 防御
		9.10.1 防火墙
		9.10.2 反病毒和抑制反病毒技术
		9.10.3 代码签名
		9.10.4 囚禁
		9.10.5 基于模型的入侵检测
		9.10.6 封装移动代码
		9.10.7 Java安全性
	9.11 有关安全的研究
	9.12 小结
	习题
第10章 实例研究1：UNIX、Linux和Android
	10.1 UNIX与Linux的历史
		10.1.1 UNICS
		10.1.2 PDP-11 UNIX
		10.1.3 可移植的UNIX
		10.1.4 Berkeley UNIX
		10.1.5 标准UNIX
		10.1.6 MINIX
		10.1.7 Linux
	10.2 Linux简介
		10.2.1 Linux的设计目标
		10.2.2 到Linux的接口
		10.2.3 shell
		10.2.4 Linux应用程序
		10.2.5 内核结构
	10.3 Linux中的进程
		10.3.1 基本概念
		10.3.2 Linux中进程管理相关的系统调用
		10.3.3 Linux中进程与线程的实现
		10.3.4 Linux中的调度
		10.3.5 启动Linux系统
	10.4 Linux中的内存管理
		10.4.1 基本概念
		10.4.2 Linux中的内存管理系统调用
		10.4.3 Linux中内存管理的实现
		10.4.4 Linux中的分页
	10.5 Linux中的I/O系统
		10.5.1 基本概念
		10.5.2 网络
		10.5.3 Linux中的I/O系统调用
		10.5.4 I/O在Linux中的实现
		10.5.5 Linux中的模块
	10.6 Linux文件系统
		10.6.1 基本概念
		10.6.2 Linux中的文件系统调用
		10.6.3 Linux文件系统的实现
		10.6.4 NFS：网络文件系统
	10.7 Linux的安全性
		10.7.1 基本概念
		10.7.2 Linux中安全相关的系统调用
		10.7.3 Linux中的安全实现
	10.8 Android
		10.8.1 Android与Google
		10.8.2 Android的历史
		10.8.3 设计目标
		10.8.4 Android体系结构
		10.8.5 Linux扩展
		10.8.6 Dalvik
		10.8.7 Binder IPC
		10.8.8 Android应用
		10.8.9 意图
		10.8.10 应用程序沙箱
		10.8.11 安全性
		10.8.12 进程模型
	10.9 小结
	习题
第11章 实例研究2：Windows 8
	11.1 Windows 8.1 的历史
		11.1.1 20世纪80年代：MS-DOS
		11.1.2 20世纪90年代：基于MS-DOS的Windows
		11.1.3 21世纪00年代：基于NT的Windows
		11.1.4 Windows Vista
		11.1.5 21世纪10年代：现代Windows
	11.2 Windows编程
		11.2.1 原生NT应用编程接口
		11.2.2 Win32应用编程接口
		11.2.3 Windows注册表
	11.3 系统结构
		11.3.1 操作系统结构
		11.3.2 启动Windows
		11.3.3 对象管理器实现
		11.3.4 子系统、DLL和用户态服务
	11.4 Windows中的进程和线程
		11.4.1 基本概念
		11.4.2 作业、进程、线程和纤程管理API调用
		11.4.3 进程和线程的实现
	11.5 内存管理
		11.5.1 基本概念
		11.5.2 内存管理系统调用
		11.5.3 存储管理的实现
	11.6 Windows的高速缓存
	11.7 Windows的I/O
		11.7.1 基本概念
		11.7.2 I/O的API调用
		11.7.3 I/O实现
	11.8 Windows NT文件系统
		11.8.1 基本概念
		11.8.2 NTFS文件系统的实现
	11.9 Windows电源管理
	11.10 Windows 8中的安全
		11.10.1 基本概念
		11.10.2 安全相关的API调用
		11.10.3 安全实现
		11.10.4 安全缓解技术
	11.11 小结
	习题
第12章 操作系统设计 
	12.1 设计问题的本质
		12.1.1 目标
		12.1.2 设计操作系统为什么困难
	12.2 接口设计
		12.2.1 指导原则
		12.2.2 范型
		12.2.3 系统调用接口
	12.3 实现
		12.3.1 系统结构
		12.3.2 机制与策略
		12.3.3 正交性
		12.3.4 命名
		12.3.5 绑定的时机
		12.3.6 静态与动态结构
		12.3.7 自顶向下与自底向上的实现
		12.3.8 同步通信与异步通信
		12.3.9 实用技术 
	12.4 性能
		12.4.1 操作系统为什么运行缓慢 
		12.4.2 什么应该优化
		12.4.3 空间――时间的权衡
		12.4.4 缓存
		12.4.5 线索
		12.4.6 利用局部性
		12.4.7 优化常见的情况 
	12.5 项目管理
		12.5.1 人月神话
		12.5.2 团队结构
		12.5.3 经验的作用
		12.5.4 没有银弹
	12.6 操作系统设计的趋势
		12.6.1 虚拟化与云
		12.6.2 众核芯片
		12.6.3 大型地址空间操作系统
		12.6.4 无缝的数据访问
		12.6.5 电池供电的计算机
		12.6.6 嵌入式系统
	12.7 小结
	习题
第13章 参考书目与文献
	13.1 进行深入阅读的建议
		13.1.1 引论
		13.1.2 进程与线程
		13.1.3 内存管理
		13.1.4 文件系统
		13.1.5 输入/输出 
		13.1.6 死锁
		13.1.7 虚拟化和云
		13.1.8 多处理机系统
		13.1.9 安全
		13.1.10 实例研究1：UNIX、Linux和Android
		13.1.11 实例研究2：Windows 8
		13.1.12 操作系统设计
	13.2 按字母顺序排序的参考文献