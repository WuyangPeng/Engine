STL 扩展技术手册（Extended STL）

官方网站：
http://extendedstl.com

★★★
作者：Matthew Wilson
其他书籍 《Imperfect C++》。

知识点 
1.	C++标准库基础知识。 

前言
	目标
	关于主题
	本书结构
	补充材料
致谢
序言
	事物的两面性
		★	要想顺利使用非平凡的抽象，就必须对抽象下面的东西有所了解。
	UNIX编程的原则
		★	清晰原则：清晰用于技巧。
		★	组合原则：设计能够互相连接的组件。
		★	多样性原则：质疑任何被声称为“真正惟一”的途径。
		★	经济原则：和机器的时间相比，程序员的时间是更宝贵的。
		★	可扩展性原则：设计着眼未来，因为未来比你想象得来得更快。
		★	生成原则：避免手动编码，可以的话，编写程序来生成程序。
		★	最小意外原则：在接口设计中作出的决策应该始终是那个令人最少感到意外的选择。
		★	模块化原则：编写简单的模块，模块与模块间通过干净的接口连接。
		★	最大意外原则：如果免不了要失败的话，要弄出最大动静，而且失败得越早越好。
		★	优化原则：首先要能工作，然后能能谈得上优化。
		★	吝啬原则：除非确无它法，否则不要编写大的组件。
		★	健壮性原则：透明性和简单性是健壮性的父母。
		★	分离原则：策略和机制分离，接口与引擎分离。
		★	简单原则：设计应该是简单的，只在必须的时候才增加或暴露复杂性。
		★	透明原则：设计的时候应考虑透明性，以方便检查和调试。
	优秀C++库的七个标志
		★	效率，可发现性与透明性，表达力，健壮性，灵活性，模块性以及可移植性。
		★	可发现性是指要想使用一个组件需要先花上多大功夫来理解它。
		★	透明性是指要想修改一个软件需要先花上多大功夫来理解它。
		★	表达力是指，用尽可能少的语句清晰地完成任务。
	权衡：适应性满足、方言化和新的和老的惯用法
	例库
		★	利用名字空间别名，你就既能使用名字空间层次结构，又能同时尽可能不影响到客户代码。
编排体例
	字体
	...和...
	预先计算终点迭代器
		★	遍历迭代器区间时，尽量预先计算终点迭代器。使用索引时，尽量预先计算集合的大小。
		★	如果有可能我们就当使用算法。
	NULL
	模板参数名
	成员类型的命名，以及名字空间中类型的命名
	调用约定
	终点迭代器
	标准C名字的名字空间
	类适配器和实例适配器
	头文件名字
第一部分 基础
	第1章 标准模板库
		1.1 核心概念
		1.2 容器
			1.2.1 序列容器
			1.2.2 关联容器
			1.2.3 存储空间的连续性
			1.2.4 交换
		1.3 迭代器
			1.3.1 输入迭代器
			1.3.2 输出迭代器
			1.3.3 前向迭代器
			1.3.4 双向迭代器
			1.3.5 随机访问迭代器
			1.3.6 成员选取运算符
			1.3.7 预定义的迭代器适配器
		1.4 算法
		1.5 函数对象
		1.6 分配器
	第2章 扩展STL：STL与真实世界的碰撞
		2.1 术语
		2.2 集合
		2.3 迭代器
			2.3.1 可变性
			2.3.2 遍历
			2.3.3 在编译期决定特性
			2.3.4 元素引用类别
			2.3.5 共享状态信息和独立状态信息
			2.3.6 需要修改迭代器精化的分类吗
	第3章 元素引用类别
		3.1 介绍
		3.2 C++引用 
		3.3 元素引用类别的分类法
			3.3.1 持久引用 
			3.3.2 固定引用 
			3.3.3 可失效引用
			3.3.4 瞬时引用 
			3.3.5 按值临时引用
			3.3.6 空引用 
		3.4 使用元素引用类别
			3.4.1 在编译时检测引用类别
			3.4.2 使用编译器帮助避免迭代器未定义行为
		3.5 定义operator->()
		3.6 元素引用类别：尾声
	第4章 奇异去临时引用
	第5章 DRY SPOT 原则
		5.1 C++编程中符合DRY SPOT的做法
			5.1.1 常量
			5.1.2 dimensionof()
			5.1.3 创建函数
		5.2 C++编程中不太符合DRY SPOT的做法
			5.2.1 父类
			5.2.2 函数返回类型
		5.3 封闭的名字空间
	第6章 抽象泄漏法则
	第7章 契约式编程
		7.1 强制的类型
		7.2 强制的机制
	第8章 约束
		8.1 利用C++类型系统
		8.2 静态断言 
	第9章 垫片
		9.1 介绍
		9.2 主要的垫片
			9.2.1 属性垫片
			9.2.2 转换垫片
		9.3 复合垫片
	第10章 鸭规则和鹅规则：不完备结构一致性的发端
		10.1 一致性
			10.1.1 类型一致性
			10.1.2 结构一致性
			10.1.3 鸭规则和鹅规则
		10.2 显式语义一致性
			10.2.1 概念
			10.2.2 给成员类型打标签
			10.2.3 垫片
		10.3 交集一致性
	第11章 资源获取即初始化
		11.1 资源可变性
		11.2 资源来源
	第12章 模板工具
		12.1 特征类
			12.1.1 base_type_traits
			12.1.2 sign_traits
			12.1.3 类型的特征：迷你特征
			12.1.4 is_integral_type
			12.1.5 is_signed_type
			12.1.6 is_fundamental_type
			12.1.7 is_same_type
		12.2 类型生成器
		12.3 真正的typedef
	第13章 推断式接口适配：编译时适配接口不全的类型
		13.1 介绍
		13.2 适配接口不全的类型
		13.3 适配非变动性集合
		13.4 推断式接口适配
			13.4.1 类型选择
			13.4.2 类型检测
			13.4.3 类型修正
		13.5 把IIA应用于区间
	第14章 Henney假说：当模板参数表太长
	第15章 通过equal()减少友元函数的使用
		15.1 警惕非成员友元函数的滥用
		15.2 集合及其迭代器
	第16章 基本组件
		16.1 介绍
		16.2 auto_buffer
			16.2.1 它不是容器
			16.2.2 类接口
			16.2.3 复制
			16.2.4 分配器宜最后
			16.2.5 swap()
			16.2.6 性能
		16.3 filesystem_traits
			16.3.1 成员类型
			16.3.2 通用字符串处理
			16.3.3 文件系统名字处理
			16.3.4 文件系统状态操作
			16.3.5 文件系统控制操作
			16.3.6 返回类型和错误处理
		16.4 file_path_buffer
			16.4.1 basic_
			16.4.2 UNIX和PATH_MAX
			16.4.3 Windows和PATH_MAX
			16.4.4 缓冲区的使用
		16.5 scoped_handle
		16.6 dl_call()
第二部分 集合
	第17章 适配glob API
		17.1 简介
			17.1.1 动机
			17.1.2 glob API
		17.2 解析使用原始API的版本
		17.3 unixstl::glob_sequence
			17.3.1 公有接口
			17.3.2 成员类型
			17.3.3 成员变量
			17.3.4 标志
			17.3.5 构造 
			17.3.6 glob_sequence元素个数和元素访问
			17.3.7 迭代
			17.3.8 init_glob_()
		17.4 解析使用glob_sequence实现的版本
		17.5 小结
	第18章 插曲：构造函数冲突以及不良的设计 
	第19章 适配opendir/readdir API
		19.1 介绍
			19.1.1 动机
			19.1.2 opendir/readdir API
		19.2 分析直接使用API的代码
		19.3 unixstl::readdir_sequence
			19.3.1 成员类型和成员常量
			19.3.2 构造
			19.3.3 元素迭代和集合大小相关的方法
			19.3.4 提取属性的方法
			19.3.5 const_iterator，版本1
			19.3.6 使用版本1
			19.3.7 const_iterator，版本2：复制语义
			19.3.8 operator++()
			19.3.9 迭代器类别和可适配的成员类型
			19.3.10 operator->()
			19.3.11 支持fullPath和absolutePath标志
		19.4 其他的实现方法
			19.4.1 把迭代结果保存为快照
			19.4.2 把迭代结果保存为迭代器
		19.5 总结
	第20章 适配FindFirstFile/FindNextFile API
		20.1 介绍
			20.1.1 动机
			20.1.2 FindFirstFile/FindNextFile API
		20.2 对例子的分解
			20.2.1 冗长版本
			20.2.2 精简版本
			20.2.3 重解析点和无限递归
		20.3 basic_findfile_sequence的设计
		20.4 winstl::basic_findfile_sequence
			20.4.1 类的接口
			20.4.2 构造
			20.4.3 迭代
			20.4.4 如果编译器不支持异常
		20.5 winstl::basic_findfile_sequence_const_iterator
			20.5.1 构造 
			20.5.2 find_first_file_()
			20.5.3 operator++()
		20.6 winstl::basic_findfile_sequence_value_type
		20.7 垫片
		20.8 basic_findfile_sequence为什么不用垫片和构造函数模板
		20.9 小结
		20.10 结尾：用recls进行文件系统遍历
	第21章 插曲：枚举FTP服务器目录——保持效率和可用性的平衡
		21.1 inetstl::basic_findfile_sequence
		21.2 inetstl::basic_ftpdir_sequence
	第22章 遍历进程和模块
		22.1 集合的特征
		22.2 winstl::pid_sequence
			22.2.1 基于组合的简单实现
			22.2.2 获取进程ID
			22.2.3 没有异常支持时的工作方式
		22.3 winstl::process_module_sequence
		22.4 枚举一个系统中的所有模块
		22.5 排除系统伪进程 
		22.6 处理缺失API头文件的情况
		22.7 总结
	第23章 斐波那契序列
		23.1 简介
		23.2 斐波那契序列
		23.3 STL序列表示的斐波那契数列
			23.3.1 无限序列的接口
			23.3.2 为序列添加契约
			23.3.3 换用别的值类型
			23.3.4 对值类型进行约束
			23.3.5 抛出std::overflow_error
		23.4 可发现性的欠缺
		23.5 定义有限上界
			23.5.1 最终还是要用迭代器
			23.5.2 由构造函数限定的区间
			23.5.3 True_Typedefs
		23.6 小结
	第24章 适配MFC的CArray容器族
		24.1 介绍
		24.2 动机
		24.3 模拟std::vector
		24.4 设计时的考虑
			24.4.1 MFC的数组容器族
			24.4.2 CArray_traits
			24.4.3 数组适配器类的设计
			24.4.4 以抽象方式操纵状态
			24.4.5 Copy-and-Swap惯用法
			24.4.6 编写集合的接口
			24.4.7 教学方法
		24.5 mfcstl::CArray_adaptor_base的接口
		24.6 mfcstl::CArray_cadaptor
			24.6.1 模板声明和继承
			24.6.2 应用CRTP
			24.6.3 CArray_cadaptor的构造 
			24.6.4 operator[]()
		24.7 mfcstl::CArray_iadaptor
		24.8 CArray_adaptor_base的构造 
		24.9 内存分配器
		24.10 元素访问方法
		24.11 元素迭代
			24.11.1 begin()和end()
			24.11.2 rbegin()和rend()
		24.12 和容器大小相关的方法
		24.13 容器容量相关的方法
		24.14 比较相关的方法
		24.15 修改容器结构的方法
			24.15.1 push_back()
			24.15.2 assign()
			24.15.3 pop_back()和clear()
			24.15.4 erase()
			24.15.5 insert()
		24.16 赋值和swap()
		24.17 总结
		24.18 在CD上
	第25章 环境变量的map
		25.1 介绍
		25.2 动机
		25.3 getenv()、putenv()、setenv()、unsetenv()和environ
		25.4 platformstl::enviroment_variable_traits
		25.5 规划接口
		25.6 通过名字查找
			25.6.1 选择1：返回固定/瞬时引用，指向一个缓存对象，具有最新值
			25.6.2 选择2：返回固定引用，指向一个缓存对象，具有快照值
			25.6.3 选择3：返回固定引用，指向一个缓存对象，具有最新值
			25.6.4 选择4：返回按值临时引用，具有最新值
			25.6.5 通过名字查找：尾声
		25.7 通过名字插入、更新和删除值
		25.8 迭代
			25.8.1 第1版：连续迭代器
			25.8.2 第2版：双向迭代器
			25.8.3 第3版：快照
			25.8.4 第4版：引用计数的快照
		25.9 最终的迭代实现
			25.9.1 可变的快照
			25.9.2 创建快照
			25.9.3 const_iterator嵌套类
			25.9.4 insert()方法
			25.9.5 erase()方法
			25.9.6 operator[]()和lookup()
			25.9.7 snapshot嵌套类
		25.10 异质的引用类别
		25.11 size()和下标索引
		25.12 总结
		25.13 在CD上
	第26章 在Z平面上来回穿梭
		26.1 序言
		26.2 介绍
		26.3 第1版：前向迭代
			26.3.1 zorder_iterator，第1版
			26.3.2 window_peer_sequence，第1版
		26.4 第2版：双向迭代
		26.5 处理外部更改
		26.6 winstl::child_window_sequence
		26.7 双向迭代器的蓝调音乐
			26.7.1 end()标记的陷阱
			26.7.2 致命的双重解引用 
			26.7.3 当双向迭代器不是前向迭代器，而是可逆可复制迭代器
		26.8 winstl::zorder_iterator：自身的反转
			26.8.1 zorder_iterator特征类
			26.8.2 zorder_iterator_tmpl<>
			26.8.3 反向的语义
		26.9 同级窗口序列的定稿
		26.10 总结
		26.11 Z平面：尾声
	第27章 字符串分词
		27.1 介绍
		27.2 strtok()
		27.3 SynesisSTL::StringTokeniser
		27.4 字符串分词的用例
		27.5 字符串分词的其他选择
			27.5.1 strtok_r()
			27.5.2 IOStreams
			27.5.3 stlsoft::find_next_token()
			27.5.4 boost::tokenizer
		27.6 stlsoft::string_tokeniser
			27.6.1 stlsoft::string_tokeniser::const_iter
			27.6.2 确定迭代器类别和元素引用类别
			27.6.3 stlsoft::string_tokeniser_type_traits
			27.6.4 stlsoft::string_tokeniser_comparator
		27.7 测试代码
			27.7.1 以单个字符作为分隔符
			27.7.2 字符串作为分隔符
			27.7.3 保留空白字段
			27.7.4 复制还是引用：考虑使用“字符串视图”
			27.7.5 字符集作为分隔符
		27.8 愚蠢的策略类
			27.8.1 经由继承重构模板参数
			27.8.2 类型生成器模板
			27.8.3 关于Henney假说
		27.9 性能
		27.10 总结
	第28章 适配COM枚举器
		28.1 介绍
		28.2 动机
			28.2.1 冗长版
			28.2.2 短小版
		28.3 COM枚举器
			28.3.1 IEnumXXXX::Next()
			28.3.2 IEnumXXXX::Skip()
			28.3.3 IEnumXXXX::Reset()
			28.3.4 IEnumXXXX::Clone()
			28.3.5 枚举器的各种值类型
		28.4 分解冗长版
		28.5 comstl::enumerator_sequence
			28.5.1 comstl::enumerator_sequence的公共接口
			28.5.2 成员类型及成员常量
			28.5.3 值策略
			28.5.4 成员变量
			28.5.5 构造函数
			28.5.6 迭代方法
			28.5.7 迭代器方法的const限定是错误的
			28.5.8 破坏了值语义
		28.6 comstl::enumerator_sequence::iterator
			28.6.1 构造
			28.6.2 迭代方法
			28.6.3 equal()
		28.7 comstl::enumerator_sequence::iterator::enumeration_context
			28.7.1 为什么需要枚举上下文
			28.7.2 类定义
			28.7.3 构造
			28.7.4 迭代器的支持方法
			28.7.5 不变量
		28.8 迭代器复制策略
			28.8.1 comstl::input_cloning_policy
			28.8.2 comstl::forward_cloning_policy
			28.8.3 comstl::cloneable_cloning_policy
		28.9 选择默认的复制策略：应用最小意外原则
		28.10 总结
			28.10.1 为什么不默认使用前向迭代器
			28.10.2 为什么不默认使用输入迭代器
			28.10.3 为什么不把Q固定为1
			28.10.4 为什么不使用标准容器
		28.11 后文提要
	第29章 插曲：运用成员类型推断，纠正设计上的小疏忽
	第30章 适配COM集合
		30.1 介绍
		30.2 动机
			30.2.1 冗长版
			30.2.2 简洁版
		30.3 comstl::collection_sequence
			30.3.1 公有接口
			30.3.2 成员类型和常量
			30.3.3 构造
			30.3.4 迭代：干净地利用一个肮脏的把戏
			30.3.5 size()
		30.4 枚举器获取策略
		30.5 总结
	第31章 聚集分散的I/O
		31.1 介绍
		31.2 分散/聚集 I/O
		31.3 分散/聚集 I/O API
			31.3.1 以COM流实现线性化
			31.3.2 Platformstl::scatter_slice_sequence——预告
		31.4 适配ACE_Message_Queue
			31.4.1 acestl::message_queue_sequence，版本1
			31.4.2 acestl::message_queue_sequence::iterator
		31.5 吃蛋糕时间
			31.5.1 再快些
			31.5.2 acestl::message_queue_sequence，版本2
			31.5.3 特化标准库
			31.5.4 性能
		31.6 总结
	第32章 根据参数返回不同类型
		32.1 介绍
		32.2 向Ruby借颗宝石
		32.3 C++中的双语义下标
		32.4 通过字符串访问垫片扩大兼容性
		32.5 整数的美中不足
		32.6 选择返回类型和重载
		32.7 总结
	第33章 外部迭代器失效
		33.1 元素接口一致性
		33.2 Windows的ListBox和ComboxBox控件
			33.2.1 提取元素的竞争条件
			33.2.2 WinSTL中的listbox_sequence和combobox_sequence类
		33.3 枚举注册表键和值
			33.3.1 那问题在哪
			33.3.2 WinSTL注册表库
			33.3.3 处理外部迭代器失效问题
			33.3.4 winstl::basic_reg_key_sequence
		33.4 总结
		33.5 在CD上
第三部分 迭代器
	第34章 增强版ostream_iterator
		34.1 介绍
		34.2 std::ostream_iterator
		34.3 stlsoft::ostream_iterator
			34.3.1 垫片的应用
			34.3.2 安全语义
			34.3.3 stlsoft::ostream_iterator与std::ostream_iterator的兼容性
			34.3.4 违反了设计原则吗
		34.4 定义流插入运算符
		34.5 小结
	第35章 插曲：借助解引用代理模式，消除笨拙的输出迭代器语法
	第36章 变换迭代器
		36.1 介绍
		36.2 动机
			36.2.1 使用std::transform()的版本
			36.2.2 使用变换迭代器的版本
		36.3 定义迭代器适配器
			36.3.1 创建函数
			36.3.2 值类型
		36.4 stlsoft::transform_iterator
			36.4.1 第一个版本
			36.4.2 构造 
			36.4.3 自增、自减运算符和指针算术方法
			36.4.4 比较运算符和算术运算符
			36.4.5 问题在于
			36.4.6 第二个版本
			36.4.7 stlsoft::transform_iterator
		36.5 复合变换
		36.6 违反了DRY SPOT原则
			36.6.1 使用类型别名和非临时函数对象
			36.6.2 使用异质迭代器和算法
			36.6.3 接受现实，但小心谨慎
		36.7 没准Sequence能帮上点忙
		36.8 小结
		36.9 CD上的内容
	第37章 插曲：命名时谨慎为好
	第38章 成员选取迭代器
		38.1 介绍
		38.2 动机
		38.3 stlsoft::member_selector_iterator
		38.4 创建函数的悲哀
			38.4.1 以非变动性方式访问非常量数组
			38.4.2 以非变动性方式访问常量数组
			38.4.3 以变动性方式访问非常量数组
			38.4.4 通过迭代器类，以非变动性方式访问非常量数组
			38.4.5 通过迭代器类，以非变动性方式访问常量数组
			38.4.6 通过迭代器类，以变动性方式访问非常量数组
			38.4.7 选取常量成员
		38.5 总结
		38.6 在CD上
	第39章 连接C风格字符串
		39.1 动机
		39.2 不灵活的版本
		39.3 stlsoft::cstring_concatenator_iterator
		39.4 创建函数
		39.5 总结
		39.6 CD上的内容
	第40章 字符串对象的连接操作
		40.1 简介
		40.2 stlsoft::string_concatenator_iterator
		40.3 异质字符串类型的良好协作
		40.4 但是
			40.4.1 关于可赋值性
			40.4.2 悬空引用 
			40.4.3 解决方案
		40.5 小结
	第41章 适配迭代器特征类
		41.1 Introduction
		41.2 stlsoft::adapted_iterator_traits
			41.2.1 iterator_category
			41.2.2 value_type
			41.2.3 difference_type
			41.2.4 pointer
			41.2.5 reference
			41.2.6 const_pointer和const_reference
			41.2.7 effective_reference和effective_const_reference
			41.2.8 effective_pointer和effective_const_pointer
			41.2.9 使用这个特征类
	第42章 过滤迭代
		42.1 介绍
		42.2 无效
		42.3 用成员迭代器定义区间
		42.4 那么
		42.5 stlsoft::filter_iterator
			42.5.1 前向迭代器语义
			42.5.2 双向迭代器语义
			42.5.3 随机访问迭代器语义
		42.6 限制迭代器的类别
		42.7 总结
		42.8 在CD上
	第43章 组合多个迭代器适配
		43.1 介绍
		43.2 转换筛选后的迭代器
		43.3 筛选转换后的迭代器
		43.4 两边下注
		43.5 总结
结语
参考书目