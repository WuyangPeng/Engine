算法图解（Grokking Algorithms）

官方网站：
https://www.manning.com/books/grokking-algorithms 、https://github.com/egonschiele/grokking_algorithms

○
作者：Aditya Bhargava

前言
致谢
关于本书
	路线图
	如何阅读本书
	读者对象
	代码约定和下载
	作者在线
第1章 算法简介 
	1.1 引言 
		1.1.1 性能方面 
		1.1.2 问题解决技巧 
	1.2 二分查找 
		1.2.1 更佳的查找方式  
		1.2.2 运行时间
	1.3 大O表示法 
		1.3.1 算法的运行时间以不同的速度增加 
		1.3.2 理解不同的大O运行时间 
		1.3.3 大O表示法指出了最糟情况下的运行时间  
		1.3.4 一些常见的大O运行时间 
		1.3.5 旅行商  
	1.4 小结 
第2章 选择排序 
	2.1 内存的工作原理  
	2.2 数组和链表  
		2.2.1 链表  
		2.2.2 数组  
		2.2.3 术语  
		2.2.4 在中间插入  
		2.2.5 删除  
	2.3 选择排序  
	2.4 小结 
第3章 递归  
	3.1 递归 
	3.2 基线条件和递归条件 
	3.3 栈 
		3.3.1 调用栈  
		3.3.2 递归调用栈  
	3.4 小结 
第4章 快速排序  
	4.1 分而治之  
	4.2 快速排序  
	4.3 再谈大O表示法 
		4.3.1 比较合并排序和快速排序 
		4.3.2 平均情况和最糟情况 
	4.4 小结 
第5章 散列表  
	5.1 散列函数  
	5.2 应用案例  
		5.2.1 将散列表用于查找 
		5.2.2 防止重复  
		5.2.3 将散列表用作缓存 
		5.2.4 小结 
	5.3 冲突 
	5.4 性能 
		5.4.1 填装因子  
		5.4.2 良好的散列函数  
	5.5 小结 
第6章 广度优先搜索 
	6.1 图简介 
	6.2 图是什么  
	6.3 广度优先搜索  
		6.3.1 查找最短路径  
		6.3.2 队列 
	6.4 实现图 
	6.5 实现算法 
	6.6 小结 
第7章 狄克斯特拉算法 
	7.1 使用狄克斯特拉算法  
	7.2 术语 
	7.3 换钢琴 
	7.4 负权边 
	7.5 实现 
	7.6 小结 
第8章 贪婪算法  
	8.1 教室调度问题  
	8.2 背包问题 
	8.3 集合覆盖问题  
	8.4 NP 完全问题  
		8.4.1 旅行商问题详解  
		8.4.2 如何识别NP完全问题  
	8.5 小结 
第9章 动态规划  
	9.1 背包问题 
		9.1.1 简单算法  
		9.1.2 动态规划  
	9.2 背包问题FAQ 
		9.2.1 再增加一件商品将如何呢 
		9.2.2 行的排列顺序发生变化时结果将如何  
		9.2.3 可以逐列而不是逐行填充网格吗  
		9.2.4 增加一件更小的商品将如何呢 
		9.2.5 可以偷商品的一部分吗 
		9.2.6 旅游行程最优化  
		9.2.7 处理相互依赖的情况 
		9.2.8 计算最终的解时会涉及两个以上的子背包吗  
		9.2.9 最优解可能导致背包没装满吗 
	9.3 最长公共子串  
		9.3.1 绘制网格  
		9.3.2 填充网格  
		9.3.3 揭晓答案  
		9.3.4 最长公共子序列
		9.3.5 最长公共子序列之解决方案 
	9.4 小结 
第10章 K最近邻算法 
	10.1 橙子还是柚子  
	10.2 创建推荐系统  
		10.2.1 特征抽取  
		10.2.2 回归 
		10.2.3 挑选合适的特征  
	10.3 机器学习简介  
		10.3.1 OCR 
		10.3.2 创建垃圾邮件过滤器  
		10.3.3 预测股票市场  
	10.4 小结 
第11章 接下来如何做 
	11.1 树 
	11.2 反向索引 
	11.3 傅里叶变换 
	11.4 并行算法 
	11.5 MapReduce  
		11.5.1 分布式算法为何很有用 
		11.5.2 映射函数  
		11.5.3 归并函数  
	11.6 布隆过滤器和HyperLogLog 
		11.6.1 布隆过滤器  
		11.6.2 HyperLogLog 
	11.7 SHA 算法  
		11.7.1 比较文件  
		11.7.2 检查密码  
	11.8 局部敏感的散列算法  
	11.9 Diffie-Hellman 密钥交换  
	11.10 线性规划 
	11.11 结语 
 