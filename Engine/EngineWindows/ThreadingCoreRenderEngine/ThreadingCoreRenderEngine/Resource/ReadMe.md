编码规范

1.  命名空间，类名和函数名以大写字母开头，驼峰式大小写。
2.  变量名以小写字母开头，驼峰式大小写。
3.  宏必须全大写，且以下划线隔开。除了宏之外，不使用全大写的变量名。
4.  成员变量使用m_开头，类静态变量使用sm_开头，全局变量使用g_开头。局部静态变量使用s_开头（可选）。
5.  使用enum class的方式定义枚举。枚举名以大写字母开头，驼峰式大小写。
6.  头文件使用.h的扩展名，源文件使用.cpp的扩展名，内联文件使用.inl的扩展名，json配置文件使用.json的扩展名，
    日志文件使用.log的扩展名，模板实现文件使用.h的扩展名，并以Detail或Achieve结尾。
7.  外部类（导出类）前加XXX_DEFAULT_DECLARE，XXX为所在库名的全大写。
8.  内部类（不导出类）前加XXX_HIDDEN_DECLARE，XXX为所在库名的全大写。
9.  尽量不直接使用除0和1之外的整数值，避免使用文字量，应使用具名常量或具有适当作用域的变量代替。
10. 不同平台或项目配置命名规则：Static + $(Platform) + $(Configuration)，如StaticX64Debug。
11. 使用min和max表示[min,max]区间，使用begin和end表示[begin,end)区间。
12. 禁止注释掉代码，必需保留不执行的代码使用预处理器。
13. 定义宏为空时，使用static_cast<void>(0)，可防止宏被用作右值。
14. 使用using代替typedef。
15. 整型转换不使用static_cast，转换失败抛出异常使用boost::numeric_cast，不能抛出异常使用gsl::narrow_cast消除警告。
16. 使用make_shared和make_unique来创建智能指针，而不是new。
17. 使用必要的noexcept、final和override。
18. 对直接抛出异常的函数使用[[noreturn]] 。
19. 对必须检查返回值的函数使用[[nodiscard]]。
20. 对可能不会使用的参数使用[[maybe_unused]]。
21. 对于没有break的case标签使用[[fallthrough]]。
22. 对于内置类型，优先使用bool、char、int、double和必要的size_t。
    需要使用其它类型时，尽量使用固定大小的整型。网络或系统相关调用必须使用固定大小的整型。

设计规范

1.  使用C++17标准。
2.  所有在各个操作系统实现不同的函数，全转移到System库。
3.  除System库外，尽量不使用参数返回值。与性能相关，需要使用参数返回时，转移到各个库的底层调用模块中，如Mathematics库增加Underlying模块。
4.  除Sysetm库外，所有类必须使用类不变式，并定义ClassType和必要的ParentType，且尽量使用ASSETRTION。
    由于调试性能原因，不直接调用内部类的类不变式，即调用“m_Impl->IsValid();”。
5.  所有单例及静态数据调用必须使用锁。
6.  将警告设置为Level4，并将警告视为错误，代码需要通过代码分析。
7.  禁止浮点数直接比较相等或不相等。
8.  在没有明显的理由需要指定数据类型时，一般使用auto。
9.  使用初始化器列表的形式初始化，只在必要时使用括号形式（如vector）和等号形式（如auto）初始化。
10. 除特殊需求外，禁止返回空指针、传递空指针和使用裸指针。
11. 只包含必须包含的头文件，头文件的包含顺序：从最特殊到最一般。本地目录中的任何头文件首先被包含，
    然后是我们自己的所用工具头文件，随后是第三方库头文件，接着是标准C++库头文件和C库头文件。
12. 除非你确实需要共享所有权，否则别轻易使用shared_ptr，请使用unique_ptr。
    但由于unique_ptr析构函数需要知道指定类的大小，Impl模式不使用unique_ptr封装指针，而使用更容易编程的shared_ptr。
13. 同时存在标准库和boost库实现时，使用标准库的实现。
14. 把指针用于“按引用传递”参数，把const引用用于“按值传递”参数。
15. 首选传值方式而不是const引用方式返回函数的结果。
16. 错误使用异常而非返回码。
17.	派生类的前置条件相比基类可以更宽松，但不能更严格。 
18.	派生类应该从基类继承所有后置条件。
19.	移动构造函数和移动赋值运算符必须定义成noexcept。
20.	函数都是异常安全的，这意味着它们至少提供基本异常安全保证。
21. 使用Impl模式封装类，通过定义ClassShareType来标识类是属于：
   （1）当类必须共享资源时，复制只是复制类的指针成员，需要在类前注释（共享类），构造函数和赋值运算符进行简单的复制指针。共享类必须以Share结尾。
   （2）类没有修改自身的成员函数，为了提高性能，复制只是复制类的指针成员，构造函数和赋值运算符进行简单的复制指针。
   （3）类有修改自身的成员函数，此时定义复制构造函数和赋值运算符对类进行深复制。
   （4）类有修改自身的成员函数，构造函数和赋值运算符简单的复制指针，只在调用非常量成员函数时对类进行深复制，即写时复制机制（Copy on Write，COW）。
        但以下情况禁止使用延迟复制：
	    导出类有虚函数的情况下。
        导出类内部某个成员析构函数有特殊调用的情况下。
	    导出类有返回内部成员的引用或指针的情况下。
   （5）类禁止复制。
22. 所有类必须有单元测试，并通过测试。单元测试包括完整测试、固定值测试、随机值测试和迭代测试，每个测试一个概念。单元测试一般不测试类不变式和断言。
    测试使用构造――操作――检验模式，必须满足五个条件：快速、独立、可重复、自足验证和及时。测试最重要的要素是可读性。

建议规范

1. 函数要短，命名清晰。
2. 减少if、for的使用，使用子类或for_each。
3. 对于p是指针，使用if(p != nullptr)，而不是更简洁的if(p)或if(nullptr != p)。
4. 避免使用do语句。
5. 使用弱指针weak_ptr保存对象，而不是使用保存对象id，然后通过单例去索引。
6. 任何编写类模板或函数模板的程序员都应该将概念检查作为他们所编写的代码的正常部分。
7. 声明一个类或函数时，使用包含头文件的方法。如果一个库很大，应该提供一个头文件的简写形式。
8. 使用move和forward的代码应该使用std::move和std::forward而不使用using声明。这样做可以避免潜在的名字冲突。
9. 按照数轴的顺序或变量――常量的顺序编写数值表达式。
11.if语句、else语句、while语句等，其中的代码块应该只有一行。该行大抵应该是一个函数调用语句。
12.把try和catch代码块的主体部分抽离出来，另外形成函数。
13.当向const函数传入引用或指针时，也要考虑该参数是否可以声明为const。
14.优先使用函数重载而不是默认参数。

注释规范

1. 使用Doxygen的注释风格。
2. 使用/// @的风格。
3. 主页标识： mainpage
4. 版权信息： copyright 
5. 作者信息： author 
6. 版本信息： version
7. 日期： date 
8. 简要说明： brief 
9. 类名：class 
10.返回结果描述： return 
11.类不变式描述： invariant 
12.前置条件描述： pre 
13.后置条件描述： post 
14.代码示例：code endcode 
15.分组标识：ingroup 
     
