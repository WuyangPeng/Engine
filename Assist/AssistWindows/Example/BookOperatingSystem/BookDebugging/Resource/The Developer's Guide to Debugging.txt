软件调试实战 （The Developer's Guide to Debugging）

官方网站：    
http://www.debugging-guide.com/

★
作者：Thorsten Grotker、Ulrich Holtmann、Holger Keding、Markus Wloka

知识点 
1.	调试基础知识。 

序
前言
	本书的网站
致谢
第1章　谁编写软件，谁制造bug（为什么需要本书）  
第2章　系统性调试方法  
	2.1　为什么要遵循结构化的过程  
	2.2　充分利用机会  
	2.3　13条黄金规则  
		2.3.1　理解需求  
		2.3.2　制造失败  
		2.3.3　简化测试用例  
		2.3.4　读取恰当的错误消息  
		2.3.5　检查显而易见的问题  
		2.3.6　从解释中分离出事实  
		2.3.7　分而治之  
		2.3.8　工具要与bug匹配  
		2.3.9　一次只做一项更改  
		2.3.10　保持审计跟踪  
		2.3.11　获得全新观点  
		2.3.12　bug不会自己修复  
		2.3.13　用回归测试来检查bug修复  
	2.4　构建一个好的工具包  
		2.4.1　工具箱  
		2.4.2　每天运行测试，防止出现bug  
	2.5　认清敌人——遇到bug家族  
		2.5.1　常见bug  
		2.5.2　偶发性bug  
		2.5.3　heisenbug  
		2.5.4　隐藏在bug背后的bug  
		2.5.5　秘密bug——调试与机密性  
		2.5.6　更多读物  
第3章　查找根源——源代码调试器 
	3.1　可视化程序行为 
	3.2　准备简单的可预测的示例 
	3.3　使调试器与程序一起运行 
	3.4　学习在程序崩溃时执行栈跟踪 
	3.5　学习使用断点  
	3.6　学习在程序中导航  
	3.7　学习检查数据：变量和表达式  
	3.8　一个简单示例的调试会话  
第4章　修复内存问题 
	4.1　C/C++中的内存管理——功能强大但很危险  
		4.1.1　内存泄漏  
		4.1.2　内存管理的错误使用  
		4.1.3　缓冲区溢出  
		4.1.4　未初始化的内存bug  
	4.2　有效的内存调试器  
	4.3　示例1：检测内存访问错误  
		4.3.1　检测无效的写访问  
		4.3.2　检测对未初始化的内存的读取操作  
		4.3.3　检测内存泄漏  
	4.4　示例2：对内存分配/释放的不完整调用  
	4.5　结合使用内存调试器和源代码测试器  
	4.6　减少干扰，排查错误  
	4.7　何时使用内存调试器  
	4.8　约束  
		4.8.1　测试用例应该有很好的代码覆盖率  
		4.8.2　提供更多计算机资源  
		4.8.3　可能不支持多线程  
		4.8.4　对非标准内存处理程序的支持  
第5章　剖析内存的使用  
	5.1　基本策略——主要步骤  
	5.2　示例：分配数组  
	5.3　第1步：查找泄漏  
	5.4　第2步：设置期望值  
	5.5　第3步：测量内存使用  
		5.5.1　使用多个输入  
		5.5.2　在固定时间间隔停止程序  
		5.5.3　用简单工具测量内存使用  
		5.5.4　使用top  
		5.5.5　使用windows task manager  
		5.5.6　为testmalloc选择相关输入值  
		5.5.7　确定机器上的内存是如何被释放的  
		5.5.8　使用内存剖析工具  
	5.6　第4步：查明大部分内存被哪些数据结构占用了  
	5.7　综合练习——genindex示例  
		5.7.1　核实没有大的内存泄漏  
		5.7.2　估计内存使用  
		5.7.3　测量内存使用  
		5.7.4　查找使用内存的数据结构  
第6章　解决性能问题  
	6.1　分步查找性能bug  
		6.1.1　执行前期分析   
		6.1.2　使用简单的时间测量方法  
		6.1.3　创建测试用例  
		6.1.4　使测试用例具有可再现性  
		6.1.5　检查程序的正确性  
		6.1.6　创建可扩展的测试用例  
		6.1.7　排除对测试用例的干扰  
		6.1.8　用time命令测量时可能会发生错误和偏差  
		6.1.9　选择一个能够揭示运行时间瓶颈的测试用例  
		6.1.10　算法与实现之间的差异  
	6.2　使用剖析工具  
		6.2.1　不要编写自己的剖析工具  
		6.2.2　剖析工具的工作原理  
		6.2.3　了解gprof  
		6.2.4　了解quantify  
		6.2.5　了解callgrind  
		6.2.6　了解vtune  
	6.3　分析I/O性能  
第7章　调试并行程序  
	7.1　用C/C++编写并行程序  
	7.2　调试竞争条件  
		7.2.1　使用基本调试器功能来查找竞争条件  
		7.2.2　使用日志文件来查找竞争条件  
	7.3　调试死锁  
		7.3.1　如何确定正在运行的是哪个线程  
		7.3.2　分析程序的线程  
	7.4　了解线程分析工具  
	7.5　异步事件和中断处理程序  
第8章　查找环境和编译器问题  
	8.1　环境变更——问题的根源  
		8.1.1　环境变量  
		8.1.2　本地安装依赖  
		8.1.3　当前工作目录依赖  
		8.1.4　进程id依赖  
	8.2　如何查看程序正在做什么  
		8.2.1　用top来查看进程  
		8.2.2　用ps来查找应用程序的多个进程  
		8.2.3　使用/proc/[pid]来访问进程  
		8.2.4　使用strace跟踪对操作系统的调用  
	8.3　编译器和调试器也有bug  
		8.3.1　编译器bug  
		8.3.2　调试器和编译器兼容性问题  
第9章　处理链接问题  
	9.1　链接器的工作原理  
	9.2　构建并链接对象  
	9.3　解析未定义的符号  
		9.3.1　丢失链接器参数  
		9.3.2　搜索丢失的符号  
		9.3.3　链接顺序问题  
		9.3.4　C++符号和名称改编  
		9.3.5　符号的反改编  
		9.3.6　链接C和C++代码  
	9.4　具有多个定义的符号  
	9.5　信号冲突  
	9.6　识别编译器和链接器版本不匹配  
		9.6.1　系统库不匹配  
		9.6.2　对象文件不匹配  
		9.6.3　运行时崩溃  
		9.6.4　确定编译器版本  
	9.7　解决动态链接问题  
		9.7.1　链接或载入dll  
		9.7.2　无法找到dll文件  
		9.7.3　分析载入器问题  
		9.7.4　在dll中设置断点  
		9.7.5　提供dll问题的错误消息  
第10章　高级调试  
	10.1　在C++函数、方法和操作符中设置断点  
	10.2　在模板化的函数和C++类中设置断点  
	10.3　进入C++方法  
		10.3.1　用step-into命令进入到隐式函数中  
		10.3.2　用step-out命令跳过隐式函数  
		10.3.3　利用临时断点跳过隐式函数  
		10.3.4　从隐式函数调用返回  
	10.4　条件断点和断点命令  
	10.5　调试静态构造/析构函数  
		10.5.1　由静态初始化程序的顺序依赖性引起的bug  
		10.5.2　识别静态初始化程序的栈跟踪  
		10.5.3　在静态初始化之前连接调试器  
	10.6　使用观察点  
	10.7　捕捉信号  
	10.8　捕获异常  
	10.9　读取栈跟踪  
		10.9.1　带调试信息编译的源代码的栈跟踪  
		10.9.2　不带调试信息编译的源代码的栈跟踪  
		10.9.3　不带任何调试信息的帧  
		10.9.4　实际工作中的栈跟踪  
		10.9.5　改编后的函数名称  
		10.9.6　被破坏的栈跟踪  
		10.9.7　核心转储  
	10.10　操纵正在运行的程序  
		10.10.1　修改变量  
		10.10.2　调用函数  
		10.10.3　修改函数的返回值  
		10.10.4　中止函数调用  
		10.10.5　跳过或重复执行个别语句  
		10.10.6　输出和修改内存内容  
	10.11　在没有调试信息时进行调试  
		10.11.1　从栈读取函数参数  
		10.11.2　读取局部/全局变量和用户定义的数据类型  
		10.11.3　在源代码中查找语句的大概位置  
		10.11.4　走查汇编代码  
第11章　编写可调试的代码  
	11.1　注释的重要性  
		11.1.1　函数签名的注释  
		11.1.2　对折中办法的注释  
		11.1.3　为不确定的代码加注释  
	11.2　采用一致的编码风格  
		11.2.1　仔细选择名称  
		11.2.2　不要使用“聪明过头”的结构  
		11.2.3　不要压缩代码  
		11.2.4　为复杂表达式使用临时变量  
	11.3　避免使用预处理器宏  
		11.3.1　使用常量或枚举来替代宏  
		11.3.2　使用函数来替代预处理器宏  
		11.3.3　调试预处理器输出  
		11.3.4　使用功能更强的预处理器  
	11.4　提供更多调试函数  
		11.4.1　显示用户定义的数据类型  
		11.4.2　自检查代码  
		11.4.3　为操作符创建一个函数，以便帮助调试  
	11.5　为事后调试做准备  
第12章　静态检查的作用  
	12.1　使用编译器作为调试工具  
		12.1.1　不要认为警告是无害的   
		12.1.2　使用多个编译器来检查代码  
	12.2　使用lint  
	12.3　使用静态分析工具  
		12.3.1　了解静态检查器  
		12.3.2　将静态检查器检测到的错误减至（接近）零  
		12.3.3　完成代码清理后重新运行所有测试用例  
	12.4　静态分析的高级应用  
第13章　结束语  
附录A　调试命令  
附录B　工具资源  
附录C　源代码  