Imperfect C++

官方网站：
http://imperfectcplusplus.com。

★★★★★
作者：Matthew Wilson
其他书籍：《STL 扩展技术手册》。

知识点 
1.	C++ 知识。

代码
1.  书籍代码。 

前言
	★ 尽量发挥想象力进行创造
	你将从中学到什么
	我假设你们已经知道 
	本书的组织方式 
	参考资料
	补充材料
	致谢
不完美主义实践者的哲学
	★ C++是卓越的，但并不完美。
	★ 穿上“苦行衣”。
	★ 让编译器成为你的仆从。
	★ 永不言弃，总会有解决方案。
	C++并不完美
	苦行僧式编程
	★ 懒惰意味着你不想在运行期查错；懒惰意味着你不想第二次犯同样的错误；懒惰意味着尽可能地榨取你的编译器能力，这样你才得以清闲。
	让编译器成为你的仆从
	永不言败
	★ 从理论上说，理论与实践是没有任何区别的，但是从实践的角度来说，它们之间区别就大了。
	“Imperfect C++”的精神
	★ 尽可能地在编译期捕获错误。
	★ 尽量避开预处理。
	★ 在不可能使用编译期错误侦测的情况下采用契约式设计。
	编码风格
	术语
	★ 聚合体：一个数组，或一个无用户自定义构造函数，无private或protected的非静态数据成员、无基类并且无虚函数的类。
	★ POD类型：标量类型、POD结构类型、POD联合类型，以上这些类型的数组，以及这些类型以const/volatile修饰的版本。
	★ POD结构：一个聚合体类，其任何非静态成员的类型都不能是如下任何一种：指向成员的指针、非POD结构、非POD联合，以及以上这些类型的数组或引用，
				同时该聚合体类不允许包含用户自定义的拷贝赋值操作符和用户自定义的析构函数。
	★ POD类型允许我们与C函数进行交互。
	★ 指向成员的指针不是POD类型，这一点跟其他任何指针类型恰恰相反。
	★ POD结构或POD联合类型可以具有静态成员、成员typedef、嵌套类型和方法。
Imperfection、定义和建议
	★ 使用断言来断言关于代码结构的条件式，而不要断言关于运行期行为的条件式。
	★ RRID是这么一种机制，它利用C++对自动的确定性析构的支持，来确保与某个封装类型的实例相关联的资源能够得到确定性的释放。
	★ RAII是这么一种机制，它利用C++对构造和自动的确定性析构的支持，来确保跟某个封装类型的实例相关联的资源能够得到确定性的释放，可以将其看成是RRID机制的超集。
	★ 不要依赖于全局对象初始化顺序。至少应该辅以全局对象初始化顺序跟踪机制。
	★ 不要在全局对象初始化期间创建线程。
	★ 对operator &()的重载会破坏封装性。
	★ 同时提供下标索引操作符和向指针类型转换的隐式转换操作符是不可移植的做法。
	★ 针对类类型重载&&和||操作符会悄悄打破它们的短路求值特性。
第一部分 基础知识
	第1章  强制设计：约束、契约和断言
		1.1 绿蛋和火腿
		1.2 编译期契约：约束
			1.2.1 must_have_base()
			1.2.2 must_be_subscriptable()
			1.2.3 must_be_subscriptable_as_decayable_pointer()
			1.2.4 must_be_pod()
			1.2.5 must_be_same_size()
			1.2.6 使用约束
			1.2.7 约束和TMP
			1.2.8 约束：尾声
		1.3 运行期契约：前置条件、后置条件和不变式
			1.3.1 前置条件
			1.3.2 后置条件
			1.3.3 类不变式
			1.3.4 检查？总是进行
			1.3.5 DbC还是不DbC
			1.3.6 运行期契约：尾声
		1.4 断言 
			1.4.1 获取消息
			1.4.2 不恰当的断言 
			1.4.3 语法以及64位指针
			1.4.4 避免使用verify()
			1.4.5 为你的断言命名
			1.4.6 避免使用#ifdef _DEBUG
			1.4.7 DebugBreak()和int 3
			1.4.8 静态/编译期断言 
			1.4.9 断言：尾声
	第2章  对象生命期
		2.1 对象生命周期
		2.2 控制你的客户端
			2.2.1 成员类型
			2.2.2 缺省构造函数
			2.2.3 拷贝构造函数
			2.2.4 拷贝赋值
			2.2.5 new和delete
			2.2.6 虚析构
			2.2.7 explicit
			2.2.8 析构函数
			2.2.9 友元
		2.3 MIL及其优点
			2.3.1 取得一块更大的场地
			2.3.2 成员顺序依赖
			2.3.3 offsetof()
			2.3.4 MIL：尾声
	第3章  资源封装
		3.1 资源封装分类
		3.2 POD类型
			3.2.1 直接操纵
			3.2.2 API函数和透明类型
			3.2.3 API函数和不透明类型
		3.3 外覆代理类
		3.4 RRID类型
			3.4.1 缺省初始化：缓式初始化
			3.4.2 未初始化
		3.5 RAII类型
			3.5.1 常性RAII和易变性RAII
			3.5.2 内部初始化和外部初始化
			3.5.3 RAII排列
		3.6 RAII：尾声
			3.6.1 不变式
			3.6.2 错误处理
	第4章  数据封装和值类型
		4.1 数据封装的分类学
		4.2 值类型和实体类型
		4.3 值类型的分类学
		4.4 开放式类型
			4.4.1 POD开放式类型
			4.4.2 C++数据结构
		4.5 封装式类型
		4.6 值类型
		4.7 算术值类型
		4.8 值类型：尾声
		4.9 封装：尾声
	第5章  对象访问模型
		5.1 确定性生命期
		5.2 返回拷贝
		5.3 直接交给调用者
		5.4 共享对象
	第6章  域守卫类
		6.1 值
		6.2 状态
		6.3 API和服务
			6.3.1 API
			6.3.2 服务
		6.4 语言特性
第二部分 生存在现实世界
	第7章  ABI
		7.1 共享代码
		7.2 C API需求
			7.2.1 结构布局
			7.2.2 调用约定、符号名以及目标文件格式
			7.2.3 静态连接
			7.2.4 动态连接
		7.3 C++ API需求
			7.3.1 对象布局
			7.3.2 虚函数
			7.3.3 调用约定和名字重整
			7.3.4 静态连接
			7.3.5 动态连接
		7.4 现在知道怎么做了
			7.4.1 extern "C"
			7.4.2 名字空间
			7.4.3 extern "C++"
			7.4.4 获得C++类的句柄 
			7.4.5 “由实现定义”的隐患
	第8章  跨边界的对象
		8.1 近乎可移植的虚函数表
			8.1.1 虚函数表布局
			8.1.2 动态操纵虚函数表
		8.2 可移植的虚函数表
			8.2.1 利用宏进行简化
			8.2.2 兼容的编译器
			8.2.3 可移植的服务器对象
			8.2.4 简化可移植接口的实现
			8.2.5 C客户代码
			8.2.6 OAB的约束
		8.3 ABI/OAB尾声
	第9章  动态库
		9.1 显示调用函数
			9.1.1 显式调用C++函数
			9.1.2 打破C++访问控制
		9.2 同一性：连接单元和连接空间
			9.2.1 连接单元
			9.2.2 连接空间
			9.2.3 多重身份
		9.3 生命期
		9.4 版本协调
			9.4.1 丢失的函数
			9.4.2 变化的签名
			9.4.3 行为的改变
			9.4.4 常量
		9.5 资源所有权
			9.5.1 共享池
			9.5.2 返还给被调用方
		9.6 动态库：尾声
	第10章  线程
		10.1 对整型值的同步访问
			10.1.1 操作系统函数
			10.1.2 原子类型
		10.2 对（代码）块的同步访问：临界区
			10.2.1 进程间互斥体和进程内互斥体
			10.2.2 自旋互斥体
		10.3 原子整型的性能
			10.3.1 基于互斥体的原子整型
			10.3.2 运行期按架构派发
			10.3.3 性能比较
			10.3.4 原子整型操作：尾声
		10.4 多线程扩展
			10.4.1 synchronized
			10.4.2 匿名synchronized
			10.4.3 atomic
		10.5 线程相关的存储
			10.5.1 重入
			10.5.2 线程相关的数据/线程局部存储
			10.5.3 declspec(thread)和TLS
			10.5.4 tss库
			10.5.5 TSS的性能
	第11章  静态对象
		11.1 非局部静态对象：全局对象
			11.1.1 编译单元内的顺序性
			11.1.2 编译单元间的顺序性
			11.1.3 利用main()避免全局变量
			11.1.4 全局对象尾声：顺序性
		11.2 单件
			11.2.1 Meyers单件
			11.2.2 Alexandrescu单件
			11.2.3 即时Schwarz计数器：一个极妙的主意
			11.2.4 对API计数
			11.2.5 被计数的API、外覆类、代理类：最终得到一个顺序化的单件
		11.3 函数范围内的静态对象
			11.3.1 牺牲缓式求值能力
			11.3.2 自旋互斥体是救星
		11.4 静态成员
			11.4.1 解决连接问题
			11.4.2 自适应代码
		11.5 静态对象：尾声
	第12章  优化
		12.1 内联函数
			12.1.1 警惕过早优化
			12.1.2 只含有头文件的库
		12.2 返回值优化
		12.3 空基类优化
		12.4 空派生类优化
		12.5 阻止优化
第三部分 语言相关的议题
	第13章  基本类型
		13.1 可以给我来一个字节吗
			13.1.1 标明符号
			13.1.2 一切都在名字之中
			13.1.3 窥探void内部
			13.1.4 额外的安全性
		13.2 固定大小的整型
			13.2.1 平台无关性
			13.2.2 类型相关的行为
			13.2.3 固定大小的整型：尾声
		13.3 大整型
		13.4 危险的类型
			13.4.1 引用和临时对象
			13.4.2 bool
	第14章  数组和指针
		14.1 不要重复你自己
		14.2 数组退化为指针
			14.2.1 下标索引操作符的交换性
			14.2.2 阻止退化
		14.3 dimensionof()
		14.4 无法将数组传递给函数
		14.5 数组总是按地址进行传递
		14.6 派生类的数组
			14.6.1 通过指针保存多态类型
			14.6.2 提供非缺省的构造函数
			14.6.3 隐藏向量式new和delete
			14.6.4 使用std::vector
			14.6.5 确保类型的大小相同
		14.7 不能拥有多维数组
	第15章  值
		15.1 NULL的是非曲直
		15.2 回到0
		15.3 屈服于事实 
		15.4 字面量
			15.4.1 整型
			15.4.2 后缀
			15.4.3 字符串
		15.5 常量
			15.5.1 简单常量
			15.5.2 类类型常量
			15.5.3 成员常量
			15.5.4 类类型的成员常量
	第16章  关键字
		16.1 interface
		16.2 temporary
		16.3 owner
		16.4 explicit(_cast)
			16.4.1 使用显式访问函数
			16.4.2 模拟显式转换
			16.4.3 使用我性垫片
		16.5 unique
		16.6 final
		16.7 不被支持的关键字
	第17章  语法
		17.1 类的代码布局
		17.2 条件表达式
			17.2.1 “使它布尔”
			17.2.2 一个危险的赋值
		17.3 for
			17.3.1 初始化作用域
			17.3.2 异质初始化类型
		17.4 变量命名
			17.4.1 匈牙利命名法
			17.4.2 成员变量
	第18章  Typedef
		18.1 指针typedef
		18.2 定义里面有什么
			18.2.1 概念性的类型定义
			18.2.2 上下文相关的类型定义
		18.3 别名
			18.3.1 错误的概念性类型互换
			18.3.2 不能对概念性类型进行重载
		18.4 true_typedef
		18.5 好的、坏的、丑陋的
			18.5.1 好的typedef
			18.5.2 坏的typedef
			18.5.3 可疑的typedef
第四部分 感知式转换
	第19章  强制
		19.1 隐式转换
		19.2 C++中的强制
		19.3 适合使用C强制的场合
		19.4 模仿强制
		19.5 explicit_cast
		19.6 literal_cast
		19.7 union_cast
		19.8 comstl::interface_cast
			19.8.1 interface_cast_addref
			19.8.2 interface_cast_noaddref
			19.8.3 interface_cast_test
			19.8.4 接口强制操作符的实现
			19.8.5 保护引用计数
			19.8.6 interface_cast_base
			19.8.7 IID_traits
			19.8.8 interface_cast 尾声
		19.9 boost::polymorphic_cast
		19.10 强制：尾声
	第20章  垫片
		20.1 拥抱变化 拥抱自由
		20.2 特性垫片
		20.3 逻辑垫片
		20.4 控制垫片
		20.5 转换垫片
		20.6 复合式垫片概念
			20.6.1 访问垫片
			20.6.2 返回值生命期
			20.6.3 泛化的类型操纵
			20.6.4 效率方面的考虑
		20.7 名字空间和Koenig查找
		20.8 为何不使用traits
		20.9 结构一致性
		20.10 打破巨石
		20.11 垫片：尾声
	第21章  饰面
		21.1 轻量级RAII
		21.2 将数据和操作绑定在一起
			21.2.1 pod_veneer
			21.2.2 创建日志消息
			21.2.3 减少浪费
			21.2.4 类型安全的消息类
		21.3 “擦亮”饰面概念
		21.4 饰面：尾声
	第22章  螺栓
		22.1 添加功能
		22.2 皮肤选择
		22.3 非虚重写
		22.4 巧用作用域
		22.5 拟编译期多态：逆反式螺栓
		22.6 参数化多态包装
		22.7 螺栓：尾声
	第23章  模板构造函数
		23.1 不易察觉的开销
		23.2 悬挂引用
		23.3 模板构造函数特化
		23.4 实参代理
		23.5 明确实参的范畴
		23.6 模板构造函数：尾声
第五部分 操作符
	第24章  operator bool()
		24.1 operator int() const
		24.2 operator void*() const
		24.3 operator bool() const
		24.4 operator !() const
		24.5 operator boolean const*() const
		24.6 operator int boolean::*() const
		24.7 在现实世界中的操作
		24.8 operator！
	第25章  快速、非侵入性的字符串拼接
		25.1 fast_string_concatenator<>
			25.1.1 与用户自定义的字符串类协同工作
			25.1.2 将“拼接子”串起来
			25.1.3 fast_string_concatenator类
			25.1.4 内部实现 
		25.2 性能
		25.3 与其他字符串类协作 
			25.3.1 整合进标准库中
			25.3.2 整合进可改动的现存类中
			25.3.3 与不可更改的类互操作
		25.4 拼接提示
		25.5 病态括号
		25.6 标准化
	第26章  你的地址是什么
		26.1 无法得到真实的地址
			26.1.1 STL式元素存放
			26.1.2 ATL外覆类和CAdapt
			26.1.3 获取真实的地址
		26.2 在转换过程中发生了什么
		26.3 我们返回什么
		26.4 你的地址是什么：尾声
	第27章  下标索引操作符
		27.1 指针转换与下标索引操作符
			27.1.1 选择隐式转换操作符
			27.1.2 选择下标索引操作符
		27.2 错误处理
		27.3 返回值
	第28章  增量操作符
		28.1 缺省后置式操作符
		28.2 效率
	第29章  算术类型
		29.1 类定义
		29.2 缺省构造
		29.3 初始化（值构造）
		29.4 拷贝构造函数
		29.5 赋值
		29.6 算术操作符
		29.7 比较操作符
		29.8 访问值
		29.9 sinteger64
		29.10 截断、提升以及布尔测试
			29.10.1 截断
			29.10.2 提升
			29.10.3 布尔测试
		29.11 算术类型：尾声
	第30章  短路
第六部分 扩展C++
	第31章  返回值生命期
		31.1 返回值生命期问题分类
			31.1.1 局部变量
			31.1.2 局部静态对象
			31.1.3 析构后指针
		31.2 为何按引用返回
		31.3 解决方案：integer_to_string<>
		31.4 解决方案2——TSS
			31.4.1 --declspec(thread)
			31.4.2 Win32 TLS
			31.4.3 平台无关的API
			31.4.4 RVL
		31.5 解决方案3——扩展RVL
			31.5.1 解决线程内的RVL-LS问题
			31.5.2 RVL
		31.6 解决方案4——静态数组大小决议
		31.7 解决方案5——转换垫片
		31.8 性能
		31.9 RVL：垃圾收集的大胜利
		31.10 可能的应用
		31.11 返回值生命期：尾声
	第32章  内存
		32.1 内存分类
			32.1.1 栈和静态内存
			32.1.2 栈扩张
			31.1.3 堆内存
		32.2 两者之间的折衷
			32.2.1 alloca()
			32.2.2 VLA
			32.2.3 auto_buffer<>
			32.2.4 使用auto_buffer
			32.2.5 EBO，在哪里
			32.2.6 性能
			32.2.7 堆、栈以及其他 
			32.2.8 pod_vector<>
		32.3  配置器
			32.3.1 函数指针
			32.3.2 配置器接口
			32.3.3 每库初始化
			32.3.4 每调用指定
		32.4 内存：尾声
	第33章  多维数组
		33.1 激活下标索引操作符
		33.2 运行时确定大小 
			33.2.1 可变长数组
			33.2.2 vector<...vector<T>...>
			33.2.3 boost::multi_array
			32.2.4 fixed_array_1/2/3/4d
		33.3 编译期确定大小
			33.3.1 boost::array
			33.3.2 static_array_1/2/3/4d
		33.4 块访问
			33.4.1 使用std::fill_n
			33.4.2 array_size垫片
		33.5 性能
			33.5.1 运行期确定大小
			33.5.2 编译期确定大小 
		33.6 多维数组：尾声
	第34章  仿函数和区间
		34.1 语法混乱
		34.2 for_all()
			34.2.1 数组
			34.2.2 命名
		34.3 局部仿函数
			34.3.1 手写循环
			34.3.2 自定义仿函数
			34.3.3 内嵌的仿函数
			34.3.4 温和一些
			34.3.5 泛化的仿函数：类型隧道
			34.3.6 再进一步，走得太远了
			34.3.7 局部仿函数和回调API
		34.4 区间
			34.4.1 区间概念
			34.4.2 概念性区间
			34.4.3 可迭代区间
			34.4.4 区间算法和标签
			34.4.5 过滤器
			34.4.6 虚伪
		34.5 仿函数和区间：尾声
	第35章  属性
		35.1 编译器扩展
		35.2 可供选择的实现方案
			35.2.1 将属性的实现分门别类
			35.2.2 EMO
		35.3 字段属性
			35.3.1 field_property_get
			35.3.2 field_property_set
			35.3.3 内置式字段属性：尾声
			35.3.4 field_property_get_external
			35.3.5 field_property_set_external
			35.3.6 Hack掉
		35.4 方法属性
			35.4.1 method_property_get
			35.4.2 method_property_set
			35.4.3 method_property_getset
			35.4.4 谨防无限循环
			35.4.5 method_property_get_external
			35.4.6 method_property_set_external
			35.4.7 method_property_getset_external
		35.5 静态属性
			35.5.1 静态字段属性
			35.5.2 内置式静态方法属性
			35.5.3 外置式静态方法属性
		35.6 虚属性
		35.7 属性的使用
			35.7.1 泛化性
			35.7.2 错误诊断中的类型替换
		35.8 属性：尾声
附录
	附录A 编译器和库
		A.1 编译器
		A.2 库
			A.2.1 Boost
			A.2.2 STLSoft
			A.2.3 其他库
		A.3 其他资源
			A.3.1 期刊
			A.3.2 其他语言
			A.3.3 新闻组
	附录B “谦虚点，别骄傲”
		B.1 操作符重载
		B.2 后悔DRY
		B.3 偏执式编程
		B.4 精神错乱
	附录C Arturius
	附录D 随书光盘
	尾声
	