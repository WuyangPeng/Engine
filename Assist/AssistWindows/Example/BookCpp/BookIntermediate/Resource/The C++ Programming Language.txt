C++ 程序设计语言（The C++ Programming Language）

华章网站：
http://www.hzcourse.com/web/teachRes/detail/3883/208、 http://www.hzcourse.com/web/refbook/detail/6641/208。

官方网站：
http://www.stroustrup.com 、http://www.research.att.com/~bs/covers.html （已失效）。

Origin库：
https://github.com/asutton/origin。

特别版
★★
作者：Bjarne Stroustrup
其他书籍：《C++ 语言导学》、《C++ 程序设计原理与实践》、《C++ 语言的设计和演化》。

知识点 
1.	C++ 基础知识。
2.	C++ 基础知识练习。

代码 
1.  书籍代码。
2.  练习代码。

要点 
1.	避免非平凡的指针算术。
2.	如果你必须使用宏，请使用带有许多大写字母的丑陋的名字。
3.	在构造全局的和名字空间的对象时，应避免顺序依赖性。
4.	将只有一个“大小参数”的构造函数做成explicit。

序
	★ 去编程就是去理解。
	致谢
第2版序
	★ 一个“高质量的库”是指这样的库，它以一个或几个方便、安全且高效的类的形式，给用户提供了一个概念。
	★ 安全意味着这个类在库的使用者与它的供方之间构成了一个特殊的类型安全的界面。
	★ 高效意味着与手工写出的C代码相比，这种库的使用不会给用户强加明显的运行时间上或空间上的额外开销。
	致谢
第1版序
	★ 语言磨砺了我们思维的方式，也决定着我们思考的范围。
	致谢
导论
	第1章  致读者
		1.1	本书的结构
			1.1.1 例子和参考
			1.1.2 练习
			1.1.3 有关实现的注记
		1.2 学习C++
		1.3 C++的设计
			1.3.1 效率和结构
			1.3.2 哲学注记
		1.4 历史注记
		1.5 C++的使用
		1.6	C和C++
			1.6.1 给C程序员的建议
			1.6.2 给C++程序员的建议
		1.7 有关在C++里编程的思考
		1.8 忠告
		1.9 参考文献
	第2章  C++概览
		2.1 为什么是C++
		2.2 程序设计范型
		2.3 过程式程序设计
			2.3.1 变量和算术
			2.3.2 检测和循环
			2.3.3 指针和数组
		2.4 模块程序设计
			2.4.1 分别编译
			2.4.2 异常处理
		2.5 数据抽象
			2.5.1 定义类型的模块
			2.5.2 用户定义类型
			2.5.3 具体类型
			2.5.4 抽象类型
			2.5.5 虚函数
		2.6 面向对象的程序设计
			2.6.1 具体类型的问题
			2.6.2 类层次结构
		2.7 通用型程序设计
			2.7.1 容器
			2.7.2 通用型算法
		2.8 附言 
		2.9 忠告
	第3章  标准库概览
		3.1 引言
		3.2 Hello,World!
		3.3 标准库名字空间
		3.4 输出
		3.5 字符串
			3.5.1 C风格的字符串
		3.6 输入
		3.7 容器
			3.7.1 向量——vector
			3.7.2 范围检查
			3.7.3 表——list
			3.7.4 映射——map
			3.7.5 标准容器
		3.8 算法 
			3.8.1 迭代器的使用
			3.8.2 迭代器类型
			3.8.3 迭代器和I/O
			3.8.4 遍历和谓词
			3.8.5 使用成员函数的算法 
			3.8.6 标准库算法 
		3.9 数学
			3.9.1 复数
			3.9.2 向量算术
			3.9.3 基本数值支持
		3.10 标准库功能
		3.11 忠告
第一部分 基本功能
	第4章  类型和声明
		4.1 类型
			4.1.1 基本类型
		4.2 布尔量
		4.3 字符类型
			4.3.1 字符文字量
		4.4 整数类型
			4.4.1 整数文字量
		4.5 浮点类型
			4.5.1 浮点文字量
		4.6 大小
		4.7 void
		4.8 枚举
		4.9 声明
			4.9.1 声明的结构
			4.9.2 声明多个名字
			4.9.3 名字
			4.9.4 作用域
			4.9.5 初始化
			4.9.6 对象和左值
			4.9.7 typedef
		4.10 忠告
		4.11 练习
	第5章  指针、数组和结构
		5.1 指针
			5.1.1 零
		5.2 数组
			5.2.1 数组的初始化
			5.2.2 字符串文字量
		5.3 到数组的指针
			5.3.1 在数组里漫游 
		5.4 常量
			5.4.1 指针和常量
		5.5 引用 
		5.6 指向void的指针
		5.7 结构
			5.7.1 类型等价
		5.8 忠告
		5.9 练习
	第6章  表达式和语句 
		6.1 一个桌面计算器
			6.1.1 分析器
			6.1.2 输入函数
			6.1.3 低级输入
			6.1.4 错误处理
			6.1.5 驱动程序
			6.1.6 头文件
			6.1.7 命令行参数
			6.1.8 有关风格的注记
		6.2 运算符概览
			6.2.1 结果
			6.2.2 求值顺序
			6.2.3 运算符优先级
			6.2.4 按位逻辑运算符
			6.2.5 增量和减量
			6.2.6 自由存储
			6.2.7 显示类型转换
			6.2.8 构造函数
		6.3 语句概览
			6.3.1 声明作为语句
			6.3.2 选择语句
			6.3.3 迭代语句
			6.3.4 goto
		6.4 注释和缩进编排
		6.5 忠告
		6.6 练习
	第7章  函数
		7.1 函数声明
			7.1.1 函数定义
			7.1.2 静态变量
		7.2 参数传递
			7.2.1 数组参数
		7.3 返回值
		7.4 重载函数名
			7.4.1 重载和返回类型
			7.4.2 重载与作用域
			7.4.3 手工的歧义性解析
			7.4.4 多参数的解析
		7.5 默认参数
		7.6 未确定数目的参数
		7.7 指向函数的指针
		7.8 宏
			7.8.1 条件编译
		7.9 忠告
		7.10 练习
	第8章  名字空间和异常
		8.1 模块化和界面
		8.2 名字空间
			8.2.1 带限定词的名字
			8.2.2 使用声明 
			8.2.3 使用指令
			8.2.4 多重界面
			8.2.5 避免名字冲突
			8.2.6 名字查找
			8.2.7 名字空间别名
			8.2.8 名字空间组合 
			8.2.9 名字空间和老代码
		8.3 异常
			8.3.1 抛出和捕捉
			8.3.2 异常的辨识
			8.3.3 在计算器中的异常
		8.4 忠告
		8.5 练习
	第9章  源文件和程序
		9.1 分别编译
		9.2 连接
			9.2.1 头文件
			9.2.2 标准库头文件
			9.2.3 单一定义规则
			9.2.4 与非C++代码的连接
			9.2.5 连接与指向函数的指针
		9.3 使用头文件
			9.3.1 单一头文件
			9.3.2 多个头文件
			9.3.3 包含保护符
		9.4 程序
			9.4.1 非局部变量的初始化
		9.5 忠告
		9.6 练习
第二部分 抽象机制
	第10章  类
		10.1 引言
		10.2 类
			10.2.1 成员函数
			10.2.2 访问控制
			10.2.3 构造函数
			10.2.4 静态成员 
			10.2.5 类对象的复制
			10.2.6 常量成员函数
			10.2.7 自引用 
			10.2.8 结构和类
			10.2.9 在类内部的函数定义 
		10.3 高效的用户定义类型
			10.3.1 成员函数
			10.3.2 协助函数
			10.3.3 重载的运算符
			10.3.4 具体类型的意义
		10.4 对象
			10.4.1 析构函数
			10.4.2 默认构造函数
			10.4.3 构造和析构
			10.4.4 局部变量
			10.4.5 自由存储
			10.4.6 类对象作为成员
			10.4.7 数组
			10.4.8 局部静态存储 
			10.4.9 非局部存储
			10.4.10 临时对象
			10.4.11 对象的放置
			10.4.12 联合
		10.5 忠告
		10.6 练习
	第11章  运算符重载
		11.1 引言
		11.2 运算符函数
			11.2.1 二元和一元运算符
			11.2.2 运算符的预定义意义
			11.2.3 运算符和用户定义类型
			11.2.4 名字空间里的运算符
		11.3 一个复数类型
			11.3.1 成员运算符和非成员运算符
			11.3.2 混合模式算术
			11.3.3 初始化
			11.3.4 复制
			11.3.5 构造函数和转换
			11.3.6 文字量
			11.3.7 另一些成员函数
			11.3.8 协助函数
		11.4 转换运算符
			11.4.1 歧义性
		11.5 友元
			11.5.1 友元的寻找
			11.5.2 友元和成员 
		11.6 大型对象
		11.7 基本运算符
			11.7.1 显式构造函数
		11.8 下标
		11.9 函数调用
		11.10 间接
		11.11 增量和减量
		11.12 一个字符串类
		11.13 忠告
		11.14 练习
	第12章  派生类
		12.1 引言
		12.2 派生类
			12.2.1 成员函数
			12.2.2 构造函数和析构函数
			12.2.3 复制
			12.2.4 类层次结构
			12.2.5 类型域
			12.2.6 虚函数
		12.3 抽象类
		12.4 类层次结构的设计
			12.4.1 一个传统的层次结构
			12.4.2 抽象类
			12.4.3 其他实现方式 
			12.4.4 对象创建的局部化
		12.5 类层次结构和抽象类
		12.6 忠告
		12.7 练习
	第13章  模板
		13.1 引言
		13.2 一个简单的String模板
			13.2.1	定义一个模板
			13.2.2 模板实例化
			13.2.3 模板参数
			13.2.4 类型等价
			13.2.5 类型检查
		13.3 函数模板
			13.3.1 函数模板的参数
			13.3.2 函数模板的重载
		13.4 用模板参数描述策略
			13.4.1 默认模板参数
		13.5 专门化
			13.5.1 专门化的顺序
			13.5.2 模板函数的专门化
		13.6 派生和模板
			13.6.1 参数化和继承
			13.6.2 成员模板
			13.6.3 继承关系
		13.7 源代码组织
		13.8 忠告
		13.9 练习
	第14章  异常处理
		14.1 错误处理
			14.1.1 关于异常的其他观点
		14.2 异常的结组
			14.2.1 派生的异常
			14.2.2 多个异常组合
		14.3 捕捉异常
			14.3.1 重新抛出
			14.3.2 捕捉所有异常
		14.4 资源管理 
			14.4.1 构造函数和析构函数的使用
			14.4.2 auto_ptr
			14.4.3 告诫
			14.4.4 异常和new
			14.4.5 资源耗尽
			14.4.6 构造函数里的异常
			14.4.7 析构函数里的异常
		14.5 不是错误的异常
		14.6 异常的描述
			14.6.1 对异常描述的检查
			14.6.2 未预期的异常
			14.6.3 异常的映射
		14.7 未捕捉的异常
		14.8 异常和效率
		14.9 处理错误的其他方式 
		14.10 标准异常
		14.11 忠告
		14.12 练习
	第15章  类层次结构
		15.1 引言和概述
		15.2 多重继承
			15.2.1 歧义性解析
			15.2.2 继承和使用声明 
			15.2.3 重复的基类
			15.2.4 虚基类
			15.2.5 使用多重继承
		15.3 访问控制
			15.3.1 保护成员 
			15.3.2 对基类的访问
		15.4 运行时类型信息
			15.4.1 dynamic_cast
			15.4.2 在类层次结构中漫游
			15.4.3 类对象的构造与析构
			15.4.4 typeid和扩展的类型信息
			15.4.5 RTTI的使用和误用
		15.5 指向成员的指针
			15.5.1 基类和派生类
		15.6 自由存储
			15.6.1 数组分配
			15.6.2 虚构造函数
		15.7 忠告
		15.8 练习
第三部分 标准库
	第16章  库组织和容器
		16.1 标准库的设计 
			16.1.1 设计约束
			16.1.2 标准库组织
			16.1.3 语言支持
		16.2 容器设计
			16.2.1 专门化的容器和迭代器
			16.2.2 有基类的容器
			16.2.3 STL容器
		16.3 向量
			16.3.1 类型
			16.3.2 迭代器
			16.3.3 元素访问
			16.3.4 构造函数
			16.3.5 堆栈操作
			16.3.6 表操作
			16.3.7 元素定位
			16.3.8 大小和容量
			16.3.9 其他成员函数
			16.3.10 协助函数
		16.4 忠告
		16.5 练习
	第17章  标准容器
		17.1 标准容器
			17.1.1 操作综述
			17.1.2 容器综述
			17.1.3 表示
			17.1.4 对元素的要求
		17.2 序列
			17.2.1 向量——vector
			17.2.2 表——list
			17.2.3 双端队列——deque
		17.3 序列适配器
			17.3.1 堆栈——stack
			17.3.2 队列——queue
			17.3.3 优先队列——priority_queue
		17.4 关联容器
			17.4.1 映射——map
			17.4.2 多重映射——multimap
			17.4.3 集合——set
			17.4.4 多重集合——multiset
		17.5 拟容器
			17.5.1 串——string
			17.5.2 值向量——valarray
			17.5.3 位集合——bitset
			17.5.4 内部数组
		17.6 定义新容器
			17.6.1 散列映射——hash_map
			17.6.2 表示和构造
			17.6.3 其他散列关联容器
		17.7 忠告
		17.8 练习
	第18章  算法和函数对象
		18.1 引言
		18.2 标准库算法综述
		18.3 序列和容器
			18.3.1 输入序列
		18.4 函数对象
			18.4.1 函数对象的基类
			18.4.2 谓词
			18.4.3 算术函数对象
			18.4.4 约束器、适配器和否定器
		18.5 非修改性序列算法 
			18.5.1 对每个做——for_each
			18.5.2 查找族函数
			18.5.3 计数
			18.5.4 相等和不匹配
			18.5.5 搜索
		18.6 修改性序列算法 
			18.6.1 复制
			18.6.2 变换
			18.6.3 惟一化
			18.6.4 取代
			18.6.5 删除
			18.6.6 填充和生成
			18.6.7 反转和旋转
			18.6.8 变换
		18.7 排序的序列
			18.7.1 排序
			18.7.2 二分搜索
			18.7.3 归并
			18.7.4 划分
			18.7.5 序列上的集合运算
		18.8 堆
		18.9 最小和最大
		18.10 排列
		18.11 C风格算法 
		18.12 忠告
		18.13 练习
	第19章  迭代器和分配器
		19.1 引言
		19.2 迭代器和序列
			19.2.1 迭代器的操作
			19.2.2 迭代器特征类——iterator_traits
			19.2.3 迭代器类别
			19.2.4 插入器
			19.2.5 反向迭代器
			19.2.6 流迭代器
		19.3 带检查迭代器
			19.3.1 异常、容器和算法 
		19.4 分配器
			19.4.1 标准分配器
			19.4.2 一个用户定义分配器
			19.4.3 广义的分配器
			19.4.4 未初始化的存储 
			19.4.5 动态存储 
			19.4.6 C风格的分配 
		19.5 忠告
		19.6 练习
	第20章  串
		20.1 引言
		20.2 字符
			20.2.1 字符特征类——char_traits
		20.3 基础串类——basic_string
			20.3.1 类型
			20.3.2 迭代器
			20.3.3 元素访问
			20.3.4 构造函数
			20.3.5 错误
			20.3.6 赋值
			20.3.7 到C风格字符串的转换
			20.3.8 比较
			20.3.9 插入
			20.3.10 拼接
			20.3.11 查找
			20.3.12 替换
			20.3.13 子串
			20.3.14 大小和容量
			20.3.15 I/O操作
			20.3.16 交换
		20.4 C标准库
			20.4.1 C风格字符串
			20.4.2 字符分类
		20.5 忠告
		20.6 练习
	第21章  流
		21.1 引言
		21.2 输出
			21.2.1 输出流
			21.2.2 内部类型的输出
			21.2.3 用户定义类型的输出
		21.3 输入
			21.3.1 输入流
			21.3.2 内部类型的输入
			21.3.3 流状态
			21.3.4 字符的输入
			21.3.5 用户定义类型的输入
			21.3.6 异常
			21.3.7 流的联结
			21.3.8 哨位
		21.4 格式化
			21.4.1 格式状态
			21.4.2 整数输出
			21.4.3 浮点数输出
			21.4.4 输出域
			21.4.5 域的调整
			21.4.6 操控符
		21.5 文件流与字符串流
			21.5.1 文件流
			21.5.2 流的关闭
			21.5.3 字符串流
		21.6 缓冲
			21.6.1 输出流和缓冲区
			21.6.2 输入流和缓冲区
			21.6.3 流和缓冲区
			21.6.4 流缓冲区
		21.7 现场
			21.7.1 流回调
		21.8 C输入/输出
		21.9 忠告
		21.10 练习
	第22章  数值
		22.1 引言
		22.2 数值的限制
			22.2.1 表示限制的宏
		22.3 标准数学函数
		22.4 向量算术
			22.4.1 valarray的构造
			22.4.2 valarray的下标和赋值
			22.4.3 成员操作
			22.4.4 非成员函数
			22.4.5 切割
			22.4.6 切割数组——slice_array
			22.4.7 临时量、复制和循环
			22.4.8 广义切割
			22.4.9 屏蔽
			22.4.10 间接数组——indirect_array
		22.5 复数算术
		22.6 通用数值算法 
			22.6.1 累积——accumulate
			22.6.2 内积——inner_product
			22.6.3 增量变化
		22.7 随机数
		22.8 忠告
		22.9 练习
第四部分 用C++做设计 
	第23章  开发和设计 
		23.1 概述
		23.2 引言
		23.3 目的和手段
		23.4 开发过程
			23.4.1 开发循环
			23.4.2 设计目标
			23.4.3 设计步骤
			23.4.4 试验和分析
			23.4.5 测试
			23.4.6 软件维护
			23.4.7 效率
		23.5 管理
			23.5.1 重用
			23.5.2 规模
			23.5.3 个人
			23.5.4 混成设计
		23.6 带标注的参考文献
		23.7 忠告
	第24章  设计和编程
		24.1 概述
		24.2 设计和程序设计语言
			24.2.1 忽视类
			24.2.2 忽视继承
			24.2.3 忽视静态类型检查
			24.2.4 忽视程序设计
			24.2.5 排他性地使用类层次结构
		24.3 类
			24.3.1 类表示什么
			24.3.2 类层次结构
			24.3.3 包容关系
			24.3.4 包容和继承
			24.3.5 使用关系
			24.3.6 编入程序里的关系
			24.3.7 类内的关系
		24.4 组件
			24.4.1 模板
			24.4.2 界面和实现 
			24.4.3 肥大的界面
		24.5 忠告
	第25章  类的作用
		25.1 类的种类
		25.2 具体类型
			25.2.1 具体类型的重用
		25.3 抽象类型
		25.4 结点
			25.4.1 修改界面
		25.5 动作
		25.6 界面类
			25.6.1 调整界面
		25.7 句柄类
			25.7.1 句柄上的操作
		25.8 应用框架
		25.9 忠告
		25.10 练习
附录
	附录A 语法
	附录B 兼容性
	附录C 技术细节
	附录D 现场
	附录E 标准库的异常时安全性	

第4版第1-3部分
★★★★
作者：Bjarne Stroustrup
其他书籍：《C++ 语言导学》、《C++ 程序设计原理与实践》、《C++ 语言的设计和演化》。

知识点 
1.	C++ 基础知识。
2.	C++11 基础知识。
3.	一个矩阵设计。

要点 
1.	将指针看作Java的引用在C++中的等价物。
2.	以值的方式返回容器（依赖于移动操作以提高效率）。
3.	数据结构应力求小巧。
4.	注释应该简短直接。
5.	库不应直接输出面向最终用户的错误诊断信息，正确的做法是抛出一个异常然后由调用者决定该怎么做。

序
	前言
		★ 所有计算机科学问题，都可以通过引入一个新的间接层次来解决，那些已有过多间接层次的问题除外。
		★ C++11给人的感觉就像是一种新语言一样。
		★ C++是一种通用程序设计语言，它强调富类型、轻量级抽象的设计和使用。
		致谢
	第3版前言
		致谢
	第2版前言
		致谢
	第1版前言
		致谢
第一部分 引言
	第1章  致读者
		1.1 本书结构
			1.1.1 引言
			1.1.2 基本特性
			1.1.3 抽象机制
			1.1.4 标准库
			1.1.5 例子和参考文献
		1.2 C++的设计
			1.2.1 程序设计风格
			1.2.2 类型检查
			1.2.3 C兼容性
			1.2.4 语言、库和系统
		1.3 学习C++
			1.3.1 用C++编程
			1.3.2 对C++程序员的建议
			1.3.3 对C程序员的建议
			1.3.4 对Java程序员的建议
		1.4 C++的历史
			1.4.1 大事年表
			1.4.2 早期的C++
			1.4.3 1998标准
			1.4.4 2011标准
			1.4.5 C++的用途
		1.5 建议
		1.6 参考文献
	第2章  C++概览：基础知识
		2.1 引言
		2.2 基本概念
			2.2.1 Hello,World!
			2.2.2 类型、变量和算术运算
			2.2.3 常量
			2.2.4 检验和循环
			2.2.5 指针、数组和循环
		2.3 用户自定义类型
			2.3.1 结构
			2.3.2 类
			2.3.3 枚举
		2.4 模块化
			2.4.1 分离编译
			2.4.2 名字空间
			2.4.3 错误处理
		2.5 附记
		2.6 建议
	第3章  C++概览：抽象机制
		3.1 引言
		3.2 类
			3.2.1 具体类型
			3.2.2 抽象类型
			3.2.3 虚函数
			3.2.4 类层次
		3.3 拷贝和移动
			3.3.1 拷贝容器
			3.3.2 移动容器
			3.3.3 资源管理
			3.3.4 抑制操作
		3.4 模板
			3.4.1 参数化类型
			3.4.2 函数模板
			3.4.3 函数对象
			3.4.4 可变参数模板
			3.4.5 别名
		3.5 建议
	第4章  C++概览：容器与算法
		4.1 标准库
			4.1.1 标准库概述
			4.1.2 标准库头文件与名字空间
		4.2 字符串
		4.3 I/O流
			4.3.1 输出
			4.3.2 输入
			4.3.3 用户自定义类型的I/O
		4.4 容器
			4.4.1 vector
			4.4.2 list
			4.4.3 map
			4.4.4 unordered_map
			4.4.5 容器概述
		4.5 算法 
			4.5.1 使用迭代器
			4.5.2 迭代器类型
			4.5.3 流迭代器
			4.5.4 谓词
			4.5.5 算法概述
			4.5.6 容器算法 
		4.6 建议
	第5章  C++概览：开发和实用功能
		5.1 引言
		5.2 资源管理 
			5.2.1 unique_ptr与shared_ptr
		5.3 并发
			5.3.1 任务和thread
			5.3.2 传递参数
			5.3.3 返回结果
			5.3.4 共享数据
			5.3.5 任务通信
		5.4 小工具组件
			5.4.1 时间
			5.4.2 类型函数
			5.4.3 pair和tuple
		5.5 正则表达式
		5.6 数学计算
			5.6.1 数学函数和算法 
			5.6.2 复数
			5.6.3 随机数
			5.6.4 向量算术
			5.6.5 数值限制
		5.7 建议
第二部分 基本功能
	第6章  类型和声明
		6.1 ISO C++标准
			6.1.1 实现 
			6.1.2 基本源程序字符集
		6.2 类型
			6.2.1 基本类型
			6.2.2 布尔值
			6.2.3 字符类型
			6.2.4 整数类型
			6.2.5 浮点数类型
			6.2.6 前缀和后缀
			6.2.7 void 
			6.2.8 类型尺寸
			6.2.9 对齐
		6.3 声明
			6.3.1 声明的结构
			6.3.2 声明多个名字
			6.3.3 名字
			6.3.4 作用域
			6.3.5 初始化
			6.3.6 推断类型：auto和decltype()
		6.4 对象和值
			6.4.1 左值和右值
			6.4.2 对象的生命周期
		6.5 类型别名
		6.6 建议
	第7章  指针、数组和结构
		7.1 引言
		7.2 指针
			7.2.1 void*
			7.2.2 nullptr
		7.3 数组
			7.3.1 数组的初始化器
			7.3.2 字符串字面值常量
		7.4 数组中的指针
			7.4.1 数组漫游
			7.4.2 多维数组
			7.4.3 传递数组
		7.5 指针与const
		7.6 指针与所有权
		7.7 引用 
			7.7.1 左值引用 
			7.7.2 右值引用 
			7.7.3 引用的引用 
			7.7.4 指针与引用 
		7.8 建议
	第8章  结构、联合与枚举
		8.1 引言
		8.2 结构
			8.2.1 struct的布局
			8.2.2 struct的名字
			8.2.3 结构与类
			8.2.4 结构与数组
			8.2.5 类型等价
			8.2.6 普通旧数据
			8.2.7 域
		8.3 联合
			8.3.1 联合与类
			8.3.2 匿名union
		8.4 枚举
			8.4.1 enum class
			8.4.2 普通的enum
			8.4.3 未命名的enum
		8.5 建议
	第9章  语句 
		9.1 引言
		9.2 语句概述
		9.3 声明作为语句
		9.4 选择语句
			9.4.1 if语句
			9.4.2 switch语句
			9.4.3 条件中的声明
		9.5 循环语句
			9.5.1 范围for语句
			9.5.2 for语句
			9.5.3 while语句
			9.5.4 do语句
			9.5.5 退出循环
		9.6 goto语句
		9.7 注释与缩进
		9.8 建议
	第10章  表达式
		10.1 引言
		10.2 一个桌面计算器示例
			10.2.1 分析器
			10.2.2 输入
			10.2.3 底层输入
			10.2.4 错误处理
			10.2.5 驱动程序
			10.2.6 头文件
			10.2.7 命令行参数
			10.2.8 关于风格
		10.3 运算符概述
			10.3.1 结果
			10.3.2 求值顺序
			10.3.3 运算符优先级
			10.3.4 临时对象
		10.4 常量表达式
			10.4.1 符号化常量 
			10.4.2 常量表达式中的const
			10.4.3 字面值常量类型
			10.4.4 引用参数
			10.4.5 地址常量表达式
		10.5 隐式类型转换
			10.5.1 提升
			10.5.2 类型转换
			10.5.3 常用的算术类型转换
		10.6 建议
	第11章  选择适当的操作
		11.1 其他运算符
			11.1.1 逻辑运算符
			11.1.2 位逻辑运算符
			11.1.3 条件表达式
			11.1.4 递增与递减
		11.2 自由存储
			11.2.1 内存管理
			11.2.2 数组
			11.2.3 获取内存空间
			11.2.4 重载new
		11.3 列表
			11.3.1 实现模型
			11.3.2 限定列表
			11.3.3 未限定列表
		11.4 lambda表达式
			11.4.1 实现模型
			11.4.2 lambda的替代品
			11.4.3 捕获
			11.4.4 调用与返回
			11.4.5 lambda的类型
		11.5 显式类型转换
			11.5.1 构造 
			11.5.2 命名转换
			11.5.3 C风格的转换
			11.5.4 函数形式的转换
		11.6 建议
	第12章  函数
		12.1 函数声明
			12.1.1 为什么使用函数
			12.1.2 函数声明的组成要件
			12.1.3 函数定义
			12.1.4 返回值
			12.1.5 inline函数
			12.1.6 constexpr函数
			12.1.7 [[noreturn]]函数
			12.1.8 局部变量
		12.2 参数传递
			12.2.1 引用参数
			12.2.2 数组参数
			12.2.3 列表参数
			12.2.4 数量未定的参数
			12.2.5 默认参数
		12.3 重载函数
			12.3.1 自动重载解析
			12.3.2 重载与返回类型
			13.3.3 重载与作用域
			13.3.4 多实参解析
			13.3.5 手动重载解析
		12.4 前置与后置条件
		12.5 函数指针
		12.6 宏
			12.6.1 条件编译
			12.6.2 预定义宏
			12.6.3 编译指令
		12.7 建议
	第13章  异常处理
		13.1 错误处理
			13.1.1 异常
			13.1.2 传统的错误处理
			13.1.3 渐进决策
			13.1.4 另一种视角看异常
			13.1.5 何时不应使用异常
			13.1.6 层次化错误处理
			13.1.7 异常与效率
		13.2 异常保障
		13.3 资源管理
			13.3.1 finally
		13.4 强制不变式
		13.5 抛出与捕获异常
			13.5.1 抛出异常
			13.5.2 捕获异常
			13.5.3 异常与线程
		13.6 vector的实现
			13.6.1 一个简单的vector
			13.6.2 显式地表示内存
			13.6.3 赋值
			13.6.4 改变尺寸
		13.7 建议
	第14章  名字空间 
		14.1 组合问题
		14.2 名字空间
			14.2.1 显式限定
			14.2.2 using声明
			14.2.3 using指示
			14.2.4 参数依赖查找
			14.2.5 名字空间是开放的
		14.3 模块化和接口
			14.3.1 名字空间作为模块
			14.3.2 实现 
			14.3.3 接口和名字
		14.4 组合使用名字空间
			14.4.1 便利性与安全性
			14.4.2 名字空间别名
			14.4.3 组合名字空间
			14.4.4 组合与选择
			14.4.5 名字空间和重载
			14.4.6 版本控制
			14.4.7 名字空间嵌套
			14.4.8 无名名字空间
			14.4.9 C头文件
		14.5 建议
	第15章  源文件和程序
		15.1 分离编译
		15.2 链接
			15.2.1 文件内名字
			15.2.2 头文件
			15.2.3 单一定义规则
			15.2.4 标准库头文件
			15.2.5 链接非C++代码
			15.2.6 链接和函数指针
		15.3 使用头文件
			15.3.1 单头文件组织
			15.3.2 多头文件组织
			15.3.3 包含保护
		15.4 程序
			15.4.1 非局部变量初始化
			15.4.2 初始化和并发
			15.4.3 程序终止 
		15.5 建议
第三部分 抽象机制
	第16章  类
		16.1 引言
		16.2 类基础
			16.2.1 成员函数
			16.2.2 默认拷贝
			16.2.3 访问控制
			16.2.4 class和struct
			16.2.5 构造函数
			16.2.6 explicit构造函数
			16.2.7 类内初始化器
			16.2.8 类内函数定义
			16.2.9 可变性
			16.2.10 自引用
			16.2.11 成员访问
			16.2.12 static成员
			16.2.13 成员类型
		16.3 具体类
			16.3.1 成员函数
			16.3.2 辅助函数
			16.3.3 重载运算符
			16.3.4 具体类的重要性
		16.4 建议
	第17章  构造、清理、拷贝和移动
		17.1 引言
		17.2 构造函数和析构函数
			17.2.1 构造函数和不变式
			17.2.2 析构函数和资源
			17.2.3 基类和成员析构函数
			17.2.4 调用构造函数和析构函数
			17.2.5 virtual析构函数
		17.3 类对象初始化
			17.3.1 不使用构造函数进行初始化
			17.3.2 使用构造函数进行初始化
			17.3.3 默认构造函数
			17.3.4 初始化器列表构造函数
		17.4 成员和基类初始化
			17.4.1 成员初始化
			17.4.2 基类初始化器
			17.4.3 委托构造函数
			17.4.4 类内初始化器
			17.4.5 static成员初始化
		17.5 拷贝和移动
			17.5.1 拷贝
			17.5.2 移动
		17.6 生成默认操作
			17.6.1 显式声明默认操作
			17.6.2 默认操作
			17.6.3 使用默认操作
			17.6.4 使用delete删除的函数
		17.7 建议
	第18章  运算符重载
		18.1 引言
		18.2 运算符函数
			18.2.1 二元和一元运算符
			18.2.2 运算符预置的含义
			18.2.3 运算符与用户自定义类型
			18.2.4 传递对象
			18.2.5 名字空间中的运算符
		18.3 复数类型
			18.3.1 成员和非成员运算符
			18.3.2 混合模式运算
			18.3.3 类型转换
			18.3.4 字面值常量
			18.3.5 访问函数
			18.3.6 辅助函数
		18.4 类型转换
			18.4.1 类型转换运算符
			18.4.2 explicit类型转换运算符
			18.4.3 二义性
		18.5 建议
	第19章  特殊运算符
		19.1 引言
		19.2 特殊运算符
			19.2.1 取下标
			19.2.2 函数调用
			19.2.3 解引用 
			19.2.4 递增和递减
			19.2.5 分配和释放
			19.2.6 用户自定义字面值常量
		19.3 字符串类
			19.3.1 必备操作
			19.3.2 访问字符
			19.3.3 类的表示
			19.3.4 成员函数
			19.3.5 辅助函数
			19.3.6 应用String
		19.4 友元
			19.4.1 发现友元
			19.4.2 友元与成员 
		19.5 建议
	第20章  派生类
		20.1 引言
		20.2 派生类
			20.2.1 成员函数
			20.2.2 构造函数和析构函数
		20.3 类层次
			20.3.1 类型域
			20.3.2 虚函数
			20.3.3 显式限定
			20.3.4 覆盖控制
			20.3.5 using基类成员
			20.3.6 返回类型放松
		20.4 抽象类
		20.5 访问控制
			20.5.1 protected成员
			20.5.2 访问基类
			20.5.3 using声明与访问控制
		20.6 成员指针
			20.6.1 函数成员指针
			20.6.2 数据成员指针
			20.6.3 基类和派生类成员
		20.7 建议
	第21章  类层次
		21.1 引言
		21.2 设计类层次
			21.2.1 实现继承
			21.2.2 接口继承
			21.2.3 替代实现方式
			21.2.4 定位对象创建
		21.3 多重继承
			21.3.1 多重接口
			21.3.2 多重实现类
			21.3.3 二义性解析
			21.3.4 重复使用基类
			21.3.5 虚基类
			21.3.6 重复基类与虚基类
		21.4 建议
	第22章  运行时类型信息
		22.1 引言
		22.2 类层次导航
			22.2.1 dynamic_cast
			22.2.2 多重继承
			22.2.3 static_cast和dynamic_cast
			22.2.4 恢复接口
		22.3 双重分发和访问
			22.3.1 双重分发
			22.3.2 访客
		22.4 构造和析构
		22.5 类型识别
			22.5.1 扩展类型信息
		22.6 RTTI的使用和误用
		22.7 建议
	第23章  模板
		23.1 引言和概述
		23.2 一个简单的字符串模板
			23.2.1 定义模板
			23.2.2 模板实例化
		23.3 类型检查
			23.3.1 类型等价
			23.3.2 错误检测
		23.4 类模板成员
			23.4.1 数据成员
			23.4.2 成员函数
			23.4.3 成员类型别名
			23.4.4 static成员
			23.4.5 成员类型
			23.4.6 成员模板
			23.4.7 友元
		23.5 函数模板
			23.5.1 函数模板实参
			23.5.2 函数模板实参推断
			23.5.3 函数模板重载
		23.6 模板别名
		23.7 源码组织
			23.7.1 链接
		23.8 建议
	第24章  泛型程序设计
		24.1 引言
		24.2 算法和提升
		24.3 概念
			24.3.1 发现概念
			24.3.2 概念和约束
		24.4 具体化概念
			24.4.1 公理
			24.4.2 多实参概念
			24.4.3 值概念
			24.4.4 约束检查
			24.4.5 模板定义检查
		24.5 建议
	第25章  特例化
		25.1 引言
		25.2 模板参数和实参
			25.2.1 类型作为实参
			25.2.2 值作为实参
			25.2.3 操作作为实参
			25.2.4 模板作为实参
			25.2.5 默认模板实参
		25.3 特例化
			25.3.1 接口特例化
			25.3.2 主模板
			25.3.3 特例化顺序
			25.3.4 函数模板特例化
		25.4 建议
	第26章  实例化
		26.1 引言
		26.2 模板实例化
			26.2.1 何时需要实例化
			26.2.2 手工控制实例化
		26.3 名字绑定
			26.3.1 依赖性名字
			26.3.2 定义点绑定
			26.3.3 实例化点绑定
			26.3.4 多实例化点
			26.3.5 模板和名字空间
			26.3.6 过于激进的ADL
			26.3.7 来自基类的名字
		26.4 建议
	第27章  模板和类层次
		27.1 引言
		27.2 参数化和类层次
			27.2.1 生成类型
			27.2.2 模板类型转换
		27.3 类模板层次
			27.3.1 模板作为接口
		27.4 模板参数作为基类
			27.4.1 组合数据结构
			27.4.2 线性化类层次
		27.5 建议
	第28章  元编程
		28.1 引言
		28.2 类型函数
			28.2.1 类型别名
			28.2.2 类型谓词
			28.2.3 选择函数
			28.2.4 萃取
		28.3 控制结构
			28.3.1 选择
			28.3.2 迭代和递归
			28.3.3 何时使用元编程
		28.4 条件定义：Enable_if
			28.4.1 使用Enable_if
			28.4.2 实现Enable_if
			28.4.3 Enable_if与概念
			28.4.4 更多Enable_if例子
		28.5 一个编译时列表：Tuple
			28.5.1 一个简单的输出函数
			28.5.2 元素访问
			28.5.3 make_tuple
		28.6 可变参数模板
			28.6.1 一个类型安全的printf()
			28.6.2 技术细节
			28.6.3 转发
			28.6.4 标准库tuple
		28.7 国际标准单位例子
			28.7.1 Unit
			28.7.2 Quantity
			28.7.3 Unit字面值常量
			28.7.4 工具函数
		28.8 建议
	第29章  一个矩阵设计
		29.1 引言
			29.1.1 Matrix的基本使用
			29.1.2 对Matrix的要求
		29.2 Matrix模板
			29.2.1 构造和赋值
			29.2.2 下标和切片
		29.3 Matrix算术运算
			29.3.1 标量运算
			29.3.2 加法
			29.3.3 乘法
		29.4 Matrix实现 
			29.4.1 slice()
			29.4.2 Matrix切片
			29.4.3 Matrix_ref
			29.4.4 Matrix列表初始化
			29.4.5 Matrix访问
			29.4.6 零维Matrix
		29.5 求解线性方程组
			29.5.1 经典高斯消去法
			29.5.2 旋转
			29.5.3 测试
			29.5.4 熔合运算
		29.6 建议

第4版第4部分
★★★
作者：Bjarne Stroustrup
其他书籍：《C++ 语言导学》、《C++ 程序设计原理与实践》、《C++ 语言的设计和演化》。

知识点 
1.	C++ 基础知识。
2.	C++11 基础知识。
3.	标准库基础知识。

要点 
1.	优先选择有特定语义的资源句柄而不是智能指针。

第四部分 标准库
	第30章  标准库概览
		30.1 引言
			30.1.1 标准库设施
			30.1.2 设计约束
			30.1.3 描述风格
		30.2 头文件
		30.3 语言支持
			30.3.1 initializer_list支持
			30.3.2 范围for支持
		30.4 错误处理
			30.4.1 异常
			30.4.2 断言 
			30.4.3 ststem_error
		30.5 建议
	第31章  STL容器
		31.1 引言
		31.2 容器概览
			31.2.1 容器表示
			31.2.2 对元素的要求
		31.3 操作概览
			31.3.1 成员类型
			31.3.2 构造函数、析构函数和赋值操作
			31.3.3 大小和容量
			31.3.4 迭代器
			31.3.5 元素访问
			31.3.6 栈操作
			31.3.7 列表操作
			31.3.8 其他操作
		31.4 容器
			31.4.1 vector
			31.4.2 链表
			31.4.3 关联容器
		31.5 容器适配器
			31.5.1 stack 
			31.5.2 queue
			31.5.3 priority_queue
		31.6 建议
	第32章  STL算法
		32.1 引言
		32.2 算法
			32.2.1 序列
		32.3 策略实参
			32.3.1 复杂性
		32.4 不修改序列的算法 
			32.4.1 for_each()
			32.4.2 序列谓词
			32.4.3 count()
			32.4.4 find()
			32.4.5 equal()和mismatch()
			32.4.6 search()
		32.5 修改序列的算法 
			32.5.1 copy()
			32.5.2 unique()
			32.5.3 remove()和replace()
			32.5.4 rotate()、random_shuffle()和partition()
			32.5.5 排列
			32.5.6 fill()
			32.5.7 swap()
		32.6 排序和搜索
			32.6.1 二分搜索
			32.6.2 merge()
			32.6.3 集合算法 
			32.6.4 堆
			32.6.5 lexicographical_compare()
		32.7 最大值和最小值
		32.8 建议
	第33章  STL迭代器
		33.1 引言
			33.1.1 迭代器模型
			31.1.2 迭代器类别
			31.1.3 迭代器萃取
			31.1.4 迭代器操作
		33.2 迭代器适配器
			33.2.1 反向迭代器
			33.2.2 推入迭代器
			33.2.3 移动迭代器
		33.3 范围访问函数
		33.4 函数对象
		33.5 函数适配器
			33.5.1 bind()
			33.5.2 mem_fn()
			33.5.3 function
		33.6 建议
	第34章  内存和资源
		34.1 引言
		34.2 “拟容器”
			34.2.1 array 
			34.2.2 bitset
			34.2.3 vector<bool>
			34.2.4 元组
		34.3 资源管理指针
			34.3.1 unique_ptr
			34.3.2 shared_ptr
			34.3.3 weak_ptr
		34.4 分配器
			34.4.1 默认分配器
			34.4.2 分配器萃取
			34.4.3 指针萃取
			34.4.4 限域的分配器
		34.5 垃圾收集接口
		34.6 未初始化内存
			34.6.1 临时缓冲区
			34.6.2 raw_storage_iterator
		34.7 建议
	第35章  工具
		35.1 引言
		35.2 时间
			35.2.1 duration
			35.2.2 time_point
			35.2.3 时钟
			35.2.4 时间萃取
		35.3 编译时有理数运算
		35.4 类型函数
			35.4.1 类型萃取
			35.4.2 类型生成器
		35.5 其他工具
			35.5.1 move()和forward()
			35.5.2 swap()
			35.5.3 关系运算符
			35.5.4 比较和哈希type_info
		35.6 建议
	第36章  字符串
		36.1 引言
		36.2 字符分类
			36.2.1 分类函数
			36.2.2 字符萃取
		36.3 字符串
			36.3.1 string与C风格字符串
			36.3.2 构造函数
			36.3.3 基本操作
			36.3.4 字符串I/O
			36.3.5 数值转换
			36.3.6 类STL操作
			36.3.7 find系列函数
			36.3.8 子串
		36.4 建议
	第37章  正则表达式
		37.1 正则表达式
			37.1.1 正则表达式符号表示
		37.2 regex
			37.2.1 匹配结果
			37.2.2 格式化
		37.3 正则表达式函数
			37.3.1 regex_match()
			37.3.2 regex_search()
			37.3.3 regex_replace()
		37.4 正则表达式迭代器
			37.4.1 regex_iterator
			37.4.2 regex_token_iterator
		37.5 regex_traits
		37.6 建议
	第38章  I/O流
		38.1 引言
		38.2 I/O流层次
			38.2.1 文件流
			38.2.2 字符串流
		38.3 错误处理
		38.4 I/O操作
			38.4.1 输入操作
			38.4.2 输出操作
			38.4.3 操纵符
			38.4.4 流状态
			38.4.5 格式化
		38.5 流迭代器
		38.6 缓冲 
			38.6.1 输出流和缓冲区
			38.6.2 输入流和缓冲区
			38.6.3 缓冲区迭代器
		38.7 建议
	第39章  区域设置
		39.1 处理文化差异
		39.2 类locale
			39.2.1 命名locale
			39.2.2 比较string
		39.3 类facet
			39.3.1 访问locale中的facet
			39.3.2 一个简单的用户自定义facet
			39.3.3 locale和facet的使用
		39.4 标准facet
			39.4.1 string比较
			39.4.2 数值格式化
			39.4.3 货币格式化
			39.4.4 日期和时间格式化
			39.4.5 字符分类
			39.4.6 字符编码转换
			39.4.7 消息
		39.5 便利接口
			39.5.1 字符分类
			39.5.2 字符转换
			39.5.3 字符串转换
			39.5.4 缓冲区转换
		39.6 建议
	第40章  数值计算
		40.1 引言
		40.2 数值限制
			40.2.1 数值限制宏
		40.3 标准数学函数
		40.4 复数complex
		40.5 数值数组：valarray
			40.5.1 构造函数和赋值操作
			40.5.2 下标操作
			40.5.3 运算
			40.5.4 切片
			40.5.5 slice_array
			40.5.6 推广切片
		40.6 推广数值算法 
			40.6.1 accumulate()
			40.6.2 inner_product()
			40.6.3 partial_sum()和adjacent_difference()
			40.6.4 iota()
		40.7 随机数
			40.7.1 引擎
			40.7.2 随机设备
			40.7.3 分布
			40.7.4 C风格随机数
		40.8 建议
	第41章  并发
		41.1 引言
		41.2 内存模型
			41.2.1 内存位置
			41.2.2 指令重排
			41.2.3 内存序
			41.2.4 数据竞争
		41.3 原子性
			41.3.1 atomic类型
			41.3.2 标志和栅栏
		41.4 volatile
		41.5 建议
	第42章  线程和任务	
		42.1 引言
		42.2 线程
			42.2.1 身份
			42.2.2 构造
			42.2.3 析构
			42.2.4 join()
			42.2.5 detach()
			42.2.6 名字空间this_thread
			42.2.7 杀死thread
			42.2.8 thread_local数据
		42.3 避免数据竞争
			42.3.1 互斥量
			42.3.2 多重锁
			42.3.3 call_once()
			42.2.4 条件变量
		42.4 基于任务的并发
			42.4.1 future和promise
			42.4.2 promise
			42.4.3 packaged_task
			42.4.4 future
			42.4.5 shared_future
			42.4.6 async()
			42.4.7 一个并行find()示例
		42.5 建议
	第43章  C标准库
		43.1 引言
		43.2 文件
		43.3 printf()系列函数
		43.4 C风格字符串
		43.5 内存
		43.6 日期和时间
		43.7 杂项
		43.8 建议
	第44章  兼容性
		44.1 引言
		44.2 C++11扩展
			44.2.1 语言特性
			44.2.2 标准库组件
			44.2.3 弃用特性
			44.2.4 应对旧版本C++实现 
		44.3 C/C++兼容性
			44.3.1 C和C++是兄弟
			44.3.2 “静默”差异
			44.3.3 不兼容C++的C代码
			44.3.4 不兼容C的C++代码
		44.4 建议