C++ 多核高级编程 （Professional Multicore Programming）

官方网站：    
http://www.wrox.com
 
★
作者：Cameron Hughes、Tracey Hughes
其他书籍：《C++ 并行与分布式编程》、《C++ 面向对象多线程编程》

前言
	关于多核编程
	不同的视角
	解决方案是多范型方法
	为什么使用C++
	UML图
	支持的开发环境
	程序概要
	测试及代码可靠性     
	约定
	源代码
	勘误表
	p2p.wrox.com
第1章 新的体系结构 
	1.1 什么是多核 
	1.2 多核体系结构 
	1.3 软件开发人员眼中的多核体系结构 
		1.3.1 基本的处理器体系结构 
		1.3.2 CPU(指令集) 
		1.3.3 内存是关键 
		1.3.4 寄存器 
		1.3.5 cache 
		1.3.6 主存 
	1.4 总线连接 
	1.5 从单核到多核 
		1.5.1 多道程序设计和多处理 
		1.5.2 并行编程 
		1.5.3 多核应用程序的设计与实现 
	1.6 小结 
第2章 4种有影响的多核设计 
	2.1 AMD Multicore Opteron 
		2.1.1 Opteron的直连和HyperTransport 
		2.1.2 系统请求接口和交叉开关 
		2.1.3 Opteron使用NUMA结构 
		2.1.4 cache以及多处理器Opteron 
	2.2 Sun UltraSparc T1 多处理器 
		2.2.1 UltraSparc T1内核 
		2.2.2 Cross Talk与Crossbar 
		2.2.3 DDRAM控制器和L2 cache 
		2.2.4 UltraSparc T1、Sun和GNU gcc编译器 
	2.3 IBM Cell Broadband Engine 
		2.3.1 CBE与Linux 
		2.3.2 CBE内存模型 
		2.3.3 对操作系统隐藏 
		2.3.4 协处理器部件 
	2.4 Intel Core 2 Duo处理器 
		2.4.1 北桥和南桥 
		2.4.2 Intel的PCI Express 
		2.4.3 Core 2 Duo的指令集 
	2.5 小结 
第3章 多核编程的挑战 
	3.1 什么是顺序模型 
	3.2 什么是并发 
	3.3 软件开发 
		3.3.1 挑战1：软件分解 
		3.3.2 挑战2：任务间通信 
		3.3.3 挑战3：多个任务或agent对数据或资源的并发访问 
		3.3.4 挑战4：识别并发执行的任务之间的关系 
		3.3.5 挑战5：控制任务之间的资源争夺 
		3.3.6 挑战6：需要多少个进程或线程 
		3.3.7 挑战7和挑战8：寻找可靠的、可重现的调试和测试 
		3.3.8 挑战9：与拥有多进程组件的设计的相关人员进行沟通 
		3.3.9 挑战10：在C++中实现多处理和多线程 
	3.4 C++开发人员必须学习新的库 
	3.5 处理器架构的挑战 
	3.6 小结 
第4章 操作系统的任务 
	4.1 操作系统扮演什么角色 
		4.1.1 提供一致的接口 
		4.1.2 管理硬件资源和其他应用软件 
		4.1.3 开发人员与操作系统的交互 
		4.1.4 操作系统的核心服务 
		4.1.5 应用程序员的接口 
		程序概要4-1 
		程序概要4-2 
	4.2 分解以及操作系统的任务 
	4.3 隐藏操作系统的任务 
		4.3.1 利用C++抽象和封装的能力 
		4.3.2 POSIX API的接口类 
	4.4 小结 
第5章 进程、C++接口类和谓词 
	5.1 多核是指多处理器 
	5.2 什么是进程 
	5.3 为什么是进程而不是线程 
	5.4 使用posix_spawn() 
		5.4.1 file_actions参数 
		5.4.2 attrp参数 
		5.4.3 简单的posix_spawn()示例 
		5.4.4 使用posix_spawn的guess_it 
	5.5 哪个是父进程，哪个是子进程 
	5.6 对进程的详细讨论 
		5.6.1 进程控制块 
		5.6.2 进程的剖析 
		5.6.3 进程状态 
		5.6.4 进程是如何被调度的 
	5.7 使用ps实用工具监视进程 
	5.8 设置和获得进程优先级 
	5.9 什么是上下文切换 
	5.10 进程创建中的活动 
		5.10.1 使用fork()函数调用 
		5.10.2 使用exec()系统调用系列 
	5.11 进程环境变量的使用 
	5.12 使用system()生成新的进程 
	5.13 删除进程 
		5.13.1 调用exit()和abort() 
		5.13.2 kill()函数 
	5.14 进程资源 
		5.14.1 资源的类型 
		5.14.2 设置资源限制的POSIX函数 
	5.15 异步进程和同步进程 
	5.16 wait( )函数调用 
	5.17 谓词、进程和接口类 
	5.18 小结 
第6章 多线程 
	6.1 什么是线程 
		6.1.1 用户级线程和内核级线程 
		6.1.2 线程上下文 
		6.1.3 硬件线程和软件线程 
		6.1.4 线程资源 
	6.2 线程和进程的比较 
		6.2.1 上下文切换 
		6.2.2 吞吐量 
		6.2.3 实体间的通信 
		6.2.4 破坏进程数据 
		6.2.5 删除整个进程 
		6.2.6 被其他程序重用 
		6.2.7 线程与进程的关键类似和差别 
	6.3 设置线程属性 
	6.4 线程的结构 
		6.4.1 线程状态 
		6.4.2 调度和线程竞争范围 
		6.4.3 调度策略和优先级 
		6.4.4 调度分配域 
	6.5 简单的线程程序 
	6.6 创建线程 
		6.6.1 向线程传递参数 
		6.6.2 结合线程 
		6.6.3 获得线程id 
		6.6.4 使用pthread属性对象 
	6.7 管理线程 
		6.7.1 终止线程 
		6.7.2 管理线程的栈 
		6.7.3 设置线程调度和优先级 
		6.7.4 设置线程的竞争范围 
		6.7.5 使用sysconf() 
		6.7.6 线程安全和库 
	6.8 扩展线程接口类 
	6.9 小结 
第7章 并发任务的通信和同步 
	7.1 通信和同步 
		7.1.1 依赖关系 
		7.1.2 对任务依赖进行计数 
		7.1.3 什么是进程间通信 
		7.1.4 什么是线程间通信 
	7.2 对并发进行同步 
		7.2.1 同步的类型 
		7.2.2 同步对数据的访问 
		7.2.3 同步机制 
	7.3 线程策略方法 
		7.3.1 委托模型 
		7.3.2 对等模型 
		7.3.3 生产者-消费者模型 
		7.3.4 流水线模型 
		7.3.5 用于线程的SPMD和MPMD 
	7.4 工作的分解和封装 
		7.4.1 问题陈述 
		7.4.2 策略 
		7.4.3 观察 
		7.4.4 问题和解决方案 
		7.4.5 流水线的简单agent模型实例 
	7.5 小结 
第8章 PADL和PBS：应用程序设计方法 
	8.1 为大规模多核处理器设计应用程序 
	8.2 什么是PADL 
		8.2.1 第5层：应用程序架构选择 
		8.2.2 第4层：PADL中的并发模型 
		8.2.3 第3层：PADL的实现模型 
	8.3 谓词分解结构 
		8.3.1 示例：Guess-My-Code游戏的PBS 
		8.3.2 将PBS、PADL和SDLC联系起来 
		8.3.3 对PBS进行编码 
	8.4 小结 
第9章 对要求并发的软件系统进行建模 
	9.1 统一建模语言 
	9.2 对系统的结构进行建模 
		9.2.1 类模型 
		9.2.2 类的可视化 
		9.2.3 对属性和服务进行排序 
		9.2.4 类的实例的可视化 
		9.2.5 模板类的可视化 
		9.2.6 显示类与对象的关系 
		9.2.7 接口类的可视化 
		9.2.8 交互式对象的组织 
	9.3 UML与并发行为 
		9.3.1 协作对象 
		9.3.2 使用进程与线程的多任务与多线程 
		9.3.3 对象间的消息序列 
		9.3.4 对象的活动 
		9.3.5 状态机 
	9.4 整个系统的可视化 
	9.5 小结 
第10章 并行程序的测试和逻辑容错 
	10.1 能否跳过测试 
	10.2 测试中必须检查的5个并发挑战 
	10.3 失效：缺陷与故障导致的结果 
		10.3.1 基本的测试类型 
		10.3.2 缺陷排除与缺陷存活 
	10.4 如何对并行程序实现缺陷排除 
		10.4.1 问题陈述 
		10.4.2 简单策略和粗解决方案模型 
		10.4.3 使用PADL第5层的修正的解决方案模型 
		10.4.4 agent解决方案模型的PBS 
	10.5 什么是标准软件工程测试 
		10.5.1 软件验证与确认 
		10.5.2 代码不能正常工作该怎么办 
		10.5.3 什么是逻辑容错 
		10.5.4 谓词异常和可能世界 
		10.5.5 什么是模型检测 
	10.6 小结 
附录A 并发设计使用的UML  
附录B 并发模型  
附录C 线程管理的POSIX标准  
附录D 进程管理的POSIX标准  