// Copyright (c) 2011-2019
// Threading Core Render Engine
// ◊˜’ﬂ£∫≈ÌŒ‰—Ù£¨≈ÌÍ ∂˜£¨≈ÌÍ ‘Û
// 
// “˝«Ê∞Ê±æ£∫0.0.0.3 (2019/07/29 18:11)

#ifndef PHYSICS_PARTICLE_SYSTEM_MASS_SPRING_ARBITRARY_H
#define PHYSICS_PARTICLE_SYSTEM_MASS_SPRING_ARBITRARY_H

#include "Physics/PhysicsDll.h"

#include "ParticleSystemManager.h"

namespace Physics
{
	template <class Real, class TVector>
	class   MassSpringArbitrary	: public ParticleSystemManager<Real,TVector>
	{
	public:
		// Construction and destruction.  This class represents a set of M
		// masses that are connected by S springs with arbitrary topology.  The
		// function SetSpring(...) should be called for each spring that you
		// want in the system.
		MassSpringArbitrary (int numParticles, int numSprings, Real step);
		virtual ~MassSpringArbitrary ();

		int GetNumSprings () const;
		void SetSpring (int spring, int particle0, int particle1,Real constant, Real length);
		void GetSpring (int spring, int& particle0, int& particle1,Real& constant, Real& length) const;

		Real& Constant (int spring);
		Real& Length (int spring);

		// Callback for acceleration (ODE solver uses x" = F/m) applied to
		// particle i.  The positions and velocities are not necessarily
		// m_akPosition and m_akVelocity since the ODE solver evaluates the
		// impulse function at intermediate positions.
		virtual TVector Acceleration (int i, Real time,const TVector* positions, const TVector* velocities);

		// The default external force is zero.  Derive a class from this one to
		// provide nonzero external forces such as gravity, wind, friction,
		// and so on.  This function is called by Acceleration(...) to append the
		// acceleration F/m generated by the external force F.
		virtual TVector ExternalAcceleration (int i, Real time,const TVector* positions, const TVector* velocities);

	protected:
		using ParticleSystemManager<Real,TVector>::mNumParticles;
		using ParticleSystemManager<Real,TVector>::mInvMasses;

		class Spring
		{
		public:
			int Particle0, Particle1;
			Real Constant, Length;
		};

		int mNumSprings;
		Spring* mSprings;

		// Each particle has an associated array of spring indices for those
		// springs adjacent to the particle.  The set elements are spring
		// indices, not indices of adjacent particles.
		std::set<int>* mAdjacent;
	};

	using MassSpringArbitrary2f = MassSpringArbitrary<float,Mathematics::FloatVector2D>;
	using MassSpringArbitrary2d = MassSpringArbitrary<double,Mathematics::DoubleVector2D>;
	using MassSpringArbitrary3f = MassSpringArbitrary<float,Mathematics::FloatVector3D>;
	using MassSpringArbitrary3d = MassSpringArbitrary<double,Mathematics::DoubleVector3D>;
}

#endif // PHYSICS_PARTICLE_SYSTEM_MASS_SPRING_ARBITRARY_H
