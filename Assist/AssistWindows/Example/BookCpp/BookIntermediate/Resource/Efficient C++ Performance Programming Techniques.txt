提高C++性能的编程技术（Efficient C++:Performance Programming Techniques）

★★
作者：Dov Bulka、David Mayhew

知识点 
1.	跟踪范例。
2.	内存池。
3.	内联。
4.	优化。 

序言
导读
	★ 在使用汇编语言编程的时代，有经验的程序员通过计算汇编指令的数量来估计程序的执行速度。
	★ 每条C语言代码被翻译为5到8条汇编指令，这就与实际情况八九不离十了。
	★ 如果不了解潜在的错误，就无法指望通过偶然性获得好性能。
	★ 某些面向对象设计中的性能问题就是由于在错误的时间、错误的地方强调了性能而造成的。
	软件低效的根源
		★ 在最高层中，软件的效率由两个主要因素决定：设计效率和编码效率。
		★ 算法与数据结构的高效是必要条件，但不是充分条件：它本身不足以保证程序整体的高性能。
		★ 在提到性能时，我们必须记住以下几点：
			1. 内存不是无限大的。
			2. 内存访问开销不是均衡的。
			3. 我们的程序没有专用的CPU，只能间歇地获得一个时间片。
			4. 在一台单处理器的计算机上，并行的线程并不是真正地并行执行，它们是轮询的。
		★ 如果认为某段代码的性能比其灵活性和可重用性都重要，那么使用自己的实现来替代库提供的功能就是合理的。
		★ 为了最大程序地控制程序，您必须自己动手解决编码问题。
	我们的目标
		★ 软件危机就是指我们目前还无法开发足够简单，便于理解和维护，便于永久扩展的代码，也无法开发足够强大，能够对复杂问题提供解决方案的代码。
		★ 高性能的解决方案通常就是最简单的解决方案。
	软件效率：很重要吗？
	术语
		★ 空间效率标准寻求占用最小内存的软件解决方案。
		★ 时间效率标准寻求占用最少处理器周期的解决方案。时间效率通常以响应时间和吞吐量作为衡量指标。
		★ 步长、指令数：都代表代码段所产生的汇编语言指令的数量。
		★ 恰当的指令数对高性能来说是必要条件而非充分条件。
	本书结构
第1章  跟踪范例
	1.1 初步跟踪的实现
	1.2 要点
第2章  构造函数和析构函数
	2.1 继承
	2.2 复合
	2.3 缓式构造 
	2.4 冗余构造
	2.5 要点
第3章  虚函数
	3.1 虚函数的构造
	3.2 模板和继承
	3.3 要点
第4章  返回值优化
	4.1 按值返回机制
	4.2 返回值优化
	4.3 计算性构造函数
	4.4 要点
第5章  临时对象
	5.1 对象定义
	5.2 类型不匹配
	5.3 按值传递
	5.4 按值返回
	5.5 使用op=()消除临时对象
	5.6 要点
第6章  单线程内存池
	6.1 版本0：全局函数new()和delete()
	6.2 版本1：专用Rational内存管理器
	6.3 版本2：固定大小对象的内存池
	6.4 版本3：单线程可变大小内存管理器
	6.5 要点
第7章  多线程内存池
	7.1 版本4：实现 
	7.2 版本5：快速锁定
	7.3 要点
第8章  内联基础
	8.1 什么是内联？
	8.2 方法调用的代价
	8.3 因何内联？
	8.4 内联详述
	8.5 虚方法的内联
	8.6 通过内联提升性能
	8.7 要点
第9章  内联——性能方面的考虑
	9.1 调用间优化
	9.2 何时避免内联？
	9.3 开发阶段及编译期的内联考虑
	9.4 基于配置的内联
	9.5 内联规则
	9.6 要点
第10章  内联技巧
	10.1 条件内联
	10.2 选择性内联
	10.3 递归内联
	10.4 对静态局部变量进行内联
	10.5 与体系结构有关的注意事项：多寄存器集
	10.6 要点
第11章  标准模板库
	11.1 渐近复杂度
	11.2 插入
	11.3 删除
	11.4 遍历
	11.5 查找
	11.6 函数对象
	11.7 比STL更好？
	11.8 要点
第12章  引用计数
	12.1 实现细节
	12.2 已存在的类
	12.3 并发引用计数
	12.4 要点
第13章  编码优化
	13.1 缓存
	13.2 预先计算
	13.3 降低灵活性
	13.4 80-20法则：加快常用路径的速度
	13.5 延迟计算
	13.6 无用计算
	13.7 系统体系结构
	13.8 内存管理
	13.9 库和系统调用
	13.10 编译器优化
	13.11 要点
第14章  设计优化
	14.1 设计灵活性
	14.2 缓存
	14.3 高效的数据结构
	14.4 延迟计算
	14.5 getpeername()
	14.6 无用计算
	14.7 失败代码
	14.8 要点
第15章  可扩展性
	15.1 对称多处理器架构
	15.2 Amdahl定律
	15.3 多线程和同步
	15.4 将任务分解为多个子任务
	15.5 缓存共享数据
	15.6 无共享
	15.7 部分共享
	15.8 锁粒度
	15.9 伪共享
	15.10 惊群现象
	15.11 读/写锁
	15.12 要点
第16章  系统体系结构相关性
	16.1 存储器层级
	16.2 寄存器：存储器之王
	16.3 磁盘和内存结构
	16.4 缓存效应
	16.5 缓存抖动
	16.6 避免跳转
	16.7 使用简单计算代替小分支
	16.8 线程化的影响
	16.9 上下文切换
	16.10 内核交叉
	16.11 线程化选择
	16.12 要点