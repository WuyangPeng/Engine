21天学通C++（Sams Teach Yourself C++ in One Hour a Day）
（第8版）

官方网站 
http://www.ptpress.com.cn/。

●
作者：Siddhartha Rao

知识点 
1.	C++基础知识。
2.	C++基础知识练习。
3.	C++14基础知识。

代码 
1.  书籍代码。

要点
1.	C++14 新增了用单引号表示的组块分隔符。
	使用这种分隔符可提高代码的可读性，如-70'000（3.2 编译器支持的常见C++变量类型）。
2.	在大多数流行的C++编译器中，都通过常量M_PI提供了精度相当高的pi值（3.6 什么是常量）。

前言
	针对的读者
	本书内容
	本书使用的约定
	示例代码
第1章 绪论
	1.1 C++简史
		1.1.1 与C语言的关系
		1.1.2 C++的优点
		1.1.3 C++标准的发展历程
		1.1.4 哪些人使用C++程序			
	1.2 编写C++应用程序
		1.2.1 生成可执行文件的步骤
		1.2.2 分析并修复错误
		1.2.3 集成开发环境
		1.2.4 编写第一个C++应用程序
		1.2.5 生成并执行第一个C++应用程序
		1.2.6 理解编译错误			
	1.3 C++新增的功能
	1.4 总结
	1.5 问与答
	1.6 作业
		1.6.1 测验
		1.6.2 练习		
第2章 C++程序的组成部分
	2.1 Hello World程序的组成部分
		2.1.1 预处理器编译指令#include
		2.1.2 程序的主体—main()
		2.1.3 返回值			
	2.2 名称空间的概念
	2.3 C++代码中的注释
	2.4 C++函数
	2.5 使用std::cin和std::cout执行基本输入输出操作
	2.6 总结
	2.7 问与答
	2.8 作业
		2.8.1 测验
		2.8.2 练习		
第3章 使用变量和常量
	3.1 什么是变量
		3.1.1 内存和寻址概述
		3.1.2 声明变量以访问和使用内存
		3.1.3 声明并初始化多个类型相同的变量
		3.1.4 理解变量的作用域
		3.1.5 全局变量
		3.1.6 命名约定			
	3.2 编译器支持的常见C++变量类型
		3.2.1 使用bool变量存储布尔值
		3.2.2 使用char变量存储字符
		3.2.3 有符号整数和无符号整数的概念
		3.2.4 有符号整型short、int、long和long long
		3.2.5 无符号整型unsigned short、unsigned int、unsigned long和unsigned long long
		3.2.6 选择正确的数据类型以免发生溢出错误
		3.2.7 浮点类型float和double			
	3.3 使用sizeof确定变量的长度
		3.3.1 使用列表初始化避免缩窄转换错误
	3.4 使用auto自动推断类型
	3.5 使用typedef替换变量类型
	3.6 什么是常量
		3.6.1 字面常量
		3.6.2 使用const将变量声明为常量
		3.6.3 使用constexpr定义常量表达式
		3.6.4 枚举
		3.6.5 使用#define定义常量			
	3.7 不能用作常量或变量名的关键字
	3.8 总结
	3.9 问与答
	3.10 作业
		3.10.1 测验
		3.10.2 练习		
第4章 管理数组和字符串
	4.1 什么是数组
		4.1.1 为何需要数组
		4.1.2 声明和初始化静态数组
		4.1.3 数组中的数据是如何存储的
		4.1.4 访问存储在数组中的数据
		4.1.5 修改存储在数组中的数据			
	4.2 多维数组
		4.2.1 声明和初始化多维数组
		4.2.2 访问多维数组中的元素			
	4.3 动态数组
	4.4 C风格字符串
	4.5 C++字符串：使用std::string
	4.6 总结
	4.7 问与答
	4.8 作业
		4.8.1 测验
		4.8.2 练习
第5章 使用表达式、语句和运算符
	5.1 语句
	5.2 复合语句（语句块）
	5.3 使用运算符
		5.3.1 赋值运算符（＝）
		5.3.2 理解左值和右值
		5.3.3 加法运算符（+）、减法运算符（-）、乘法运算符（*）、除法运算符（/）和求模运算符（%）
		5.3.4 递增运算符（++）和递减运算符（--）
		5.3.5 前缀还是后缀
		5.3.6 相等运算符（==）和不等运算符（!=）
		5.3.7 关系运算符
		5.3.8 逻辑运算NOT、AND、OR和XOR
		5.3.9 使用C++逻辑运算NOT（!）、AND（&&）和OR（||）
		5.3.10 按位运算符NOT（~）、AND（&）、OR（|）和XOR（^）
		5.3.11 按位右移运算符（>>）和左移运算符（<<）
		5.3.12 复合赋值运算符
		5.3.13 使用运算符sizeof确定变量占用的内存量
		5.3.14 运算符优先级			
	5.4 总结
	5.5 问与答
	5.6 作业
		5.6.1 测验
		5.6.2 练习		
第6章 控制程序流程
	6.1 使用if…else有条件地执行
		6.1.1 使用if…else进行条件编程
		6.1.2 有条件地执行多条语句
		6.1.3 嵌套if语句
		6.1.4 使用switch-case进行条件处理
		6.1.5 使用运算符?:进行条件处理			
	6.2 在循环中执行代码
		6.2.1 不成熟的goto循环
		6.2.2 while循环
		6.2.3 do…while循环
		6.2.4 for循环
		6.2.5 基于范围的for循环			
	6.3 使用continue和break修改循环的行为
		6.3.1 不结束的循环—无限循环
		6.3.2 控制无限循环			
	6.4 编写嵌套循环
		6.4.1 使用嵌套循环遍历多维数组
		6.4.2 使用嵌套循环计算斐波纳契数列
	6.5 总结
	6.6 问与答
	6.7 作业
		6.7.1 测验
		6.7.2 练习		
第7章 使用函数组织代码
	7.1 为何需要函数
		7.1.1 函数原型是什么
		7.1.2 函数定义是什么
		7.1.3 函数调用和实参是什么
		7.1.4 编写接受多个参数的函数
		7.1.5 编写没有参数和返回值的函数
		7.1.6 带默认值的函数参数
		7.1.7 递归函数——调用自己的函数
		7.1.8 包含多条return语句的函数			
	7.2 使用函数处理不同类型的数据
		7.2.1 函数重载
		7.2.2 将数组传递给函数
		7.2.3 按引用传递参数			
	7.3 微处理器如何处理函数调用
		7.3.1 内联函数
		7.3.2 自动推断返回类型
		7.3.3 lambda函数			
	7.4 总结
	7.5 问与答
	7.6 作业
		7.6.1 测验
		7.6.2 练习			
第8章 阐述指针和引用
	8.1 什么是指针
		8.1.1 声明指针
		8.1.2 使用引用运算符（&）获取变量的地址
		8.1.3 使用指针存储地址
		8.1.4 使用解除引用运算符（*）访问指向的数据
		8.1.5 将sizeof()用于指针的结果			
	8.2 动态内存分配
		8.2.1 使用new和delete动态地分配和释放内存
		8.2.2 将递增和递减运算符（++和--）用于指针的结果
		8.2.3 将关键字const用于指针
		8.2.4 将指针传递给函数
		8.2.5 数组和指针的类似之处			
	8.3 使用指针时常犯的编程错误
		8.3.1 内存泄露
		8.3.2 指针指向无效的内存单元
		8.3.3 悬浮指针（也叫迷途或失控指针）
		8.3.4 检查使用new发出的分配请求是否得到满足
	8.4 指针编程最佳实践
	8.5 引用是什么
		8.5.1 是什么让引用很有用
		8.5.2 将关键字const用于引用
		8.5.3 按引用向函数传递参数			
	8.6 总结
	8.7 问与答
	8.8 作业
		8.8.1 测验
		8.8.2 练习		
第9章 类和对象
	9.1 类和对象
		9.1.1 声明类
		9.1.2 作为类实例的对象
		9.1.3 使用句点运算符访问成员
		9.1.4 使用指针运算符（->）访问成员
	9.2 关键字public和private
		9.2.1 使用关键字private实现数据抽象
	9.3 构造函数
		9.3.1 声明和实现构造函数
		9.3.2 何时及如何使用构造函数
		9.3.3 重载构造函数
		9.3.4 没有默认构造函数的类
		9.3.5 带默认值的构造函数参数
		9.3.6 包含初始化列表的构造函数			
	9.4 析构函数
		9.4.1 声明和实现析构函数
		9.4.2 何时及如何使用析构函数			
	9.5 复制构造函数
		9.5.1 浅复制及其存在的问题
		9.5.2 使用复制构造函数确保深复制
		9.5.3 有助于改善性能的移动构造函数
	9.6 构造函数和析构函数的其他用途
		9.6.1 不允许复制的类
		9.6.2 只能有一个实例的单例类
		9.6.3 禁止在栈中实例化的类
		9.6.4 使用构造函数进行类型转换			
	9.7 this指针
	9.8 将sizeof()用于类
	9.9 结构不同于类的地方
	9.10 声明友元
	9.11 共用体：一种特殊的数据存储机制
		9.11.1 声明共用体
		9.11.2 在什么情况下使用共用体			
	9.12 对类和结构使用聚合初始化
		9.12.1 将consexpr用于类和对象
	9.13 总结
	9.14 问与答
	9.15 作业
		9.15.1 测验
		9.15.2 练习		
第10章 实现继承
	10.1 继承基础
		10.1.1 继承和派生
		10.1.2 C++派生语法
		10.1.3 访问限定符protected
		10.1.4 基类初始化——向基类传递参数
		10.1.5 在派生类中覆盖基类的方法
		10.1.6 调用基类中被覆盖的方法
		10.1.7 在派生类中调用基类的方法
		10.1.8 在派生类中隐藏基类的方法
		10.1.9 构造顺序
		10.1.10 析构顺序
	10.2 私有继承
	10.3 保护继承
	10.4 切除问题
	10.5 多继承
	10.6 使用final禁止继承
	10.7 总结
	10.8 问与答
	10.9 作业
		10.9.1 测验
		10.9.2 练习
第11章 多态
	11.1 多态基础
		11.1.1 为何需要多态行为
		11.1.2 使用虚函数实现多态行为
		11.1.3 为何需要虚构造函数
		11.1.4 虚函数的工作原理——理解虚函数表
		11.1.5 抽象基类和纯虚函数
	11.2 使用虚继承解决菱形问题
	11.3 表明覆盖意图的限定符override
	11.4 使用final来禁止覆盖函数
	11.5 可将复制构造函数声明为虚函数吗
	11.6 总结
	11.7 问与答
	11.8 作业
		11.8.1 测验
		11.8.2 练习		
第12章 运算符类型与运算符重载
	12.1 C++运算符
	12.2 单目运算符
		12.2.1 单目运算符的类型
		12.2.2 单目递增与单目递减运算符
		12.2.3 转换运算符
		12.2.4 解除引用运算符（*）和成员选择运算符（->）
	12.3 双目运算符
		12.3.1 双目运算符的类型
		12.3.2 双目加法与双目减法运算符
		12.3.3 实现运算符+=与-=
		12.3.4 重载等于运算符（==）和不等运算符（!=）
		12.3.5 重载运算符<、>、<=和>=
		12.3.6 重载复制赋值运算符（=）
		12.3.7 下标运算符
	12.4 函数运算符operator()
	12.5 用于高性能编程的移动构造函数和移动赋值运算符
		12.5.1 不必要的复制带来的问题
		12.5.2 声明移动构造函数和移动赋值运算符
	12.6 用户定义的字面量
	12.7 不能重载的运算符
	12.8 总结
	12.9 问与答
	12.10 作业
		12.10.1 测验
		12.10.2 练习		
第13章 类型转换运算符
	13.1 为何需要类型转换
	13.2 为何有些C++程序员不喜欢C风格类型转换
	13.3 C++类型转换运算符
		13.3.1 使用static_cast
		13.3.2 使用dynamic_cast和运行阶段类型识别
		13.3.3 使用reinterpret_cast
		13.3.4 使用const_cast			
	13.4 C++类型转换运算符存在的问题
	13.5 总结
	13.6 问与答
	13.7 作业
		13.7.1 测验
		13.7.2 练习		
第14章 宏和模板简介
	14.1 预处理器与编译器
	14.2 使用#define定义常量
		14.2.1 使用宏避免多次包含
	14.3 使用#define编写宏函数
		14.3.1 为什么要使用括号
		14.3.2 使用assert宏验证表达式
		14.3.3 使用宏函数的优点和缺点			
	14.4 模板简介
		14.4.1 模板声明语法
		14.4.2 各种类型的模板声明
		14.4.3 模板函数
		14.4.4 模板与类型安全
		14.4.5 模板类
		14.4.6 声明包含多个参数的模板
		14.4.7 声明包含默认参数的模板
		14.4.8 一个模板示例
		14.4.9 模板的实例化和具体化
		14.4.10 模板类和静态成员
		14.4.11 参数数量可变的模板
		14.4.12 使用static_assert执行编译阶段检查
		14.4.13 在实际C++编程中使用模板
	14.5 总结
	14.6 问与答
	14.7 作业
		14.7.1 测验
		14.7.2 练习	
第15章 标准模板库简介
	15.1 STL容器
		15.1.1 顺序容器
		15.1.2 关联容器
		15.1.3 容器适配器		
	15.2 STL迭代器
	15.3 STL算法
	15.4 使用迭代器在容器和算法之间交互
		15.4.1 使用关键字auto让编译器确定类型
	15.5 选择正确的容器
	15.6 STL字符串类
	15.7 总结
	15.8 问与答
	15.9 作业		
第16章 STL string类
	16.1 为何需要字符串操作类
	16.2 使用STL string类
		16.2.1 实例化和复制STL string
		16.2.2 访问std::string的字符内容
		16.2.3 拼接字符串
		16.2.4 在string中查找字符或子字符串
		16.2.5 截短STL string
		16.2.6 字符串反转
		16.2.7 字符串的大小写转换
	16.3 基于模板的STL string实现
	16.4 总结
	16.5 问与答
	16.6 作业
		16.6.1 测验
		16.6.2 练习		
第17章 STL动态数组类
	17.1 std::vector的特点
	17.2 典型的vector操作
		17.2.1 实例化vector
		17.2.2 使用push_back()在末尾插入元素
		17.2.3 列表初始化
		17.2.4 使用insert()在指定位置插入元素
		17.2.5 使用数组语法访问vector中的元素
		17.2.6 使用指针语法访问vector中的元素
		17.2.7 删除vector中的元素			
	17.3 理解大小和容量
	17.4 STL deque类
	17.5 总结
	17.6 问与答
	17.7 作业
		17.7.1 测验
		17.7.2 练习		
第18章 STL list和forward_list
	18.1 std::list的特点
	18.2 基本的list操作
		18.2.1 实例化std::list对象
		18.2.2 在list开头或末尾插入元素
		18.2.3 在list中间插入元素
		18.2.4 删除list中的元素			
	18.3 对list中的元素进行反转和排序
		18.3.1 使用list::reverse()反转元素的排列顺序
		18.3.2 对元素进行排序
		18.3.3 对包含对象的list进行排序以及删除其中的元素
		18.3.4 C++11引入的std::forward_list
	18.4 总结
	18.5 问与答
	18.6 作业
		18.6.1 测验
		18.6.2 练习		
第19章 STL集合类
	19.1 简介
	19.2 STL set和multiset的基本操作
		19.2.1 实例化std::set对象
		19.2.2 在set或multiset中插入元素
		19.2.3 在STL set或multiset中查找元素
		19.2.4 删除STL set或multiset中的元素	
	19.3 使用STL set和multiset的优缺点
	19.4 总结
	19.5 问与答
	19.6 作业
		19.6.1 测验
		19.6.2 练习		
第20章 STL映射类
	20.1 STL映射类简介
	20.2 STL map和multimap的基本操作
		20.2.1 实例化std::map和std::multimap
		20.2.2 在STL map或multimap中插入元素
		20.2.3 在STL map或multimap中查找元素
		20.2.4 在STL multimap中查找元素
		20.2.5 删除STL map或multimap中的元素
	20.3 提供自定义的排序谓词
	20.4 基于散列表的STL键——值对容器
		20.4.1 散列表的工作原理
		20.4.2 使用unordered_map和unordered_multimap
	20.5 总结
	20.6 问与答
	20.7 作业
		20.7.1 测验
		20.7.2 练习
第21章 理解函数对象
	21.1 函数对象与谓词的概念
	21.2 函数对象的典型用途
		21.2.1 一元函数
		21.2.2 一元谓词
		21.2.3 二元函数
		21.2.4 二元谓词			
	21.3 总结
	21.4 问与答
	21.5 作业
		21.5.1 测验
		21.5.2 练习		
第22章 lambda表达式
	22.1 lambda表达式是什么
	22.2 如何定义lambda表达式
	22.3 一元函数对应的lambda表达式
	22.4 一元谓词对应的lambda表达式
	22.5 通过捕获列表接受状态变量的lambda表达式
	22.6 lambda表达式的通用语法
	22.7 二元函数对应的lambda表达式
	22.8 二元谓词对应的lambda表达式
	22.9 总结
	22.10 问与答
	22.11 作业
		22.11.1 测验
		22.11.2 练习
第23章 STL算法
	23.1 什么是STL算法
	23.2 STL算法的分类
		23.2.1 非变序算法
		23.2.2 变序算法			
	23.3 使用STL算法
		23.3.1 根据值或条件查找元素
		23.3.2 计算包含给定值或满足给定条件的元素数
		23.3.3 在集合中搜索元素或序列
		23.3.4 将容器中的元素初始化为指定值
		23.3.5 使用std::generate()将元素设置为运行阶段生成的值
		23.3.6 使用for_each()处理指定范围内的元素
		23.3.7 使用std::transform()对范围进行变换
		23.3.8 复制和删除操作
		23.3.9 替换值以及替换满足给定条件的元素
		23.3.10 排序、在有序集合中搜索以及删除重复元素
		23.3.11 将范围分区
		23.3.12 在有序集合中插入元素			
	23.4 总结
	23.5 问与答
	23.6 作业
		23.6.1 测验
		23.6.2 练习		
第24章 自适应容器：栈和队列
	24.1 栈和队列的行为特征
		24.1.1 栈
		24.1.2 队列			
	24.2 使用STL stack类
		24.2.1 实例化stack
		24.2.2 stack的成员函数
		24.2.3 使用push()和pop()在栈顶插入和删除元素
	24.3 使用STL queue类
		24.3.1 实例化queue
		24.3.2 queue的成员函数
		24.3.3 使用push()在队尾插入以及使用pop()从队首删除
	24.4 使用STL优先级队列
		24.4.1 实例化priority_queue类
		24.4.2 priority_queue的成员函数
		24.4.3 使用push()在priority_queue末尾插入以及使用pop()在priority_queue开头删除
	24.5 总结
	24.6 问与答
	24.7 作业
		24.7.1 测验
		24.7.2 练习
第25章 使用STL位标志
	25.1 bitset类
	25.2 使用std::bitset及其成员
		25.2.1 std:bitset的运算符
		25.2.2 std::bitset的成员方法
	25.3 vector<bool>
		25.3.1 实例化vector<bool>
		25.3.2 vector<bool>的成员函数和运算符
	25.4 总结
	25.5 问与答
	25.6 作业
		25.6.1 测验
		25.6.2 练习
第26章 理解智能指针
	26.1 什么是智能指针
		26.1.1 常规（原始）指针存在的问题
		26.1.2 智能指针有何帮助
	26.2 智能指针是如何实现的
	26.3 智能指针类型
		26.3.1 深复制
		26.3.2 写时复制机制
		26.3.3 引用计数智能指针
		26.3.4 引用链接智能指针
		26.3.5 破坏性复制
		26.3.6 使用std::unique_ptr
	26.4 深受欢迎的智能指针库
	26.5 总结
	26.6 问与答
	26.7 作业
		26.7.1 测试
		26.7.2 练习
第27章 使用流进行输入和输出
	27.1 流的概述
	27.2 重要的C++流类和流对象
	27.3 使用std::cout将指定格式的数据写入控制台
		27.3.1 使用std::cout修改数字的显示格式
		27.3.2 使用std::cout对齐文本和设置字段宽度
	27.4 使用std::cin进行输入
		27.4.1 使用std::cin将输入读取到基本类型变量中
		27.4.2 使用std::cin:get将输入读取到char*缓冲区中
		27.4.3 使用std::cin将输入读取到std::string中
	27.5 使用std::fstream处理文件
		27.5.1 使用open()和close()打开和关闭文件
		27.5.2 使用open()创建文本文件并使用运算符<<写入文本
		27.5.3 使用open()和运算符>>读取文本文件
		27.5.4 读写二进制文件
	27.6 使用std::stringstream对字符串进行转换
	27.7 总结
	27.8 问与答
	27.9 作业
		27.9.1 测验
		27.9.2 练习
第28章 异常处理
	28.1 什么是异常
	28.2 导致异常的原因
	28.3 使用try和catch捕获异常
		28.3.1 使用catch(…)处理所有异常
		28.3.2 捕获特定类型的异常
		28.3.3 使用throw引发特定类型的异常
	28.4 异常处理的工作原理
		28.4.1 std::exception类
		28.4.2 从std::exception派生出自定义异常类
	28.5 总结
	28.6 问与答
	28.7 作业
		28.7.1 测验
		28.7.2 练习
第29章 继续前行
	29.1 当今的处理器有何不同
	29.2 如何更好地利用多个内核
		29.2.1 线程是什么
		29.2.2 为何要编写多线程应用程序
		29.2.3 线程如何交换数据
		29.2.4 使用互斥量和信号量同步线程
		29.2.5 多线程技术带来的问题
	29.3 编写杰出的C++代码
	29.4 C++17有望引入的新特性
		29.4.1 支持在if和switch中进行初始化
		29.4.2 保证复制得以避免
		29.4.3 避免内存分配开销的std::string_view
		29.4.4 类型安全的共用体替代品std::variant
		29.4.5 使用if constexpr有条件地编译代码
		29.4.6 改进的lambda表达式
		29.4.7 在构造函数中使用类型自动推断功能
	29.5 更深入地学习C++
		29.5.1 在线文档
		29.5.2 提供指南和帮助的社区
	29.6 总结
	29.7 问与答
	29.8 作业
附录A 二进制和十六进制
	A.1 十进制
	A.2 二进制
		A.2.1 计算机为何使用二进制
		A.2.2 位和字节
		A.2.3 1KB相当于多少字节
	A.3 十六进制
	A.4 不同进制之间的转换
		A.4.1 通用转换步骤
		A.4.2 从十进制转换为二进制
		A.4.3 从十进制转换为十六进制
附录B C++关键字
附录C 运算符优先级
附录D ASCII码
	D.1 可打印字符ASCII表
附录E 答案