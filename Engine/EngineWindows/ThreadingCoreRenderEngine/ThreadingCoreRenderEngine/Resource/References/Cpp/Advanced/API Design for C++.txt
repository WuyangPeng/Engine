C++ API设计（API Design for C++）

官方网站：
http://APIBook.com、 http://www.apidiff.com/en/。

敏捷开发宣言：
http://agilemanifesto.org/。

开源的3D图形工具包，用于可视化仿真应用。
http://www.openscenegraph.org/。

PHP手册：
http://www.php.net/manual。

Doxygen：
http://www.doxygen.org/。

Apache HTTP Server 文档：
http://httpd.apache.org/docs/。

PNG图像测试套件
http://www.schaik.com/

自动化测试框架：
https://sourceforge.net/projects/cppunit/
http://www.boost.org/

代码覆盖率：
https://www.bullseye.com/

SWIG：
http://www.swig.org/

Ruby：
http://www.ruby-lang.org/zh_cn/

★★★  
作者：Martin Reddy

联系作者：
martin@martinreddy.net

知识点 
1.	编写健壮而优雅的应用程序编程接口。 
2.	模式的基础知识。
3.	设计的基础知识。

代码
1.	hide_class（2.2 隐藏实现细节）。
2.	coord2d_template（2.4 易用性）。
3.	shared_pointer（2.4 易用性）。
4.	callback_instance（2.5 松耦合）。
5.	callback_static（2.5 松耦合）。
6.	pimpl_bad（3.1 Pimpl惯用法）。
7.	pimpl_good（3.1 Pimpl惯用法）。
8.	pimpl_boost（3.1 Pimpl惯用法）。
9.	opaque_pointer（3.1 Pimpl惯用法）。
10.	singleton（3.2 单例）。
11.	factory_simple（3.3 工厂模式）。
12.	factory_extensible（3.3 工厂模式）。
13.	proxy_simple（3.4 API包装器模式）。
14.	proxy_interface（3.4 API包装器模式）。
15.	adapter（3.4 API包装器模式）。
16.	facade（3.4 API包装器模式）。
17.	observer（3.5 观察者模式）。
18. named_parameters（第4章 设计）。
19. stack_c（5.1.3 使用ANSI C编写API）
20.	stack_cpp（5.1.3 使用ANSI C编写API）
21.	stack_template（5.3.1 基于模板的API示例）
22.	stack_preprocessor（5.3.2 模板与宏）
23.	stack_datadriven（5.4 数据驱动API）
24.	constructors（6.2 构造函数和赋值）
25.	template_polymorphism（6.4 模板）
26.	template_specialization（6.4.2 隐式实例化API设计）
27.	template_explicit（6.4.3 显示实例化API设计）
28.	operators（6.5 操作符重载）
29. bad_friends（6.8 避免使用友元）
30.	extern_leakage（6.9 导出符号）
31.	const_reference（7.1 通过const引用传递输入参数）
32. struct_size（7.5 内存优化）
33. virtual_speed（7.5 内存优化）
34. getter_speed（7.6 除非必要，勿用内联）
35. copy_on_write（7.7 写时复制）
36. iterators（7.8 迭代元素）
37.	auto_timer（7.9 性能分析）
38.	version_api（8.1.3 提供API的版本信息）
39.	deprecate_compiletime（8.5.3 弃用功能）
40.	deprecate_runtime（8.5.3 弃用功能）
41.	doxygen（第9章 文档）
42.	unit_test（10.2.1 单元测试）
43.	self_test（10.4.3 测试私有代码）
44. python（第11章 脚本化）
45. ruby（第11章 脚本化）
46. plugin_api（12.1 通过插件扩展）
47. visitor（12.2.5 访问者模式）
48. curious_templates（12.3 通过模板扩展）
49. gcc_plugin（A.3 Linux上的库）
50. gcc_entry_point（A.3 Linux上的库）

要点
1.	API是软件组件的逻辑接口，隐藏了实现这个接口所需的内部细节。（1.1 什么是API）
2.	API描述了其他工程师构建他们的应用软件所使用的软件。
	因此，API必须拥有良好的设计、文档、回归测试，并且保证发布之间的稳定性。（1.2 API设计上有什么不同）
3.	优质的API应该设计精巧且实用性强。它不仅能带来愉悦的使用体验，且能与各种应用程序完美融合，甚至让使用者感觉不到其存在。（2.1 问题域建模）
4.	类的数据成员应该始终声明为私有的，而不是公有的或受保护的。（2.2 隐藏实现细节）
5.	永远不要返回私有数据成员的非const指针或引用。这会破坏封装性。（2.2 隐藏实现细节）
6.	谨记以下几点原则：（2.3 最小完备性）
	（1）如果类包含任一虚函数，那么必须将析构函数声明为虚函数。
	（2）一定要编写文档，说明类的方法是如何相互调用的。
	（3）绝不在构造函数或析构函数中调用虚函数，这些调用不会指向子类。
7.	除非确实需要#include类的完整定义，否则应该为类使用前置声明。（2.5 松耦合）
8.	敏捷开发宣言：（4.3.4 需求与敏捷开发）
	（1）个体与交互重于过程与工具。
	（2）工作的软件重于全面的文档。
	（3）客户合作重于合同谈判。
	（4）响应变化重于因循计划。
9.	当向const函数传入引用或指针时，也要考虑该参数是否可以声明为const。（6.3.2 参数的const正确性）

第1章 API简介
	★	C++ API包含如下的元素：
		1.	头文件。
		2.	类库。
		3.	文档。
	★	API开发中的一些关键因素：
		1.	API是为开发者设计的接口，如同GUI是为用户设计的接口一样。
		2.	多个应用程序可以共享一个API。
		3.	修改API时，必须尽可能保证向后兼容。
		4.	出于向后兼容的需求，一定要具有变更控制流程。
		5.	API的生存周期一般都比较长。
		6.	在编写API时，良好的文档必不可少，特别是当不提供实现的源代码时。
		7.	自动化测试同样也很重要。
	★	构建API带来以下好处：
		1.	隐藏实现。
		2.	延长寿命。
		3.	促进模块化。
		4.	减少代码重复。
		5.	消除硬编码假设。
		6.	易于改变实现。
		7.	易于优化。
	★	何时应该避免使用API：
		1.	许可证限制。
		2.	功能不匹配。
		3.	缺少源代码。
		4.	缺乏文档。
	★	每当于创建一个文件格式或者客户端/服务器协议时，同时也要为其创建API。
		这样，规范的细节以及未来的任何变更都将是集中且隐蔽的。
第2章 特征
	★	创建API的主要原因是隐藏所有的实现细节，以免将来修改API对已有客户造成影响。有两种技巧可以达到此目标：物理隐藏和信息隐藏。
	★	声明告诉编译器某个标识符的名称及类型。定义提供该标识符的完整细节，即它是一个函数还是一块内存区域。
	★	物理隐藏表示将内部细节（.cpp）和公有接口（.h）分离，存储在不同的文件中。
	★	封装是将API的公有接口与其底层实现分离的过程。
	★	逻辑隐藏指的是使用C++语言中受保护的和私有的访问控制从而限制访问内部细节。
	★	使用getter/setter惯用法与直接暴露成员变量相比，还有以下额外的好处：
		1.	有效性验证。
		2.	惰性求值。
		3.	缓存。
		4.	额外的计算。
		5.	通知。
		6.	调试。
		7.	同步。
		8.	更精细的访问控制。
		9.	维护
	★	将私有功能声明为.cpp文件中的静态函数，而不要将其作为私有方法暴露在公开的头文件中。（更好的做法是使用Pimpl惯用法）
	★	谨记奥卡姆剃刀原理：若无必要，勿增实体。
	★	当不确定是否需要某个接口时，就不要提供此接口。
		1.	你想要添加的通用性可能永远不会用到。
		2.	如果某天用到了想要添加的通用性，那时你可能已经掌握了更多API的设计知识，并可能有了与最初设想方案不同的解决方案。
		3.	如果你确实需要添加新功能，那么简单的API比复杂的API更容易添加新功能。
	★	应该保证API尽量简单：类及类中的公有成员暴露得越少越好。
		这样做的好处是API会更易于理解，更易于用户记住API模型，而且更易于调试。
	★	疑惑之时，果断弃之！精简API中公有的类和函数。
	★	继承十分强大，但仍要意识到其潜在的隐患：
		1.	对基类看似无害的修改可能会给客户带来不利的影响。
		2.	客户可能会以你根本无法预料的方式使用API。
		3.	客户可能采用不正确的或易于出错的方式扩展API。
		4.	重写函数可能破坏类的内部完整性。
	★	C++中使用虚函数时还要注意以下常见问题：
		1.	虚函数的调用必须在运行时查询虚函数表决定，而非虚函数的调用在编译时就能确定。
		2.	使用虚函数一般需要维护指向虚函数表的指针，进而增加了对象的大小。
		3.	添加、重排或移除虚函数会破坏二进制兼容性。
		4.	不是所有的虚函数都能内联，因而将虚函数声明为内联是没有任何意义的。
		5.	重载虚函数是需要技巧的。更好的方式是避免重载虚函数。
	★	应该将虚函数声明为私有的，并且仅在派生类需要调用虚函数的基类实现时才将其声明为受保护的派生类。
		因此，接口应当是非虚的，同时在适当的情况下使用模板方法设计模式。
	★	避免将函数声明为可以重写的函数（虚的），除非你有合理且迫切的需求。
	★	API应该通过易用接口来呈现基本功能，同时将高级功能隐藏在另一个独立的层次中。
	★	基于最小化的核心API，以独立的模块或库的形式构建便捷API。
	★	使用枚举类型代替布尔类型，提高代码的可读性。
	★	避免编写拥有多个相同类型参数的函数。
	★	使用一致的函数命名和参数顺序。
	★	正交的API意味着函数没有副作用。
		1.	减少冗余。
		2.	增加独立性。
	★	大部分的C++错误都是由于误用指针或引用所导致的：
		1.	对NULL解引用。
		2.	二次释放。
		3.	访问非法内存区域。
		4.	混用内存分配器。
		5.	数组释放不正确。
		6.	内存泄露。
	★	这些特定的问题可通过使用托管指针避免：
		1.	共享指针。
		2.	弱指针。
		3.	作用域指针。
	★	客户需要的指针的生命周期比对象的生命周期更长时，就应该返回智能指针。
		如果由对象持有指针的所有权，那么可以返回一个标准指针。
	★	当需要客户销毁指针时，使用智能指针返回动态申请的对象。
	★	将资源的申请与释放当作对象的构造和析构。
	★	不要将平台相关的#if和#ifdef语句放在公共的API中，因为这些语句暴露了实现细节，并使API因平台而异。
	★	耦合：软件组件之间相互连接的强度的度量，即系统中每个组件对其他组件的依赖程序。
	★	内聚：单个软件组件内的各种方法相互关联或聚合强度的度量。
	★	优秀的API表现为松耦合和高内聚。
	★	评估组件之间的耦合度可以采用下面几种不同的度量方式：
		1.	尺度。
		2.	可见度。
		3.	密切度。
		4.	灵活度。
	★	与成员函数相比，使用非成员、非友元的方法能降低耦合度。
	★	有时，使用数据冗余降低类之间的耦合是合理的。
	★	管理器类可以通过封装几个低层次类来降低耦合。
	★	回调、观察者和通知需要注意的一些共通问题：
		1.	重入。
		2.	生命周期管理。
		3.	事件顺序。
	★	优秀的API设计应该是稳定的且具有前瞻性。在当前语境中，稳定不一定意味着API不会改变，
		而是应该将接口版本化，并且在版本升级时保证身后兼容。
	★	优秀的API设计也应该有很好的文档支持，以便用户获取API的功能、行为、最佳实践以及错误条件的明确信息。
		最终，应该为API的实现编写可扩展的自动化测试程序，确保新的变更不会破坏现有用例。
第3章 模式
	★	对高质量API设计而言至关重要的设计模式：
		1.	Pimpl惯用法：该技巧支持在公有接口中完全隐藏内部细节。
		2.	单例和工厂方法：如果要确保只创建一个对象实例，那么单例模式很有用。
							工厂方法提供了创建对象实例的通用方法，它是隐藏派生类实现细节的好方法。
		3.	代理、适配器和外观：这几种结构型模式提供了在现有的不兼容接口或遗留接口上封装API的各种途径。
		4.	观察者：该行为模式可以用来减少类之间的直接依赖。
					它通过一个类（观察者）在另一个类（主体）中注册通知的方式，使得概念上不相关的类相互通信。
	★	使用Pimpl惯用法将实现细节从公有头文件中分离出来。
	★	使用Pimpl惯用法时，应采用私有内嵌实现类。只有在.cpp文件中其他类或自由函数必须访问Impl成员时，才应采用公有内嵌类。
	★	两个注意事项：
		1.	不能在实现类中隐藏私有虚方法。它们必须出现在公有类中，以保证任何派生类都能够覆盖它们。
		2.	虽然可以将公有类传递给需要使用它的实现类的方法，但必要时可以在实现类中增加指回公有类的指针，以便Impl类调用公有方法。
	★	复制语义：
		1.	禁止复制类。
		2.	显式定义复制语义。
	★	注意Pimpl类的复制语义，可以使用智能指针管理指向impl对象的指针的初始化和销毁。
	★	Pimpl惯用法的优点：
		1.	信息隐藏。
		2.	降低耦合。
		3.	加速编译。
		4.	更好的二进制兼容性。
		5.	惰性分配。
	★	Pimpl的缺点：
		1.	必须为你创建的每个对象分配并释放实现对象。
		2.	即访问所有私有成员都需要增加开如Impl->的前缀，增加的抽象层次使得实现代码更加难以阅读和调试。
		3.	编译器将不再能够捕获const方法中对成员变量的修改。
	★	单例设计模式用来确保一个类仅存一个实例。该模式变提供对此唯一实例的全局访问点。
		可以认为单例是一种更加优雅的全局变量。
	★	单例的一些优点：
		1.	确保一个类只创建一个实例。
		2.	为对象分配和销毁提供控制。
		3.	支持线程安全地访问对象的全局状态。
		4.	避免污染全局命名空间。
	★	单例是一种更加优雅地维护全局状态的方式，但始终应该考虑清楚是否需要全局状态。
	★	将构造函数、析构函数、复制构造函数以及赋值操作符声明为私有（或受保护的—），可以实现单例模式。
	★	不同编译单元中的非局部静态对象的初始化顺序是未定义的。
	★	单例销毁顺序问题的几种解决方案：
		1.	单例销毁后必要时将其恢复。
		2.	延长某个单例的寿命，使其比其他单例生存期更久。
		3.	不销毁单例。
	★	依赖注入使采用了单例模式的代码更易于测试。
	★	单一状态模式允许创建类的多个实例，这些实例使用相同的静态数据。
	★	单一状态模式的优点：
		1.	允许创建多个实例。
		2.	由于不需要特殊的GetInstance()方法，所以无需用户特别配置。
		3.	使用静态变量可以呈现出定义明确的创建和销毁语义。
	★	如果不需要惰性初始化全局数据，或者想让类的唯一性透明化，可以考虑使用单一状态代替单件。
	★	单例模式有一些替代方案，包括依赖注入、单一状态模式以及使用会话上下文。
	★	工厂模式是一个创建型的设计模式。它允许创建对象时不指定要创建的对象的具体类型。
	★	工厂方法是构造函数的一般化。
	★	构造函数的限制：
		1.	没有返回值。
		2.	命名限制。
		3.	静态绑定创建。
		4.	不允许虚构造函数。
	★	使用工厂方法提供更强大的类构造语义并隐藏子类的细节。
	★	创建包装器API的潜在副作用是影响性能，这主要因为额外增加的一级间接寻址以及存储包装层次状态带来的开销。
	★	结构化设计模式可以处理接口包装任务。
	★	代理设计模式为另一个类提供了一对一的转发接口。也就是说，代理类和原始类有相同的接口。
	★	代理的缺点是需要再次暴露原始对象的函数。
	★	代理的另一个方案是增加代理和原始API共享的虚接口，这样做是为了更好地保持这两个API的同步，这么做的前提是你能够修改原始API。
	★	代理提供了一个接口，此接口将函数调用转发到具有同样形式的另一个接口。
	★	代理模式的案例：
		1.	实现原始对象的惰性实例。
		2.	实现对原始对象的访问控制。
		3.	支持调试或“演习”模式。
		4.	保证原始类线程安全。
		5.	支持资源共享。
		6.	应对原始类将来被修改的情况。
	★	适配器设计模式将一个类的接口转换成一个兼容的但不相同的接口。
	★	适配器设计模式与代理模式相似之处是，适配器设计模式也是一个单一组件包装器，但适配器类和原始类的接口可以不相同。
	★	适配器将一个接口转换为一个兼容的但不相同的接口。
	★	适配器模式的优点：
		1.	强制API始终保持一致性。
		2.	包装API的依赖库。
		3.	转换数据类型。
		4.	为API暴露一个不同的调用约定。
	★	外观模式能够为一组类提供简化的接口。
	★	外观模式和适配器模式的区别是，外观模式简化了类的结构，而适配器模式仍然保持相同的类结构。
	★	外观模式为一组类提供了简化的接口。在封装外观模式中，底层类不再可访问。
	★	外观模式的用途：
		1.	隐藏遗留代码。
		2.	创建便捷API。
		3.	支持简化功能或者替代功能的API。
	★	观察者支持组件解耦且避免了循环依赖。
	★	MVC支持应用程序的功能模块化，并具有以下优点：
		1.	模型和视图组件的隔离，就可以实现多个用户界面，并且使这些界面能够重用公共的业务逻辑核心。
		2.	避免了因多份UI实现而构建多份重复的底层模型代码的问题。
		3.	模型和视图代码的解耦简化了为核心业务逻辑代码编写单元测试的工作。
		4.	组件的模块化允许核心逻辑开发者和GUI开发者并行工作，且互不影响。
	★	MVC架构模式促使核心业务逻辑与用户界面分离。它还隔离了控制器逻辑，控制器逻辑会引起模型的改变并更新视图。
	★	控制器和视图都依赖于模型，但是模型代码既不依赖控制器代码，也不依赖视图代码。
	★	观察者模式是“发布/订阅”范式的一个具体实例。这些技术定义了对象之间一对多的依赖，
		使得发布者对象能够将它的状态变化通知给所有的订阅对象，而又不直接依赖订阅对象。
第4章 设计
	★	最初的良好设计和此后的高标准维护同等重要。
	★	好的API设计是一个过程，而不仅仅是第一步。
	★	第一次交付代码就像背负债务。少量技术债可以加速开发，只要你立即通过重写偿还了它们。
		如果有技术债没有偿还，危险就会出现 。花在不稳定的代码上的每分钟都会算作技术债的利息。
		整个工程都可能因为不稳定实现带来的债务压力而停滞不前。
	★	警告信号：
		1.	脆弱性。
		2.	僵化性。
		3.	顽固性。
		4.	不可转移性。
	★	对于下一代项目，开发有以下两个方向：
		1.	演进式。设计一个包含所有新需求的系统，然后迭代重构现有系统直到满足需求。
		2.	革命式。丢掉旧代码，然后从零开始设计，实现一个全新的系统。
	★	记住要不断偿还技术债。
	★	软件产业中的需求可以分为不同的类型：
		1.	业务需求。
		2.	功能性需求。
		3.	非功能性需求。
	★	功能性需求规定了API如何表现。
	★	非功能性需求：
		1.	性能。
		2.	平台兼容性。
		3.	安全性。
		4.	可伸缩性。
		5.	灵活性。
		6.	易用性。
		7.	并发性。
		8.	代价。
	★	好的功能性需求应该是简单、易读、清晰、可验证的，而且没有开发术语。
	★	用例基于API与用户或其他软件的交互来描述API的行为。
	★	用例从用户的角度描述API的需求。
	★	实现创建用例过程的好方法是：
		1.	识别系统所有的参与者以及它们扮演的角色。
		2.	识别每个角色需要完成的所有目标。
		3.	为每个目标创建用例。
	★	用例可以是面向目标的简短描述信息的简要列表，也可以是更为正式的模板定义的结构化说明。
	★	编写高质量用例：
		1.	使用领域术语。
		2.	不要过度详细地说明用例。
		3.	用例并不定义所有的需求。
		4.	用例并不定义设计。
		5.	不要在用例中详细说明设计。
		6.	用例能够指导测试。
		7.	对迭代的预期。
		8.	不要坚持完全覆盖。
	★	用户故事是敏捷开发过程中一种从用户那获得最小需求的方法。
	★	用户故事的特性：
		1.	独立性。
		2.	可协商性。
		3.	有价值。
		4.	可评估。
		5.	短小。
		6.	可测试。
	★	对问题领域进行合理抽象，然后设计相应的对象与类的层次结构来表达该抽象。
	★	复杂系统都有两种层次化视角：
		1.	对象层次结构。
		2.	类层次结构。
	★	软件构建的设计阶段由两个主要活动组成：
		1.	架构设计。
		2.	详细设计。
	★	API设计包括开发顶层架构和详细的类层次结构。
	★	创建API的架构的过程可以分解为4个基本步骤：
		1.	分析影响架构的功能性需求。
		2.	识别架构的约束并加以说明。
		3.	创建系统中的主要对象，并确认它们之间的关系。
		4.	架构的交流与文档。
	★	架构的约束：
		1.	组织因素。
		2.	环境因素。
		3.	运行因素。
	★	架构设计被众多独特的组织、环境和运行等因素约束。
	★	总是为变化而设计，变化是不可避免的。
	★	创建关键对象：
		1.	自然语言。
		2.	属性。
		3.	行为。
		4.	原型。
		5.	领域。
	★	API的关键对象并不容易识别，请尝试从不同的角度看待问题，并不断迭代和完善你的模型。
	★	架构模式的分类：
		1.	结构化模式。
		2.	交互式系统。
		3.	分布式系统。
		4.	自适应系统。
	★	一个API应该是由逻辑关联组件组成的无环层次结构。
	★	要避免API各个组件间的循环依赖。
	★	在API的附属文档中要描述其高层架构并阐述其原理。
	★	你应该深入地思考如何将设计以最自然、最直观的方式传达给用户。
	★	要集中精力设计定义了API80%功能的20%的类。
	★	创建一个新类涉及定义一个新类型。
	★	使用继承：
		1.	设计支持还是禁止继承。
		2.	仅在适当的地方使用继承。
		3.	避免深度继承树。
		4.	使用纯虚成员函数强制子类提供实现。
		5.	不要为现有接口增加新的纯虚函数。
		6.	不要过度设计。
	★	避免深度继承层次结构。
	★	除非专门为了使用抽象接口或mixin类，否则应该避免使用多重继承。
	★	Liskov替换原则指出，在不修改任何行为的情况下用派生类替换基类，这应该总是可行的。
	★	组合优先于继承。
	★	开放——封闭原则：类的目标应该是为扩展而开放，为修改而关闭的。
	★	维护一个稳定的接口能够带来一定的灵活性，即在修改接口的底层实现的同时，
		又不过多地影响客户的代码。
	★	API应该为不兼容的接口变化而关闭，为功能扩展而开放。
	★	迪米特法则：函数可以做的事情。
		1.	调用同一个类的其他函数。
		2.	在同一个类的数据成员卢调用函数。
		3.	在它接受的任何参数上调用函数。
		4.	在它创建的任何局部对象上调用函数。
		5.	在全局对象上调用函数。
	★	迪米特法则指出，你应该只调用自己类或直接相关对象的函数。
	★	类命名的指导原则：
		1.	简单的类名应该是动人的，描述性强的且是自解释的。
		2.	好名字能推动设计。
		3.	为了传达更为精确具体的意义，使用复合名字是必要的。
		4.	接口往往使用对象模型中的形容词表示。
		5.	避免含义模糊的缩写词。
		6.	为顶层符号包含某种形式的命名空间，以避免API中的名字与客户使用其他API冲突。
	★	函数命名指导原则：
		1.	用于设置或返回值的函数，函数名应该使用标准前缀来完整地描述这个量值。
		2.	需要回答“是否”问题的函数应该使用适当的前缀指示该行为并返回。
		3.	用于执行某些动作的函数应该用一个证据强烈的动词命名。
		4.	使用正面的概念命名函数，而不要以否定形式命名。
		5.	函数名应该能描述例程所做的所有事情。
		6.	避免使用缩写。
		7.	函数不应该以下划线开头。
		8.	形成自然对仗的函数应该使用正确的互补的术语。
	★	避免过长的参数列表。
	★	使用函数来设置参数值也带来以下好处：
		1.	值可以以任何顺序指定，因为函数调用是与顺序无关。
		2.	每个值的效果图更为明显，因为你必须使用一个命名函数来设置值。
		3.	支持可选的参数，只要不调用相应的函数即可。
		4.	对于所有的设定，构造函数可以定义合理的默认值。
		5.	添加新参数是向后兼容的，因为只是添加了新函数，现有函数的签名不需要修改。
	★	使用一致的、充分文档化的错误处理机制。
	★	异常的使用是个要么全有要么全无的命题。
	★	从std::exception派生自己的异常。
	★	在出现故障时，让API快速干净地退出，并给出完整精确的诊断细节。
第5章 风格
	★	API风格：
		1.	纯C API。
		2.	面向对象的C++ API。
		3.	基于模板的API。
		4.	数据驱动型的API。
	★	对于纯C API而言，所有公开的函数和数据结构应该使用一个公共的前缀。
	★	为实现更严格的类型检查，并确保C++程序可以使用你的API，请尝试用C++编译器来编译C API。
	★	使用C编写API的原因：
		1.	必须与现有的完全用C编写的项目集成。
		2.	出于二进制兼容性考虑。
	★	在C API的头文件中使用extern "C"限制，以便于C++程序能正确地编译和链接API。
	★	识别给定问题空间中的关键对象，并确定它们之间是如何彼此关联的。
	★	面向对象API允许使用对象而非动作来建模软件，同时也带来了继承和封装等优点。
	★	如果相对于运行时开销而言，代码体积是需要优先考虑的因素，那么应该选择面向对象方案，而非模板。
		或者相反，如果运行时性能更重要，那就应该选择模板。
	★	数据驱动型API的优点：
		1.	程序的业务逻辑能够抽象到可以由人来编辑的数据文件之中。
			利用这种方法，可以在不重新编译可执行文件的情况下改变程序的行为。
		2.	对于API将来可能发生变化，它的容错性更强。
		3.	它们可以更容易地支持数据驱动型测试技术。
	★	数据驱动型API可以很好地映射到Web服务和其他客户端/服务器形式的API，它们也支持数据驱动型测试技术。
	★	数据驱动API的缺点：
		1.	API的简洁性和稳定性也伴随着运行时开销。
		2.	物理上的头文件无法反映逻辑接口。
		3.	数据驱动API无法从接口的编译时检查中获益。
第6章 C++用法
	★	应当始终使用一致的前缀或C++的namespace关键字为API符号提供命名空间。
	★	如果类分配了资源，则应该遵循三大件规则，同时定义析构函数、复制构造函数和赋值操作符。
	★	考虑在只带有一个参数的构造函数的声明前使用explicit关键字。
	★	保证API的const正确性。
	★	尽可能早地将函数和参数声明为const。过后修正API中const正确性会即耗时又麻烦。
	★	逻辑上遵循const函数不能修改任何状态这一惯常约定。
	★	首选传值方式而不是const引用方式返回函数的结果。
	★	如果只需要一些确定的特化集合，那么尽量选择显式模板实例化。这样做可以隐藏私有细节并降低构建时间。
	★	建议在定义操作符时尽量选择自由函数，而非类成员方法：
		1.	操作符对称性。
		2.	降低耦合度。
	★	除非操作符必须访问私有成员或受保护成员，或它是=、[]、->、()、(T)、new、delete其中之一，
		否则应该尽量将其声明为自由函数。
	★	给类添加转换操作符，从而利用自动类型强制转换。
	★	尽量在可行的地方为输入参数使用const引用，而非指针。对于输出参数，考虑使用指针而不是非const引用，
		以便显式地向客户表明它们可能被修改。
	★	当默认值会暴露实现中的常量时，尽量使用函数重载，而不是默认参数。
	★	尽量避免定义涉及构造临时对象的默认参数，因为这些参数会以传值的方法传递给方法，开销很大。
	★	避免采用#define定义常量：
		1.	没有指定类型。
		2.	没有指定作用域。
		3.	没有访问控制。
		4.	没有符号。
	★	使用静态const数据成员而非#define表示类常量。
	★	避免使用友元。它往往预示着糟糕的设计，这就等于赋予用户访问API所有受保护成员和私有成员的权限。
	★	使用内部链接以便隐藏.cpp文件内部的、具有文件作用域的自由函数和变量。
		也就是说，使用static关键字或匿名命名空间。
	★	应该显式导出公有API的符号，以便维持对动态库中类、函数和变量访问性的直接控制。
		对于GNU C++，可以使用__fvisibility__hidden选项。
	★	为API指定编码风格标准，这有助于保证一致性、明确流程，并总结常见的工程陷阱。
第7章 性能
	★	实现也许不必是高性能的，但接口应该尽可能优化，以确保其不严重损害性能。
	★	力求做到不因性能原因而扭曲API的设计初衷。
	★	不要以扭曲API的设计为代码换取高性能。
	★	API性能的主题：
		1.	编译时速度。
		2.	运行时速度。
		3.	运行时内存开销。
		4.	库的大小。
		5.	启动时间。
	★	绝不应该相信你的“哪些部分会比较慢”直觉，而是应该在实际环境中测量API的真实性能概况，然后把优化精力集中在影响最大的部分。
	★	为优化API，应使用工具收集代码在真实运行实例中的性能数据，然后把优化精力集中在实际的瓶颈上。不要猜测性能瓶颈的位置。
	★	应该通过const引用而非传值方式传递不会改变的对象。这样可以避免创建和销毁对象的临时副本，及副本中所有的成员和继承对象的内存与性能开销。
	★	缩短构建时间的一种常见技巧是尝试减少头文件中#include语句的数量。
	★	避免“无所不包型”头文件。
	★	前置声明可以在下列几种情况下使用：
		1.	不需要知道类的大小。
		2.	没有引用类的任何成员方法。
		3.  没有引用类的任何成员变量。
	★	如果以传值方式给方法传递变量，或者以传值方式返回值，那么前置声明即可满足需求。
	★	一般来说，只有在自己的类中将某个类的对象作为数据成员使用时，或者需要继承某个类时，才应该包含那个类的头文件。
	★	只前置声明你自己的代码才是安全的做法。
	★	仅仅前置声明你自己的API中的符号。
	★	头文件应该#include或者前置声明其所有依赖项。
	★	考虑在头文件中加入冗余的#include警戒语句，为客户优化编译时间。
	★	应使用extern声明全局作用域的常量，或者在类中以静态const方式声明常量，然后在.cpp文件中定义常量值。
		这样就减少了包含这些头文件的模块的目标文件大小。更可取的方法是将这些常量隐藏在函数调用背后。
	★	使用构造函数初始化列表，从而为每个数据成员减少一次调用构造函数的开销。
		这些应在.cpp文件中声明，以便隐藏实现细节。
	★	对象越小，就越适合缓存。
	★	缩小对象大小的方法：
		1.	根据类型聚集成员变量。
		2.	使用位域。
		3.	使用联合。
		4.	除非必要，不要添加虚方法。
		5.	使用大小明确的类型。
	★	根据成员变量类型对它们加以聚集，从而优化对象大小。
	★	考虑使用位域进一步压缩对象，但是要注意它对性能的影响。
	★	使用大小明确的类型指定变量所需的最大位数。
	★	内联的下列隐含影响：
		1.	暴露实现细节。
		2.	在客户应用程序中嵌入代码。
		3.	代码膨胀。
		4.	调试复杂化。
	★	避免在公有头文件中使用内联代码，除非能证明代码会导致性能问题，并确认内联可以解决该问题。
	★	使用写时复制语义，为对象的多份副本减少内存消耗。
	★	采用迭代器模型遍历简单的线性数据结构。对于链表或树型数据结构，如果迭代性能很重要，那么应该考虑数组引用。
	★	时效性分析：
		1.	内嵌测量。
		2.	二进制测量。
		3.	采样。
		4.	监控计数器。
第8章 版本控制
	★	API总会需要修复错误、集成新特性、优化工作流程、改进架构、支持其他平台等后续更新。
	★	API的每次发布都应该附带一个唯一的标识符，以便其最新版本能够与之前版本有所区别。
		标准的做法是使用版本号。
	★	在库名中包含API的主版本号是良好的编程实践，尤其是在做了一些不能向后兼容的修改时。
	★	应该提供API的版本信息。
	★	只在必要时再分支，心是延迟创建分支的时机。心是使用分支代码路线而非冻结代码路线。尽早且频繁地合并分支。
	★	版本N的功能应该是版本N-1功能的超集。
	★	工作在不同并行分支上团队互不引入不兼容的特性：
		1.	制定开发分支的目标。
		2.	经常合并到主干中。
		3.	审查过程。
	★	在维护一种产品的不同分发版时，在所有需要在不同分发版间共享的文件中，除了要保存创建该文件的分发版的版本号，还需要保存分发版的名字。
	★	在创建相同API的Basic和Advanced分发版时，在所有生成文件的版本号里带上“Basic”或“Advanced”字符串。
		不要试图仅使用版本号识别文件是Basic还是Advanced API生成的。
	★	API开发有4个常见阶段：
		1.	发布前。
		2.	维护。
		3.	完成。
		4.	弃用。
	★	API发布后，可以改进但不应改变。
	★	向后兼容性意味着使用第N版本API的客户代码能够不加修改地升级到N+1版本。
	★	功能兼容性意味着第N+1版本的行为和第N版本一致。
	★	源代码兼容性意味着用户使用第N版本API编写的代码可以使用第N+1版本进行编译，而不用修改源代码。
	★	二进制兼容性意味着使用第N版本API编写的应用程序可以仅通过替换或重新链接API的新动态链接库，就升级到第N+1版本。
	★	二进制兼容性的进阶技巧：
		1.	不要给已有方法增加参数，可以定义该方法新的重载版本。
		2.	Pimpl模式可以用来帮助保持接口的二进制兼容性，因为它把那些将来很可能发生变化的实现细节移进了.cpp文件，使之不会影响公有的.h文件。
		3.	采用纯C风格的API可以更容易地获得二进制兼容性。
		4.	如果确实需要做二进制不兼容的修改，那么可以考虑为新库换个不同的名字，这样就不会破坏已有的应用程序。
	★	向前兼容性意味着使用第N版本API的用户代码可以不加修改地降级使用第N-1版本。
	★	在API初始版本发布后，不要为抽象基类添加新的纯虚成员函数。
	★	API审查的目的：
		1.	维护向后兼容性。
		2.	维护设计一致性。
		3.	对修改加以控制。
		4.	支持未来改进。
		5.	重新审视解决方案。
	★	在发布API新版本前，引入API审查过程，以便检查所有修改。
第9章 文档
	★	API定义：一个或多个头文件加上支持文档组成的抽象程序接口。
	★	复用做起来远不如说起来那么简单，它同时需要良好的设计和优秀的文档。
		即使我们发现了难得一见的良好设计，如果没有优秀的文档，这个组件就很难得以复用。
	★	良好的文档描述了如何使用API，并会解释API对不同输入所产生的行为。
	★	在实现每个组件时编写API文档。在API完成后对文档进行修订。
	★	软件组件为它实现的服务提供和种契约或责任。
		1.	前置条件。
		2.	后置条件。
		3.	类的不变式。
	★	契约编程意味着为函数的前置条件、后置条件，以及类的不变式编写文档。
	★	派生类的前置条件相比基类可以更宽松，但不能更严格。派生类应该能处理基类处理的所有情况，亦可处理仅需要更少前置条件的情况。
	★	派生类应该从基类继承所有后置条件。派生类的函数在满足基类所有后置条件的同时，还可以满足它自己额外定义的后置条件。
	★	文档应该：
		1.	完整。
		2.	一致。
		3.	易于访问。
		4.	没有重复。
	★	为API的每个公有元素编写文档。
	★	使用自动生成文档的工具，从头文件注释中提取API文档。
	★	概述文档：
		1.	API高层次的概念视图。
		2.	关键概念、特性和术语。
		3.	如何下载、安装和配置软件。
		4.	如何提供反馈信息、报告错误。
		5.	对API生命周期各阶段的陈述。
	★	示例和教程：
		1.	简单的示例。
		2.	可运行的演示。
		3.	教程和演练。
		4.	用户贡献。
		5.	常见问题。
	★	应当明确指定API的授权条款。
第10章 测试
	★	为了确保不破坏用户程序，编写自动化测试是所能采取的措施中最重要的一项。
	★	采用测试的理由：
		1.	增强信心。
		2.	确保向后兼容性。
		3.	节约成本。
		4.	编写用例。
		5.	合规保证。
	★	自动化测试可以帮助你确定是否正在构建正确的东西，以及是否构建正确。
	★	软件测试活动分为以下几类：
		1.	白盒测试。
		2.	黑盒测试。
		3.	灰盒测试。
	★	API是用来构建完整系统的组件。
	★	非功能测试：
		1.	性能测试。
		2.	负载测试。
		3.	可扩展性测试。
		4.	浸泡测试。
		5.	安全性测试。
		6.	并发测试。
	★	API测试应该组合使用单元测试和集成测试。也可以适当运用非功能性技术测试，比如性能测试、并发测试和安全性测试。
	★	单元测试用于验证一个最小单元的源代码。
	★	单元测试是一种白盒测试技术，用于独立验证函数和类的行为。
	★	测试固件设置：单元测试的经典做法是在每个单元测试运行前，初始化一个一致的环境或测试固件。
	★	桩/模拟对象：通过创建桩对象或模拟对象代表单元之外的依赖项，将待测试的代码同系统其他部分隔离开。
	★	如果代码依赖于不可靠的资源，比如数据库、文件系统或网络，那么可以使用桩对象或模拟对象创建更健壮的单元测试。
	★	相比单元测试，集成测试关注几个组件一起协作时的交互过程。
	★	集成测试是一种墨盒测试技术，用于验证几个组件的交互过程。
	★	对关键用例进行性能测试，有助于避免无意引入的速度问题或内存损失。
	★	如果API的性能很重要，考虑为关键用例编写性能测试，以避免引入性能损失。
	★	性能测试是依赖于特定机器的。
	★	良好测试的特征：
		1.	快速。
		2.	稳定。
		3.	可移植。
		4.	高编码标准。
		5.	错误可重现。
	★	测试驱动开发指首先编写单元测试，然后编写代码使测试通过。这可以让你专注于API的主要用途。
	★	桩对象和模拟对象都返回封装好的响应，但是模拟对象还会验证调用行为。
	★	使用SelfTest()成员函数测试类的私有成员。
	★	使用断言记录和验证那些绝不应该发生的程序设计错误。
	★	通过对断言的系统性使用，强制保证接口契约。
	★	对接口而不是实现执行契约检查。
	★	自动化测试工具：
		1.	自动化测试框架。
		2.	代码覆盖率工具。
		3.	缺陷跟踪系统。
		4.	持续构建系统。
	★	缺陷跟踪系统是一种能够在数据库中持续跟踪软件项目缺陷的应用程序。
第11章 脚本化
	★	C++代码与脚本语言集成的策略：
		1.	扩充语言。
		2.	嵌入在应用程序中。
	★	脚本化的优点：
		1.	跨平台。
		2.	更快速地开发。
		3.	需要编写的代码更少。
		4.	基于脚本的应用程序。
		5.	支持专家级用户。
		6.	可扩展性。
		7.	脚本化有利于测试。
		8.	更具表现力。
	★	本质上，任何脚本绑定技术都是建立在适配器设计模式之上。
	★	务必确认编译脚本绑定时使用的Python版本与构建Boost Python库时使用的是一致的。
第12章 可扩展性
	★	扩展性是指对于客户的特定需求，在无需改进API的情况下，客户自行修改接口的行为。
	★	API中采用插件模型的优点：
		1.	更为通用。
		2.	催生社区。
		3.	更新量小。
		4.	面向未来。
		5.	隔离风险。
	★	以C++实现插件：
		1.	使用抽象基类。
		2.	自由函数使用C链接。
		3.	避免使用STL和异常。
		4.	不要混用内存分配器。
	★	对用户而言，将类的析构函数声明为虚拟的就是一个信号，说明该类就是为了继承而设计的。
	★	绝对不要继承STL容器类。
	★	对于基类中的枚举，请在最后添加一个枚举项，比如<枚举名>_END。
	★	访问者模式的核心目标是：允许客户遍历一个数据结构中的所有对象，并在每个对象上执行给定操作。
	★	奇特的递归模板模式：继承自基类的模板类，将该类自身作为模板参数。
附录A 库
	★	为了给客户更大的灵活性，在发布时，你应该首选动态库形式。如果库相当小，且非常稳定，你也可以提供一个静态库版本。