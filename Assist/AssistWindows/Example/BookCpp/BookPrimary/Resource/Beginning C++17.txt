C++17 入门经典（Beginning C++17）
（第5版）

★☆
作者：Ivor Horton、Peter Van Weert
其他书籍：Ivor Horton《Visual C++ 2013入门经典》、 《C++ 标准模板库编程实战》。

知识点 
1.	C++17基础知识。 
2.	C++17基础知识练习。
3.	移动语义基础知识（第17章）。

前言
	★ 现代C++强调使用更新、更具表达力、更安全的语言特性，并结合经过实践验证的最佳实践和编码指导原则。
	如何使用本书
第1章 基本概念  
	1.1 现代C++  
	1.2 标准库  
	1.3 C++程序概念  
		1.3.1 源文件和头文件  
		1.3.2 注释和空白  
		1.3.3 预处理指令和标准库头文件  
		1.3.4 函数  
		1.3.5 语句  
		1.3.6 数据的输入输出  
		1.3.7 return语句  
		1.3.8 名称空间
		1.3.9 名称和关键字  
	1.4 类和对象
	1.5 模板
	1.6 代码的表示样式和编程风格
	1.7 创建可执行文件
	1.8 过程化编程和面向对象编程
	1.9 表示数字
		1.9.1 二进制数
		1.9.2 十六进制数
		1.9.3 负的二进制数
		1.9.4 八进制数
		1.9.5 Big-Endian和Little-Endian系统
		1.9.6 浮点数
	1.10 表示字符
		1.10.1 ASCII 码
		1.10.2 UCS和Unicode
	1.11 C++源字符
	1.12 本章小结
	1.13 练习
第2章 基本数据类型
	2.1 变量、数据和数据类型
		2.1.1 定义整型变量
		2.1.2 零初始化
		2.1.3 定义有固定值的变量
	2.2 整型字面量
		2.2.1 十进制整型字面量
		2.2.2 十六进制的整型字面量
		2.2.3 八进制的整型字面量
		2.2.4 二进制的整型字面量
	2.3 整数的计算
	2.4 赋值运算
	2.5 sizeof运算符
	2.6 整数的递增和递减
	2.7 定义浮点变量
	2.8 浮点字面量
	2.9 浮点数的计算
		2.9.1 缺点
		2.9.2 无效的浮点结果
		2.9.3 数学函数
	2.10 输出流的格式化
	2.11 混合的表达式和类型转换
	2.12 显式类型转换
	2.13 确定数值的上下限
	2.14 使用字符变量
	2.15 auto关键字
	2.16 本章小结
	2.17 练习
第3章 处理基本数据类型
	3.1 运算符的优先级和相关性
	3.2 位运算符
		3.2.1 移位运算符
		3.2.2 位模式下的逻辑运算
	3.3 枚举数据类型
	3.4 数据类型的别名
	3.5 变量的生存期
	3.6 全局变量
	3.7 本章小结
	3.8 练习
第4章 决策
	4.1 比较数据值
		4.1.1 应用比较运算符
		4.1.2 比较浮点数值
	4.2 if语句
		4.2.1 嵌套的if语句
		4.2.2 字符分类和转换
	4.3 if-else语句
		4.3.1 嵌套的if-else语句
		4.3.2 理解嵌套的if语句
	4.4 逻辑运算符
		4.4.1 逻辑与运算符
		4.4.2 逻辑或运算符
		4.4.3 逻辑非运算符
		4.4.4 组合逻辑运算符
		4.4.5 对整数操作数应用逻辑运算符
		4.4.6 对比逻辑运算符与位运算符
	4.5 条件运算符
	4.6 switch语句
	4.7 语句块和变量作用域
	4.8 本章小结
	4.9 练习
第5章 数组和循环
	5.1 数组
	5.2 理解循环
	5.3 for循环
	5.4 避免幻数
	5.5 用初始化列表定义数组的大小
	5.6 确定数组的大小
	5.7 用浮点数控制for循环
	5.8 使用更复杂的for循环控制表达式
	5.9 基于范围的for循环
	5.10 while循环
	5.11 do-while循环
	5.12 嵌套的循环
	5.13 跳过循环迭代
	5.14 循环的中断
	5.15 使用无符号整数控制for循环
	5.16 字符数组
	5.17 多维数组
		5.17.1 初始化多维数组
		5.17.2 多维字符数组
	5.18 在运行期间给数组分配内存空间
	5.19 数组的替代品
		5.19.1 使用array容器
		5.19.2 使用std::vector容器
	5.20 本章小结
	5.21 练习
第6章 指针和引用
	6.1 什么是指针
	6.2 地址运算符
	6.3 间接运算符
	6.4 为什么使用指针
	6.5 char类型的指针
	6.6 常量指针和指向常量的指针
	6.7 指针和数组
		6.7.1 指针的算术运算
		6.7.2 使用数组名的指针表示法
	6.8 动态内存分配
		6.8.1 栈和自由存储区
		6.8.2 运算符new和delete
		6.8.3 数组的动态内存分配
	6.9 通过指针选择成员
	6.10 动态内存分配的危险
		6.10.1 悬挂指针和多次释放
		6.10.2 分配与释放的不匹配
		6.10.3 内存泄漏
		6.10.4 自由存储区的碎片
	6.11 内存分配的黄金准则
	6.12 原始指针和智能指针
		6.12.1 使用unique_ptr指针
		6.12.2 使用shared_ptr指针
	6.13 理解引用
		6.13.1 定义引用
		6.13.2 在基于范围的for循环中使用引用变量
	6.14 本章小结
	6.15 练习
第7章 操作字符串
	7.1 更强大的string类
		7.1.1 定义string对象
		7.1.2 string对象的操作
		7.1.3 访问字符串中的字符
		7.1.4 访问子字符串
		7.1.5 比较字符串
		7.1.6 搜索字符串
		7.1.7 修改字符串
		7.1.8 对比std::string与std::vector
	7.2 将字符串转换为数字
	7.3 字符串流
	7.4 国际字符串
		7.4.1 存储wchar_t字符的字符串
		7.4.2 包含Unicode字符串的对象
	7.5 原始字符串字面量
	7.6 本章小结
	7.7 练习
第8章 定义函数
	8.1 程序的分解
		8.1.1 类中的函数
		8.1.2 函数的特征
	8.2 定义函数
		8.2.1 函数体
		8.2.2 返回值
		8.2.3 函数声明
	8.3 给函数传送实参
		8.3.1 按值传送
		8.3.2 按引用传送
		8.3.3 字符串视图：新的const string引用
	8.4 默认实参值
	8.5 main()函数的实参
	8.6 从函数中返回值
		8.6.1 返回指针
		8.6.2 返回引用
		8.6.3 对比返回值与输出参数
		8.6.4 返回类型推断
		8.6.5 使用可选值
	8.7 静态变量
	8.8 内联函数
	8.9 函数重载
		8.9.1 重载和指针参数
		8.9.2 重载和引用参数
		8.9.3 重载和const参数
		8.9.4 重载和默认实参值
	8.10 递归
		8.10.1 基本示例
		8.10.2 递归算法
	8.11 本章小结
	8.12 练习
第9章 函数模板
	9.1 函数模板
	9.2 创建函数模板的实例
	9.3 模板类型参数
	9.4 显式指定模板实参
	9.5 函数模板的特例
	9.6 函数模板和重载
	9.7 带有多个参数的函数模板
	9.8 模板的返回类型推断
		9.8.1 decltype和拖尾返回类型
		9.8.2 对比decltype(auto)、拖尾decltype()与auto
	9.9 模板参数的默认值
	9.10 非类型的模板参数
	9.11 本章小结
	9.12 练习
第10章 程序文件和预处理指令
	10.1 理解转换单元
		10.1.1 单一定义规则
		10.1.2 程序文件和链接
		10.1.3 确定名称的链接属性
		10.1.4 外部函数
		10.1.5 外部变量
		10.1.6 内部名称
	10.2 预处理源代码
	10.3 定义预处理宏
		10.3.1 定义类似于函数的宏
		10.3.2 取消宏的定义
	10.4 包含头文件
		10.4.1 防止重复头文件的内容
		10.4.2 第一个头文件
	10.5 名称空间
		10.5.1 全局名称空间
		10.5.2 定义名称空间
		10.5.3 应用using声明
		10.5.4 函数和名称空间
		10.5.5 未命名的名称空间
		10.5.6 嵌套的名称空间
		10.5.7 名称空间的别名
	10.6 逻辑预处理指令
		10.6.1 逻辑#if指令
		10.6.2 测试指定标识符的值
		10.6.3 多个代码选择
		10.6.4 标准的预处理宏
		10.6.5 检查头文件是否可用
	10.7 调试方法
		10.7.1 集成调试器
		10.7.2 调试中的预处理指令
		10.7.3 使用assert()宏
	10.8 静态断言
	10.9 本章小结
	10.10 练习
第11章 定义自己的数据类型
	11.1 类和面向对象编程
		11.1.1 封装
		11.1.2 继承
		11.1.3 多态性
	11.2 术语
	11.3 定义类
	11.4 构造函数
		11.4.1 默认构造函数
		11.4.2 定义类的构造函数
		11.4.3 使用default关键字
		11.4.4 在类的外部定义函数和构造函数
		11.4.5 默认构造函数的参数值
		11.4.6 使用成员初始化列表
		11.4.7 使用explicit关键字
		11.4.8 委托构造函数
		11.4.9 副本构造函数
	11.5 访问私有类成员
	11.6 this指针
	11.7 const对象和const成员函数
		11.7.1 const成员函数
		11.7.2 const正确性
		11.7.3 重载const
		11.7.4 常量的强制转换
		11.7.5 使用mutable关键字
	11.8 友元
		11.8.1 类的友元函数
		11.8.2 友元类
	11.9 类的对象数组
	11.10 类对象的大小
	11.11 类的静态成员
		11.11.1 静态成员变量
		11.11.2 访问静态成员变量
		11.11.3 静态常量
		11.11.4 类类型的静态成员变量
		11.11.5 静态成员函数
	11.12 析构函数
	11.13 使用指针作为类成员
	11.14 嵌套类
	11.15 本章小结
	11.16 练习
第12章 运算符重载
	12.1 为类实现运算符
		12.1.1 运算符重载
		12.1.2 实现重载运算符
		12.1.3 非成员运算符函数
		12.1.4 提供对运算符的全部支持
		12.1.5 在类中实现所有的比较运算符
	12.2 可以重载的运算符
	12.3 运算符函数习语
	12.4 为输出流重载<<运算符
	12.5 重载算术运算符
	12.6 成员与非成员函数
	12.7 重载一元运算符
	12.8 重载递增和递减运算符
	12.9 重载下标运算符
	12.10 函数对象
	12.11 重载类型转换
	12.12 重载赋值运算符
		12.12.1 实现复制赋值运算符
		12.12.2 复制赋值运算符与副本构造函数
		12.12.3 赋值不同类型
	12.13 本章小结
	12.14 练习
第13章 继承
	13.1 类和面向对象编程
	13.2 类的继承
		13.2.1 继承和聚合
		13.2.2 派生类
	13.3 把类的成员声明为protected
	13.4 派生类成员的访问级别
		13.4.1 在类层次结构中使用访问修饰符
		13.4.2 在类层次结构中选择访问修饰符
		13.4.3 改变继承成员的访问修饰符
	13.5 派生类中的构造函数
		13.5.1 派生类中的副本构造函数
		13.5.2 派生类中的默认构造函数
		13.5.3 继承构造函数
	13.6 继承中的析构函数
	13.7 重复的成员变量名
	13.8 重复的成员函数名
	13.9 多重继承
		13.9.1 多个基类
		13.9.2 继承成员的模糊性
		13.9.3 重复继承
		13.9.4 虚基类
	13.10 在相关的类类型之间转换
	13.11 本章小结
	13.12 练习
第14章 多态性
	14.1 理解多态性
		14.1.1 使用基类指针
		14.1.2 调用继承的函数
		14.1.3 虚函数
		14.1.4 虚函数中的默认实参值
		14.1.5 通过引用调用虚函数
		14.1.6 多态集合
		14.1.7 通过指针释放对象
		14.1.8 在指针和类对象之间转换
		14.1.9 动态强制转换
		14.1.10 调用虚函数的基类版本
		14.1.11 在构造函数或析构函数中调用虚函数
	14.2 多态性引发的成本
	14.3 确定动态类型
	14.4 纯虚函数
		14.4.1 抽象类
		14.4.2 用作接口的抽象类
	14.5 本章小结
	14.6 练习
第15章 运行时错误和异常
	15.1 处理错误
	15.2 理解异常
		15.2.1 抛出异常
		15.2.2 异常处理过程
		15.2.3 导致抛出异常的代码
		15.2.4 嵌套的try块
	15.3 用类对象作为异常
		15.3.1 匹配catch处理程序和异常
		15.3.2 用基类处理程序捕获派生类异常
	15.4 重新抛出异常
	15.5 未处理的异常
	15.6 捕获所有的异常
	15.7 不抛出异常的函数
		15.7.1 noexcept限定符
		15.7.2 异常和析构函数
	15.8 异常和资源泄漏
		15.8.1 资源获取即初始化
		15.8.2 用于动态内存的标准RAII类
	15.9 标准库异常
		15.9.1 异常类的定义
		15.9.2 使用标准异常
	15.10 本章小结
	15.11 练习
第16章 类模板
	16.1 理解类模板
	16.2 定义类模板
		16.2.1 模板参数
		16.2.2 简单的类模板
	16.3 定义类模板的成员函数
		16.3.1 构造函数模板
		16.3.2 析构函数模板
		16.3.3 下标运算符模板
		16.3.4 赋值运算符模板
	16.4 创建类模板的实例
	16.5 非类型的类模板参数
		16.5.1 带有非类型参数的成员函数的模板
		16.5.2 非类型参数的实参
		16.5.3 对比非类型模板实参与构造函数实参
	16.6 模板参数的默认值
	16.7 模板的显式实例化
	16.8 类模板特化
		16.8.1 定义类模板特化
		16.8.2 部分模板特化
		16.8.3 从多个部分特化中选择
	16.9 在类模板中使用static_assert()
	16.10 类模板的友元
	16.11 带有嵌套类的类模板
		16.11.1 栈成员的函数模板
		16.11.2 消除依赖名称的歧义
	16.12 本章小结
	16.13 练习
第17章 移动语义
	17.1 lvalue和rvalue
	17.2 移动对象
		17.2.1 传统方法
		17.2.2 定义移动成员
		17.3 显式移动对象
		17.3.1 只能移动的类型
		17.3.2 移动对象的继续使用
	17.4 看似矛盾的情况
		17.4.1 std::move()并不移动任何东西
		17.4.2 rvalue引用是一个lvalue
	17.5 继续探讨函数定义
		17.5.1 按rvalue引用传送
		17.5.2 按值传送的归来
		17.5.3 按值返回
	17.6 继续讨论定义移动成员
		17.6.1 总是添加noexcept
		17.6.2 “移动后交换”技术
	17.7 特殊成员函数
		17.7.1 默认移动成员
		17.7.2 5的规则
		17.7.3 0的规则
	17.8 本章小结
	17.9 练习
第18章 头等函数
	18.1 函数指针
		18.1.1 定义函数指针
		18.1.2 高阶函数的回调函数
		18.1.3 函数指针的类型别名
	18.2 函数对象
		18.2.1 基本的函数对象
		18.2.2 标准函数对象
		18.2.3 参数化函数对象
	18.3 lambda表达式
		18.3.1 定义lambda表达式
		18.3.2 命名lambda闭包
		18.3.3 向函数模板传送lambda表达式
		18.3.4 捕获子句
	18.4 std::function<>模板
	18.5 本章小结
	18.6 练习
第19章 容器与算法
	19.1 容器
		19.1.1 顺序容器
		19.1.2 栈和队列
		19.1.3 集合
		19.1.4 映射
	19.2 迭代器
		19.2.1 迭代器设计模式
		19.2.2 标准库容器的迭代器
		19.2.3 数组的迭代器
	19.3 算法
		19.3.1 第一个示例
		19.3.2 寻找元素
		19.3.3 输出多个值
		19.3.4 删除-擦除技术
		19.3.5 排序
		19.3.6 并行算法
	19.4 本章小结
	19.5 练习

 