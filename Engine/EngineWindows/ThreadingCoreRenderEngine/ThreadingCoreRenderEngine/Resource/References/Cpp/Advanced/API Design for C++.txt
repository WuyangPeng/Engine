C++ API设计（API Design for C++）

官方网站：
http://APIBook.com、 http://www.apidiff.com/en/。

敏捷开发宣言：
http://agilemanifesto.org/。

开源的3D图形工具包，用于可视化仿真应用。
http://www.openscenegraph.org/。

★★★  
作者：Martin Reddy

联系作者：
martin@martinreddy.net

知识点 
1.	编写健壮而优雅的应用程序编程接口。 

代码
1.	hide_class（2.2 隐藏实现细节）。
2.	coord2d_template（2.4 易用性）。
3.	shared_pointer（2.4 易用性）。
4.	callback_instance（2.5 松耦合）。
5.	callback_static（2.5 松耦合）。
6.	pimpl_bad（3.1 Pimpl惯用法）。
7.	pimpl_good（3.1 Pimpl惯用法）。
8.	pimpl_boost（3.1 Pimpl惯用法）。
9.	opaque_pointer（3.1 Pimpl惯用法）。
10.	singleton（3.2 单例）。
11.	factory_simple（3.3 工厂模式）。
12.	factory_extensible（3.3 工厂模式）。
13.	proxy_simple（3.4 API包装器模式）。
14.	proxy_interface（3.4 API包装器模式）。
15.	adapter（3.4 API包装器模式）。
16.	facade（3.4 API包装器模式）。
17.	observer（3.5 观察者模式）。
18. named_parameters（第4章 设计）。
19. stack_c（5.1.3 使用ANSI C编写API）
20.	stack_cpp（5.1.3 使用ANSI C编写API）
21.	stack_template（5.3.1 基于模板的API示例）
22.	stack_preprocessor（5.3.2 模板与宏）
23.	stack_datadriven（5.4 数据驱动API）
 
要点
1.	API是软件组件的逻辑接口，隐藏了实现这个接口所需的内部细节。（1.1 什么是API）
2.	API描述了其他工程师构建他们的应用软件所使用的软件。
	因此，API必须拥有良好的设计、文档、回归测试，并且保证发布之间的稳定性。（1.2 API设计上有什么不同）
3.	优质的API应该设计精巧且实用性强。它不仅能带来愉悦的使用体验，且能与各种应用程序完美融合，甚至让使用者感觉不到其存在。（2.1 问题域建模）
4.	类的数据成员应该始终声明为私有的，而不是公有的或受保护的。（2.2 隐藏实现细节）
5.	永远不要返回私有数据成员的非const指针或引用。这会破坏封装性。（2.2 隐藏实现细节）
6.	谨记以下几点原则：（2.3 最小完备性）
	（1）如果类包含任一虚函数，那么必须将析构函数声明为虚函数。
	（2）一定要编写文档，说明类的方法是如何相互调用的。
	（3）绝不在构造函数或析构函数中调用虚函数，这些调用不会指向子类。
7.	除非确实需要#include类的完整定义，否则应该为类使用前置声明。（2.5 松耦合）
8.	敏捷开发宣言：（4.3.4 需求与敏捷开发）
	（1）个体与交互重于过程与工具。
	（2）工作的软件重于全面的文档。
	（3）客户合作重于合同谈判。
	（4）响应变化重于因循计划。

第1章 API简介
	★	C++ API包含如下的元素：
		1.	头文件。
		2.	类库。
		3.	文档。
	★	API开发中的一些关键因素：
		1.	API是为开发者设计的接口，如同GUI是为用户设计的接口一样。
		2.	多个应用程序可以共享一个API。
		3.	修改API时，必须尽可能保证向后兼容。
		4.	出于向后兼容的需求，一定要具有变更控制流程。
		5.	API的生存周期一般都比较长。
		6.	在编写API时，良好的文档必不可少，特别是当不提供实现的源代码时。
		7.	自动化测试同样也很重要。
	★	构建API带来以下好处：
		1.	隐藏实现。
		2.	延长寿命。
		3.	促进模块化。
		4.	减少代码重复。
		5.	消除硬编码假设。
		6.	易于改变实现。
		7.	易于优化。
	★	何时应该避免使用API：
		1.	许可证限制。
		2.	功能不匹配。
		3.	缺少源代码。
		4.	缺乏文档。
	★	每当于创建一个文件格式或者客户端/服务器协议时，同时也要为其创建API。
		这样，规范的细节以及未来的任何变更都将是集中且隐蔽的。
第2章 特征
	★	创建API的主要原因是隐藏所有的实现细节，以免将来修改API对已有客户造成影响。有两种技巧可以达到此目标：物理隐藏和信息隐藏。
	★	声明告诉编译器某个标识符的名称及类型。定义提供该标识符的完整细节，即它是一个函数还是一块内存区域。
	★	物理隐藏表示将内部细节（.cpp）和公有接口（.h）分离，存储在不同的文件中。
	★	封装是将API的公有接口与其底层实现分离的过程。
	★	逻辑隐藏指的是使用C++语言中受保护的和私有的访问控制从而限制访问内部细节。
	★	使用getter/setter惯用法与直接暴露成员变量相比，还有以下额外的好处：
		1.	有效性验证。
		2.	惰性求值。
		3.	缓存。
		4.	额外的计算。
		5.	通知。
		6.	调试。
		7.	同步。
		8.	更精细的访问控制。
		9.	维护
	★	将私有功能声明为.cpp文件中的静态函数，而不要将其作为私有方法暴露在公开的头文件中。（更好的做法是使用Pimpl惯用法）
	★	谨记奥卡姆剃刀原理：若无必要，勿增实体。
	★	当不确定是否需要某个接口时，就不要提供此接口。
		1.	你想要添加的通用性可能永远不会用到。
		2.	如果某天用到了想要添加的通用性，那时你可能已经掌握了更多API的设计知识，并可能有了与最初设想方案不同的解决方案。
		3.	如果你确实需要添加新功能，那么简单的API比复杂的API更容易添加新功能。
	★	应该保证API尽量简单：类及类中的公有成员暴露得越少越好。
		这样做的好处是API会更易于理解，更易于用户记住API模型，而且更易于调试。
	★	疑惑之时，果断弃之！精简API中公有的类和函数。
	★	继承十分强大，但仍要意识到其潜在的隐患：
		1.	对基类看似无害的修改可能会给客户带来不利的影响。
		2.	客户可能会以你根本无法预料的方式使用API。
		3.	客户可能采用不正确的或易于出错的方式扩展API。
		4.	重写函数可能破坏类的内部完整性。
	★	C++中使用虚函数时还要注意以下常见问题：
		1.	虚函数的调用必须在运行时查询虚函数表决定，而非虚函数的调用在编译时就能确定。
		2.	使用虚函数一般需要维护指向虚函数表的指针，进而增加了对象的大小。
		3.	添加、重排或移除虚函数会破坏二进制兼容性。
		4.	不是所有的虚函数都能内联，因而将虚函数声明为内联是没有任何意义的。
		5.	重载虚函数是需要技巧的。更好的方式是避免重载虚函数。
	★	应该将虚函数声明为私有的，并且仅在派生类需要调用虚函数的基类实现时才将其声明为受保护的派生类。
		因此，接口应当是非虚的，同时在适当的情况下使用模板方法设计模式。
	★	避免将函数声明为可以重写的函数（虚的），除非你有合理且迫切的需求。
	★	API应该通过易用接口来呈现基本功能，同时将高级功能隐藏在另一个独立的层次中。
	★	基于最小化的核心API，以独立的模块或库的形式构建便捷API。
	★	使用枚举类型代替布尔类型，提高代码的可读性。
	★	避免编写拥有多个相同类型参数的函数。
	★	使用一致的函数命名和参数顺序。
	★	正交的API意味着函数没有副作用。
		1.	减少冗余。
		2.	增加独立性。
	★	大部分的C++错误都是由于误用指针或引用所导致的：
		1.	对NULL解引用。
		2.	二次释放。
		3.	访问非法内存区域。
		4.	混用内存分配器。
		5.	数组释放不正确。
		6.	内存泄露。
	★	这些特定的问题可通过使用托管指针避免：
		1.	共享指针。
		2.	弱指针。
		3.	作用域指针。
	★	客户需要的指针的生命周期比对象的生命周期更长时，就应该返回智能指针。
		如果由对象持有指针的所有权，那么可以返回一个标准指针。
	★	当需要客户销毁指针时，使用智能指针返回动态申请的对象。
	★	将资源的申请与释放当作对象的构造和析构。
	★	不要将平台相关的#if和#ifdef语句放在公共的API中，因为这些语句暴露了实现细节，并使API因平台而异。
	★	耦合：软件组件之间相互连接的强度的度量，即系统中每个组件对其他组件的依赖程序。
	★	内聚：单个软件组件内的各种方法相互关联或聚合强度的度量。
	★	优秀的API表现为松耦合和高内聚。
	★	评估组件之间的耦合度可以采用下面几种不同的度量方式：
		1.	尺度。
		2.	可见度。
		3.	密切度。
		4.	灵活度。
	★	与成员函数相比，使用非成员、非友元的方法能降低耦合度。
	★	有时，使用数据冗余降低类之间的耦合是合理的。
	★	管理器类可以通过封装几个低层次类来降低耦合。
	★	回调、观察者和通知需要注意的一些共通问题：
		1.	重入。
		2.	生命周期管理。
		3.	事件顺序。
	★	优秀的API设计应该是稳定的且具有前瞻性。在当前语境中，稳定不一定意味着API不会改变，
		而是应该将接口版本化，并且在版本升级时保证身后兼容。
	★	优秀的API设计也应该有很好的文档支持，以便用户获取API的功能、行为、最佳实践以及错误条件的明确信息。
		最终，应该为API的实现编写可扩展的自动化测试程序，确保新的变更不会破坏现有用例。
第3章 模式
	★	对高质量API设计而言至关重要的设计模式：
		1.	Pimpl惯用法：该技巧支持在公有接口中完全隐藏内部细节。
		2.	单例和工厂方法：如果要确保只创建一个对象实例，那么单例模式很有用。
							工厂方法提供了创建对象实例的通用方法，它是隐藏派生类实现细节的好方法。
		3.	代理、适配器和外观：这几种结构型模式提供了在现有的不兼容接口或遗留接口上封装API的各种途径。
		4.	观察者：该行为模式可以用来减少类之间的直接依赖。
					它通过一个类（观察者）在另一个类（主体）中注册通知的方式，使得概念上不相关的类相互通信。
	★	使用Pimpl惯用法将实现细节从公有头文件中分离出来。
	★	使用Pimpl惯用法时，应采用私有内嵌实现类。只有在.cpp文件中其他类或自由函数必须访问Impl成员时，才应采用公有内嵌类。
	★	两个注意事项：
		1.	不能在实现类中隐藏私有虚方法。它们必须出现在公有类中，以保证任何派生类都能够覆盖它们。
		2.	虽然可以将公有类传递给需要使用它的实现类的方法，但必要时可以在实现类中增加指回公有类的指针，以便Impl类调用公有方法。
	★	复制语义：
		1.	禁止复制类。
		2.	显式定义复制语义。
	★	注意Pimpl类的复制语义，可以使用智能指针管理指向impl对象的指针的初始化和销毁。
	★	Pimpl惯用法的优点：
		1.	信息隐藏。
		2.	降低耦合。
		3.	加速编译。
		4.	更好的二进制兼容性。
		5.	惰性分配。
	★	Pimpl的缺点：
		1.	必须为你创建的每个对象分配并释放实现对象。
		2.	即访问所有私有成员都需要增加开如Impl->的前缀，增加的抽象层次使得实现代码更加难以阅读和调试。
		3.	编译器将不再能够捕获const方法中对成员变量的修改。
	★	单例设计模式用来确保一个类仅存一个实例。该模式变提供对此唯一实例的全局访问点。
		可以认为单例是一种更加优雅的全局变量。
	★	单例的一些优点：
		1.	确保一个类只创建一个实例。
		2.	为对象分配和销毁提供控制。
		3.	支持线程安全地访问对象的全局状态。
		4.	避免污染全局命名空间。
	★	单例是一种更加优雅地维护全局状态的方式，但始终应该考虑清楚是否需要全局状态。
	★	将构造函数、析构函数、复制构造函数以及赋值操作符声明为私有（或受保护的—），可以实现单例模式。
	★	不同编译单元中的非局部静态对象的初始化顺序是未定义的。
	★	单例销毁顺序问题的几种解决方案：
		1.	单例销毁后必要时将其恢复。
		2.	延长某个单例的寿命，使其比其他单例生存期更久。
		3.	不销毁单例。
	★	依赖注入使采用了单例模式的代码更易于测试。
	★	单一状态模式允许创建类的多个实例，这些实例使用相同的静态数据。
	★	单一状态模式的优点：
		1.	允许创建多个实例。
		2.	由于不需要特殊的GetInstance()方法，所以无需用户特别配置。
		3.	使用静态变量可以呈现出定义明确的创建和销毁语义。
	★	如果不需要惰性初始化全局数据，或者想让类的唯一性透明化，可以考虑使用单一状态代替单件。
	★	单例模式有一些替代方案，包括依赖注入、单一状态模式以及使用会话上下文。
	★	工厂模式是一个创建型的设计模式。它允许创建对象时不指定要创建的对象的具体类型。
	★	工厂方法是构造函数的一般化。
	★	构造函数的限制：
		1.	没有返回值。
		2.	命名限制。
		3.	静态绑定创建。
		4.	不允许虚构造函数。
	★	使用工厂方法提供更强大的类构造语义并隐藏子类的细节。
	★	创建包装器API的潜在副作用是影响性能，这主要因为额外增加的一级间接寻址以及存储包装层次状态带来的开销。
	★	结构化设计模式可以处理接口包装任务。
	★	代理设计模式为另一个类提供了一对一的转发接口。也就是说，代理类和原始类有相同的接口。
	★	代理的缺点是需要再次暴露原始对象的函数。
	★	代理的另一个方案是增加代理和原始API共享的虚接口，这样做是为了更好地保持这两个API的同步，这么做的前提是你能够修改原始API。
	★	代理提供了一个接口，此接口将函数调用转发到具有同样形式的另一个接口。
	★	代理模式的案例：
		1.	实现原始对象的惰性实例。
		2.	实现对原始对象的访问控制。
		3.	支持调试或“演习”模式。
		4.	保证原始类线程安全。
		5.	支持资源共享。
		6.	应对原始类将来被修改的情况。
	★	适配器设计模式将一个类的接口转换成一个兼容的但不相同的接口。
	★	适配器设计模式与代理模式相似之处是，适配器设计模式也是一个单一组件包装器，但适配器类和原始类的接口可以不相同。
	★	适配器将一个接口转换为一个兼容的但不相同的接口。
	★	适配器模式的优点：
		1.	强制API始终保持一致性。
		2.	包装API的依赖库。
		3.	转换数据类型。
		4.	为API暴露一个不同的调用约定。
	★	外观模式能够为一组类提供简化的接口。
	★	外观模式和适配器模式的区别是，外观模式简化了类的结构，而适配器模式仍然保持相同的类结构。
	★	外观模式为一组类提供了简化的接口。在封装外观模式中，底层类不再可访问。
	★	外观模式的用途：
		1.	隐藏遗留代码。
		2.	创建便捷API。
		3.	支持简化功能或者替代功能的API。
	★	观察者支持组件解耦且避免了循环依赖。
	★	MVC支持应用程序的功能模块化，并具有以下优点：
		1.	模型和视图组件的隔离，就可以实现多个用户界面，并且使这些界面能够重用公共的业务逻辑核心。
		2.	避免了因多份UI实现而构建多份重复的底层模型代码的问题。
		3.	模型和视图代码的解耦简化了为核心业务逻辑代码编写单元测试的工作。
		4.	组件的模块化允许核心逻辑开发者和GUI开发者并行工作，且互不影响。
	★	MVC架构模式促使核心业务逻辑与用户界面分离。它还隔离了控制器逻辑，控制器逻辑会引起模型的改变并更新视图。
	★	控制器和视图都依赖于模型，但是模型代码既不依赖控制器代码，也不依赖视图代码。
	★	观察者模式是“发布/订阅”范式的一个具体实例。这些技术定义了对象之间一对多的依赖，
		使得发布者对象能够将它的状态变化通知给所有的订阅对象，而又不直接依赖订阅对象。
第4章 设计
	★	最初的良好设计和此后的高标准维护同等重要。
	★	好的API设计是一个过程，而不仅仅是第一步。
	★	第一次交付代码就像背负债务。少量技术债可以加速开发，只要你立即通过重写偿还了它们。
		如果有技术债没有偿还，危险就会出现 。花在不稳定的代码上的每分钟都会算作技术债的利息。
		整个工程都可能因为不稳定实现带来的债务压力而停滞不前。
	★	警告信号：
		1.	脆弱性。
		2.	僵化性。
		3.	顽固性。
		4.	不可转移性。
	★	对于下一代项目，开发有以下两个方向：
		1.	演进式。设计一个包含所有新需求的系统，然后迭代重构现有系统直到满足需求。
		2.	革命式。丢掉旧代码，然后从零开始设计，实现一个全新的系统。
	★	记住要不断偿还技术债。
	★	软件产业中的需求可以分为不同的类型：
		1.	业务需求。
		2.	功能性需求。
		3.	非功能性需求。
	★	功能性需求规定了API如何表现。
	★	非功能性需求：
		1.	性能。
		2.	平台兼容性。
		3.	安全性。
		4.	可伸缩性。
		5.	灵活性。
		6.	易用性。
		7.	并发性。
		8.	代价。
	★	好的功能性需求应该是简单、易读、清晰、可验证的，而且没有开发术语。
	★	用例基于API与用户或其他软件的交互来描述API的行为。
	★	用例从用户的角度描述API的需求。
	★	实现创建用例过程的好方法是：
		1.	识别系统所有的参与者以及它们扮演的角色。
		2.	识别每个角色需要完成的所有目标。
		3.	为每个目标创建用例。
	★	用例可以是面向目标的简短描述信息的简要列表，也可以是更为正式的模板定义的结构化说明。
	★	编写高质量用例：
		1.	使用领域术语。
		2.	不要过度详细地说明用例。
		3.	用例并不定义所有的需求。
		4.	用例并不定义设计。
		5.	不要在用例中详细说明设计。
		6.	用例能够指导测试。
		7.	对迭代的预期。
		8.	不要坚持完全覆盖。
	★	用户故事是敏捷开发过程中一种从用户那获得最小需求的方法。
	★	用户故事的特性：
		1.	独立性。
		2.	可协商性。
		3.	有价值。
		4.	可评估。
		5.	短小。
		6.	可测试。
	★	对问题领域进行合理抽象，然后设计相应的对象与类的层次结构来表达该抽象。
	★	复杂系统都有两种层次化视角：
		1.	对象层次结构。
		2.	类层次结构。
	★	软件构建的设计阶段由两个主要活动组成：
		1.	架构设计。
		2.	详细设计。
	★	API设计包括开发顶层架构和详细的类层次结构。
	★	创建API的架构的过程可以分解为4个基本步骤：
		1.	分析影响架构的功能性需求。
		2.	识别架构的约束并加以说明。
		3.	创建系统中的主要对象，并确认它们之间的关系。
		4.	架构的交流与文档。
	★	架构的约束：
		1.	组织因素。
		2.	环境因素。
		3.	运行因素。
	★	架构设计被众多独特的组织、环境和运行等因素约束。
	★	总是为变化而设计，变化是不可避免的。
	★	创建关键对象：
		1.	自然语言。
		2.	属性。
		3.	行为。
		4.	原型。
		5.	领域。
	★	API的关键对象并不容易识别，请尝试从不同的角度看待问题，并不断迭代和完善你的模型。
	★	架构模式的分类：
		1.	结构化模式。
		2.	交互式系统。
		3.	分布式系统。
		4.	自适应系统。
	★	一个API应该是由逻辑关联组件组成的无环层次结构。
	★	要避免API各个组件间的循环依赖。
	★	在API的附属文档中要描述其高层架构并阐述其原理。
	★	你应该深入地思考如何将设计以最自然、最直观的方式传达给用户。
	★	要集中精力设计定义了API80%功能的20%的类。
	★	创建一个新类涉及定义一个新类型。
	★	使用继承：
		1.	设计支持还是禁止继承。
		2.	仅在适当的地方使用继承。
		3.	避免深度继承树。
		4.	使用纯虚成员函数强制子类提供实现。
		5.	不要为现有接口增加新的纯虚函数。
		6.	不要过度设计。
	★	避免深度继承层次结构。
	★	除非专门为了使用抽象接口或mixin类，否则应该避免使用多重继承。
	★	Liskov替换原则指出，在不修改任何行为的情况下用派生类替换基类，这应该总是可行的。
	★	组合优先于继承。
	★	开放——封闭原则：类的目标应该是为扩展而开放，为修改而关闭的。
	★	维护一个稳定的接口能够带来一定的灵活性，即在修改接口的底层实现的同时，
		又不过多地影响客户的代码。
	★	API应该为不兼容的接口变化而关闭，为功能扩展而开放。
	★	迪米特法则：函数可以做的事情。
		1.	调用同一个类的其他函数。
		2.	在同一个类的数据成员卢调用函数。
		3.	在它接受的任何参数上调用函数。
		4.	在它创建的任何局部对象上调用函数。
		5.	在全局对象上调用函数。
	★	迪米特法则指出，你应该只调用自己类或直接相关对象的函数。
	★	类命名的指导原则：
		1.	简单的类名应该是动人的，描述性强的且是自解释的。
		2.	好名字能推动设计。
		3.	为了传达更为精确具体的意义，使用复合名字是必要的。
		4.	接口往往使用对象模型中的形容词表示。
		5.	避免含义模糊的缩写词。
		6.	为顶层符号包含某种形式的命名空间，以避免API中的名字与客户使用其他API冲突。
	★	函数命名指导原则：
		1.	用于设置或返回值的函数，函数名应该使用标准前缀来完整地描述这个量值。
		2.	需要回答“是否”问题的函数应该使用适当的前缀指示该行为并返回。
		3.	用于执行某些动作的函数应该用一个证据强烈的动词命名。
		4.	使用正面的概念命名函数，而不要以否定形式命名。
		5.	函数名应该能描述例程所做的所有事情。
		6.	避免使用缩写。
		7.	函数不应该以下划线开头。
		8.	形成自然对仗的函数应该使用正确的互补的术语。
	★	避免过长的参数列表。
	★	使用函数来设置参数值也带来以下好处：
		1.	值可以以任何顺序指定，因为函数调用是与顺序无关。
		2.	每个值的效果图更为明显，因为你必须使用一个命名函数来设置值。
		3.	支持可选的参数，只要不调用相应的函数即可。
		4.	对于所有的设定，构造函数可以定义合理的默认值。
		5.	添加新参数是向后兼容的，因为只是添加了新函数，现有函数的签名不需要修改。
	★	使用一致的、充分文档化的错误处理机制。
	★	异常的使用是个要么全有要么全无的命题。
	★	从std::exception派生自己的异常。
	★	在出现故障时，让API快速干净地退出，并给出完整精确的诊断细节。
第5章 风格
	★	API风格：
		1.	纯C API。
		2.	面向对象的C++ API。
		3.	基于模板的API。
		4.	数据驱动型的API。
	★	对于纯C API而言，所有公开的函数和数据结构应该使用一个公共的前缀。
	★	为实现更严格的类型检查，并确保C++程序可以使用你的API，请尝试用C++编译器来编译C API。
	★	使用C编写API的原因：
		1.	必须与现有的完全用C编写的项目集成。
		2.	出于二进制兼容性考虑。
	★	在C API的头文件中使用extern "C"限制，以便于C++程序能正确地编译和链接API。
	★	识别给定问题空间中的关键对象，并确定它们之间是如何彼此关联的。
	★	面向对象API允许使用对象而非动作来建模软件，同时也带来了继承和封装等优点。
	★	如果相对于运行时开销而言，代码体积是需要优先考虑的因素，那么应该选择面向对象方案，而非模板。
		或者相反，如果运行时性能更重要，那就应该选择模板。
	★	数据驱动型API的优点：
		1.	程序的业务逻辑能够抽象到可以由人来编辑的数据文件之中。
			利用这种方法，可以在不重新编译可执行文件的情况下改变程序的行为。
		2.	对于API将来可能发生变化，它的容错性更强。
		3.	它们可以更容易地支持数据驱动型测试技术。
	★	数据驱动型API可以很好地映射到Web服务和其他客户端/服务器形式的API，它们也支持数据驱动型测试技术。
	★	数据驱动API的缺点：
		1.	API的简洁性和稳定性也伴随着运行时开销。
		2.	物理上的头文件无法反映逻辑接口。
		3.	数据驱动API无法从接口的编译时检查中获益。
第6章 C++用法
