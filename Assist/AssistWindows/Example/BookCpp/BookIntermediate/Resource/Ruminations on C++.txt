C++ 沉思录（Ruminations on C++）

官方网站：
http://ftp.aw.com/cseng/authors/koenig/ruminations （已失效）。

★★★
作者：Andrew Koenig、Barbara E.Moo
其他书籍：《Accelerated C++》，Barbara E.Moo《C++ Primer》。

知识点 
1.	C++	知识。

前言
	★ C++最基本的设计理念就是“用类来表示概念”，C++解决复杂性的基本原则是抽象，面向对象思想是C++的手段之一，而不是全部。
	原由
	本书正是世界所需的又一本C++书籍
	组织
	编译和编辑
	致谢
第0章  序幕
	0.1 第一次尝试
		0.1.1 改进
		0.1.2 另一种改进
	0.2 不用类来实现 
	0.3 为什么用C++更简单
	0.4 一个更大的例子
	0.5 结论
第一篇 动机
	第1章  为什么我用C++
		1.1 问题
		1.2 历史背景
		1.3 自动软件发布
			1.3.1 可靠性与通用性
			1.3.2 为什么用C
			1.3.3 应付快速增长
		1.4 进入C++
		1.5 重复利用的软件 
		1.6 后记
	第2章  为什么用C++工作
		2.1 小项目的成功
			2.1.1 开销
			2.1.2 质疑软件工厂
		2.2 抽象
			2.2.1 有些抽象不是语言的一部分
			2.2.2 抽象和规范
			2.2.3 抽象和内存管理
		2.3 机器应该为人服务
	第3章  生活在现实世界中		
第二篇 类和继承
	第4章  类设计者的核查表
	第5章  代理类
		5.1 问题
		5.2 经典解决方案
		5.3 虚复制函数
		5.4 定义代理类
		5.5 小结
	第6章  句柄：第一部分
		6.1 问题
		6.2 一个简单的类
		6.3 绑定到句柄
		6.4 获取对象
		6.5 简单的实现
		6.6 引用计数型句柄
		6.7 写时复制
		6.8 讨论
	第7章  句柄：第二部分
		7.1 回顾
		7.2 分离引用计数
		7.3 对引用计数的抽象
		7.4 存取函数和写时复制
		7.5 讨论
	第8章  一个面向对象程序范例
		8.1 问题描述
		8.2 面向对象的解决方案
		8.3 句柄类
		8.4 扩展1：新操作
		8.5 扩展2：增加新的节点类型
		8.6 反思
	第9章  一个课堂练习的分析（上）
		9.1 问题描述
		9.2 接口设计
		9.3 补遗
		9.4 测试接口
		9.5 策略
		9.6 方案
		9.7 图像的组合
		9.8 结论
	第10章  一个课堂练习的分析（下）
		10.1 策略
			10.1.1 方案
			10.1.2 内存分配
			10.1.3 结构构造 
			10.1.4 显示图像
		10.2 体验设计的灵活性
		10.3 结论
	第11章  什么时候不应当使用虚函数	
		11.1 适用的情况
		11.2 不适用的情况
			12.2.1 效率
			12.2.2 你想要什么样的行为
			12.2.3 不是所有的类都是通用的
		11.3 析构函数很特殊
		11.4 小结
第三篇 模板
	第12章  设计容器类
		12.1 包含什么
		12.2 复制容器意味着什么
		12.3 怎样获取容器的元素
		12.4 怎样区分读和写
		12.5 怎样处理容器的增长
		12.6 容器支持哪些操作
		12.7 怎样设想容器元素的类型
		12.8 容器和继承
		12.9 设计一个类似数组的类
	第13章  访问容器中的元素
		13.1 模拟指针
		13.2 获取数据
		13.3 遗留问题
		13.4 指向const Array的Pointer
		13.5 有用的增强操作
	第14章  迭代器
		14.1 完成Pointer类
		14.2 什么是迭代器
		14.3 删除元素
		14.4 删除容器
		14.5 其他设计考虑
		14.6 讨论
	第15章  序列
		15.1 技术状况
		15.2 基本的传统观点
		15.3 增加一些额外操作
		15.4 使用范例
		15.5 再增加一些
		15.6 请你思考
	第16章  作为接口的模板
		16.1 问题
		16.2 第一个例子
		16.3 分离迭代方式
		16.4 遍历任意类型
		16.5 增加其他类型
		16.6 将存储技术抽象化
		16.7 实证
		16.8 小结
	第17章  模板和泛型算法
		17.1 一个特例
		17.2 泛型化元素类型
		17.3 推迟计数
		17.4 地址独立性
		17.5 查找非数组
		17.6 讨论
	第18章  泛型迭代器
		18.1 一个不同的算法 
		18.2 需求的分类
		18.3 输入迭代器
		18.4 输出迭代器
		18.5 前向迭代器
		18.6 双向迭代器
		18.7 随机存取迭代器
		18.8 是继承吗
		18.9 性能
		18.10 小结
	第19章  使用泛型迭代器
		19.1 迭代器类型
		19.2 虚拟序列
		19.3 输出流迭代器
		19.4 输入流迭代器
		19.5 讨论
	第20章  迭代器配接器
		20.1 一个例子
		20.2 方向不对称性
		20.3 一致性和不对称性
		20.4 自动反向
		20.5 讨论
	第21章  函数对象
		21.1 一个例子
		21.2 函数指针
		21.3 函数对象
		21.4 函数对象模板
		21.5 隐藏中间类型
		21.6 一种类型包罗万象
		21.7 实现
		21.8 讨论
	第22章  函数配接器	
		22.1 为什么是函数对象
		22.2 用于内建操作符的函数对象
		22.3 绑定者
		22.4 更深入地探讨
		22.5 接口继承
		22.6 使用这些类
		22.7 讨论
第四篇 库
	第23章  日常使用的库
		23.1 问题
		23.2 理解问题：第1部分
		23.3 实现：第1部分
		23.4 理解问题：第2部分
		23.5 实现：第2部分
		23.6 讨论
	第24章  一个库接口设计实例
		24.1 复杂问题
		24.2 优化接口
		24.3 温故知新
		24.4 编写代码
		24.5 结论
	第25章  库设计就是语言设计
		25.1 字符串
		25.2 内存耗尽
		25.3 复制
		25.4 隐藏实现 
		25.5 缺省构造函数
		25.6 其他操作
		25.7 子字符串
		25.8 结论
	第26章  语言设计就是库设计
		26.1 抽象数据类型
			26.1.1 构造函数与析构函数
			26.1.2 成员函数及可见度控制
		26.2 库和抽象数据类型
			26.2.1 类型安全的链接
			26.2.2 命名空间
		26.3 内存分配
		26.4 按成员赋值和初始化
		26.5 异常处理
		26.6 小结
第五篇 技术
	第27章  自己跟踪自己的类
		27.1 设计一个跟踪类
		27.2 创建死代码
		27.3 生成对象的审计跟踪
		27.4 验证容器行为
		27.5 小结
	第28章  在簇中分配对象
		28.1 问题
		28.2 设计方案
		28.3 实现
		28.4 加入继承
		28.5 小结
	第29章  应用器、操纵器和函数对象
		29.1 问题
		29.2 一种解决方案
		29.3 另一种不同的解决方案
		29.4 多个参数
		29.5 一个例子
		29.6 简化
		29.7 思考
		29.8 历史记录、参考资料和致谢
	第30章  将应用程序库从输入输出中分离出来	
		30.1 问题
		30.2 解决方案1：技巧加蛮力
		30.3 解决方案2：抽象输出
		30.4 解决方案3：技巧而无蛮力
		30.5 评论
第六篇 总结
	第31章  通过复杂性获取简单性
		31.1 世界是复杂的
		31.2 复杂性变得隐蔽
		31.3 计算机也是一样
		31.4 计算机解决实际问题
		31.5 类库和语言语义
		31.6 很难使事情变得容易
		31.7 抽象和接口
		31.8 复杂度的守恒
	第32章  说了Hello world后再做什么
		32.1 找当地的专家
		32.2 选一种工具包并适应它
		32.3 C的某些部分是必需的
		32.4 C的其他部分不是必需的
		32.5 给自己设一些问题
		32.6 结论
附录 Koenig和Moo夫妇访谈