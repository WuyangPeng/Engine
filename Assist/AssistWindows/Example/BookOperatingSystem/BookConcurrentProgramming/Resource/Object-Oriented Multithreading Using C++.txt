C++ 面向对象多线程编程 （Object-Oriented Multithreading Using C++）

官方网站：    
http://www.cloudcrown.com （已失效）
 
☆
作者：Cameron Hughes、Tracey Hughes
其他书籍：《C++ 并行与分布式编程》、《C++ 多核高级编程》

前言
	学习本书的必要性
	发展趋势
	存在的难题
	解决方案
	本书为谁而写
	本书的组织
	类关系图
	支持的线程环境和编译器
	测试与代码可靠性
	致谢
第1章 C++组件简介
	1.1 既是好消息，也是坏消息
	1.2 面向对象方法
	1.3 面向对象架构
	1.4 C++组件
	1.5 面向对象软件组件
		1.5.1 什么是类
		1.5.2 抽象数据类型
		1.5.3 类作为模型
		1.5.4 类类型
第2章 进程解剖
	2.1 什么是进程
	2.2 进程状态
	2.3 进程优先权
	2.4 上下文切换
	2.5 进程关系
		2.5.1 进程终止
		2.5.2 同步和异步进程
	2.6 进程映射
	2.7 进程资源
		2.7.1 硬件资源
		2.7.2 数据资源
		2.7.3 软件资源
		2.7.4 优先权与资源
第3章 轻量级进程：线程
	3.1 多线程处理
	3.2 线程与进程的相似之处
	3.3 线程与进程的不同之处
	3.4 线程的优点
	3.5 线程的缺点
	3.6 线程类型
		3.6.1 休眠（sleeper）和单步（one-shot）
		3.6.2 先占工作
		3.6.3 延迟工作
	3.7 线程相关信息
	3.8 线程创建
		3.8.1 谁可以终止线程
		3.8.2 分离线程
		3.8.3 远程线程
	3.9 线程堆栈
	3.10 线程控制
		3.10.1 临界区
		3.10.2 挂起和恢复线程
	3.11 线程优先权
	3.12 线程状态
	3.13 线程与资源
	3.14 线程的实现模型：用户级线程
		3.14.1 核心级线程
		3.14.2 混合线程
第4章 多任务与多线程编程
	4.1 什么是多任务编程
		4.1.1 对话级多任务编程
		4.1.2 进程级多任务编程
		4.1.3 多线程编程
	4.2 合作和抢占式多任务
		4.2.1 合作多任务
		4.2.2 抢占式多任务
		4.2.3 时间片的大小
	4.3 多处理器下的多线程
		4.3.1 非对称多处理器处理
		4.3.2 对称多处理器处理
		4.3.3 具有多处理器的多线程处理模型
	4.4 规划策略
		4.4.1 规划策略目标
		4.4.2 规划策略准则
		4.4.3 轮询和FIFO规划
		4.4.4 最短任务优先规划法
		4.4.5 最短剩余时间规划法
第5章 进程间和线程间通信
	5.1 依赖关系
		5.1.1 通信依赖性
		5.1.2 合作依赖性
		5.1.3 计数线程与进程依赖性
	5.2 进程间和线程间通信
		5.2.1 什么是进程间通信
		5.2.2 进程间通信类型
	5.3 线程间通信
第6章 合作与同步
	6.1 竞争条件
		6.1.1 数据同步
		6.1.2 硬件同步
		6.1.3 任务同步
	6.2 同步关系
	6.3 进程同步机制
		6.3.1 信号量提供钥匙
		6.3.2 信号量类型
		6.3.3 自愿互斥量策略
		6.3.4 使用互斥量锁定防止竞争条件
		6.3.5 临界区
	6.4 避免竞争条件
	6.5 死锁必需的条件
	6.6 远离死锁
第7章 接口类与进程间通信
	7.1 接口类详解
		7.1.1 接口类的类型
		7.1.2 减小参数和全局变量的数量
	7.2 C++没有多线程处理的关键字
	7.3 面向对象接口到管道
	7.4 使用接口类来实现面向对象命名管道
		7.4.1 相关客户/服务器术语
		7.4.2 名字包含哪些内容
		7.4.3 命名管道和iostream复合
		7.4.4 npstream接口类
		7.4.5 命名管道与STL istream_iterator和ostream_iterator
第8章 同步对象
	8.1 初识mutex类
		8.1.1 命名互斥量类
		8.1.2 同步和依赖性关系（示例）
		8.1.3 表示条件的类
		8.1.4 等待多个事件或互斥量
		8.1.5 通过类成员函数锁定和取消锁定
		8.1.6 小结
第9章 线程处理面向对象架构
	9.1 什么是多线程架构
	9.2 使用多线程的常见架构
		9.2.1 文件服务器
		9.2.2 数据库服务器和事务服务器
		9.2.3 应用服务器
		9.2.4 事件驱动架构
	9.3 黑板架构
	9.4 途径上的不同（面向对象与过程化）
		9.4.1 封装是关键（保护和数据隐藏）
		9.4.2 类成员函数CREW策略
	9.5 增量多线程处理
第10章 类层次和线程处理C++组件
	10.1 抽象基类
	10.2 具体类 理想终结者
		10.2.1 多线程层次中的节点类
		10.2.2 线程与容器和集合类
		10.2.3 应用框架类
第11章 类行为和线程处理
	11.1 线程、对象和作用域
		11.1.1 连接与作用域
		11.1.2 线程和类作用域
	11.2 同步关系和对象成员函数
	11.3 在多线程环境中构建和析构对象
		11.3.1 exit()和abort()
		11.3.2 构造函数和SS关系
		11.3.3 析构函数与FF关系
		11.3.4 线程集合与对象
		11.3.5 线程与异常处理
	11.4 线程安全函数
	11.5 多线程环境中的不安全函数
	11.6 在多线程架构中使用STL算法
第12章 测试多线程应用程序
	12.1 软件测试的目标
		12.1.1 分而治之（divide and conquer）
		12.1.2 软件测试类型
		12.1.3 对象的组件复合
		12.1.4 成员函数访问数据组件
		12.1.5 成员函数正确性
		12.1.6 对象的过渡状态
		12.1.7 成员函数调用序列
		12.1.8 对象完整性
	12.2 对象的测试实例
		12.2.1 对象构建的测试实例
		12.2.2 析构函数的测试实例
		12.2.3 赋值的测试实例
		12.2.4 对象派生子类
		12.2.5 成员函数性能的测试实例
		12.2.6 对象资源需求和测试实例
		12.2.7 测试公有对象访问、受保护对象访问以及线程化对象访问
	12.3 测试多线程架构的问题
		12.3.1 开放层次问题
		12.3.2 规划问题
	12.4 使用常用模型和架构
第13章 实现并发的最后思考
附录A POSIX线程管理规范
附录B 类关系图规范
附录C POSIX线程管理函数
附录D Win32线程管理函数
附录E OS/2线程管理函数
附录F 线程和同步类（POSIX, Win32以及OS/2）
 