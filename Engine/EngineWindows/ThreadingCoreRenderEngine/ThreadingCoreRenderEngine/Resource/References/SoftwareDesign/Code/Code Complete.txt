代码大全（Code Complete）
（第2版)

官方网站：
https://stevemcconnell.com/、 http://www.cc2e.com/ （已失效）。

★★☆
作者：Steve McConnell
其他书籍：《软件估算：“黑匣子”揭秘》。

知识点
1.	软件构建手册。 
2.	需求核对表（3.4 需求的先决条件）。
3.  架构核对表（3.5 架构的先决条件）。
4.  前期准备核对表（第3章 三思而后行：前期准备）。
5.	主要的构建实践核对表（4.4 选择主要的构建实践方法）。
6.	软件构造中的设计核对表（5.5	对流行的设计方法的评论）。
7.	类的质量核对表（6.6	超越类：包）。
8.	高质量的子程序核对表（7.7 宏子程序和内联子程序）。
9.	防御式编程核对表（8.8 对防御式编程采取防御的姿态）。
10.	使用数据的一般事项核对表（10.8 为变量指定单一用途）。

要点
1.	首先为人编写代码，其次才是为机器。（译序）
2.	可以用较低代价修正的错误，并不意味着这些错误的修正不重要。（前言）
3.	隐喻的价值绝不应低估。隐喻的优点在于其可预期的效果：能被所有的人理解。不必要的沟通和误解也因此大为减低，学习与教授更为快速。
	实际上，隐喻是对概念进行内在化和抽象的一种途径，它让人们在更高的层面上思考问题，从而避免低层次的错误。（第2章）
4.	设计模式提供的益处：（第5章）
	1.	设计模式通过提供现成的抽象来减少复杂度。
	2.	设计模式通过把常见解决方案的细节予以制度化来减少出错。
	3.	设计模式通过提供多种设计方案而带来启发性的价值。
	4.	设计模式通过把设计对话提升到一个更高的层次上来简化交流。
5.	创建类的抽象接口的指导建议：（第6章）
	1.	类的接口应该展现一致的抽象层次。
	2.	一定要理解类所实现的抽象是什么。
	3.	提供成对的服务。
	4.	把不相关的信息转移到其他类中。
	5.	尽可能让接口可编程，而不是表达语义。
	6.	谨防在修改时破坏接口的抽象。
	7.	不要添加与接口抽象不一致的公有成员。
	8.	同时考虑抽象性和内聚性。
6.	良好的封装：（第6章）
	1.	不要公开暴露成员数据。
	2.	避免把私有的实现细节放入类的接口中。
	3.	不要对类的使用者做出任何假设。
	4.	避免使用友元类。
	5.	不要因为一个子程序里仅使用公有子程序，就把它归入公开接口。
	6.	让阅读代码比编写代码更方便。
	7.	要格外警惕从语义上破坏封装性。
	8.	留意过于紧密的耦合关系。
7.	包含：（第6章）
	1.	通过包含来实现“有一个”的关系。
	2.	在万不得已时通过private继承来实现“有一个”的关系。
	3.	警惕有超过约7个数据成员的类。
8.	应该避免的类：（第6章）
	1.	避免创建万能类。
	2.	消除无关紧要的类。
	3.	避免用动词命名的类。
9.	设置函数的返回值：（第7章）
	1.	检查所有可能的返回路径。
	2.	不要返回指向局部数据的引用或指针。
10.	指导建议：（第9章）
	1.	把编译器的警告级别调到最高。
	2.	使用验证工具。
	3.	消息产生错误消息和警告的所有根源。

第1部分 打好基础
	第1章 欢迎进入软件构建的世界
		要点：
		1.	软件构建是软件开发的核心活动；构建活动是每个项目中唯一一项必不可少的工作。
		2.	软件构建的主要活动包括：详细设计、编码、调试、集成、开发者测试（包括单元测试和集成测试）。
		3.	构建也常被称作“编码”和“编程”。
		4.	构建活动的质量对软件的质量有着实质性的影响。
	第2章 用隐喻来更充分地理解软件开发
		科学发展的历史并不是一系列从“错误”的隐喻到“正确”的隐喻的转变，而是一系列从“不太合适”的隐喻到“更好”的隐喻的转变，
		也是从不是很贴切的隐喻到更贴切的隐喻的转变，还是从在一个方面暗示人们到在别一个方面暗示人们的转变。 
		要点：
		1.	隐喻是启示而不是算法。因此它们往往有一点随意。
		2.	隐喻把软件开发过程与其他你熟悉的活动联系在一起，帮助你更好地理解。
		3.	有些隐喻比其他一些隐喻更贴切。
		4.	通过把软件的构建过程比作是房屋的建设过程，我们可以发现，仔细的准备是必要的，而大型项目和小型项目之间也是有差异的。
		5.	通过把软件开发中的实践比作是智慧工具箱中的工具，我们又发现，每位程序员都有许多工具，
			但并不存在任何一个能适用于所有工作的工具，因地制宜地选择正确工具是成为能有效编程的程序员的关键。
		6.	不同的隐喻彼此并不排斥，应当使用对你最有益处的某种隐喻组合。
	第3章 三思而后行：前期准备
		要点：
		1.	构建活动的准备工作的根本目标在于降低风险。要确认你的准备活动是在降低风险，而非增加风险。
		2.	如果你想开发高质量的软件，软件开发过程必须由始至终关注质量。
			在项目初期关注质量，对产品质量的正面影响比在项目末期关注质量的影响要大。
		3.	程序员的一部分工作是教育老板和合作者，告诉他们软件开发过程，包括在开始编程之前进行充分准备的重要性。
		4.	你所从事的软件项目的类型对构建活动的前期准备有重大影响——许多项目应该是调度迭代式的，某些应该是序列式的。
		5.	如果没有明确的问题定义，那么你可能会在构建期间解决错误的问题。
		6.	如果没有做完良好的需求分析工作，你可能没能察觉待解决的问题的重要细节。
			如果需要变更发生在构建之后的阶段，其代阶是“在项目早期更改需求”的20至100倍。
			因此在开始编程之前，你要确认“需求”已到到位了。
		7.	如果没有做完良好的架构设计，你可能会在构建期间用错误的方法解决正确的问题。
			架构变更的代阶随着“为错误的架构编写的代码数量”增加而增加，因此，也要确认“架构”已经到位了。
		8.	理解项目的前期准备所采用的方法，并相应地选择构建方法。
	第4章 关键的“构建”决策
		要点：
		1.	每种编程语言都有其优点和弱点。要知道你使用的语言的明确优点和弱点。
		2.	在开始编程之前，做好一些约定。“改变代码使之符合这些约定”是近乎不可能的。
		3.	“构建的实践方法”的种类比任何单个项目能用到的更多。有意识地选择最适合你的项目的实践方法。
		4.	问问你自己，你采用的编程实践是对你所用的编程语言的正确响应，还是受它的控制？
			请记得“深入一种语言去编程”，不要仅“在一种语言上编程”。
		5.	你在技术浪潮中的位置决定了哪种方法是有效的——甚至是可能用到的。
			确定你在技术浪潮中的位置，并相应调整计划和预期目标。
第2部分 创建高质量的代码
	第5章 软件构建中的设计
		高代价、低效率的设计源于下面三种根源：
		1.	用复杂的方法解决简单的问题。
		2.	用简单但错误的方法解决复杂的问题。
		3.	用不恰当的复杂方法解决复杂的问题。
		理想的设计特征：
		1.	最小的复杂度。
		2.	易于维护。
		3.	松散耦合。
		4.	可扩展性。
		5.	可重用性。
		6.	高扇入。
		7.	低扇出。
		8.	可移植性。
		9.	精简性。
		10.	层次性。
		11.	标准技术。
		常见的设计模式：
		1.	抽象工厂：通过指定对象组的种类而非单个对象的类型来支持创建一组相关的对象。
		2.	适配器：把一个类的接口转变成为另一个接口。
		3.	桥接：把接口和实现分离开来，使它们可以独立的变化。
		4.	组合：创建一个包含其他同类对象的对象，使得客户代码可以与最上层对象交互而无须考虑所有的细节对象。
		5.	装饰器：给一个对象动态地添加职责，而无须为了每一种可能的职责配置情况去创建特定的子类。
		6.	外观：为没有提供一致接口的代码提供一个一致的接口。
		7.	工厂方法：给特定基类的派生类的实例化时，除了在工厂方法内部之外均无须了解各派生对象的具体类型。
		8.	迭代器：提供一个服务对象来顺序地访问一组元素中的各个元素。
		9.	观察者：使一组相关对象相互同步，方法是让另一个对象负责。
					在这组对象中的任何一个发生改变时，由它把这种变化通知给这个组里的所有对象。
		10. 单件：为有且仅有一个实例的类提供一种全局访问功能。
		11.	策略：定义一组算法或者行为，使得它们可以动态地相互替换。
		12. 模板方法：定义一个操作的算法结构，但是把部分实现的细节留给子类。
		要点：
		1.	软件的首要技术使命就是管理复杂度。以简单性作为努力目标的设计方案对此最有帮助。
		2.	简单性可以通过两种方式来获取：一是减少在同一时间所关注的本质性复杂度的量，二是避免生成不必要的偶然的复杂度。
		3.	设计是一种启发式的过程。固执于某一种单一方法会损害创新能力，从而损害你的程序。
		4.	好的设计都是迭代的。你尝试设计的可能性越多，你的最终设计方案就会变得越好。
		5.	信息隐藏是个非常有价值的概念。通过询问“我应该隐藏些什么？”能够解决很多困难的设计问题。
	第6章 可以工作的类
		使用ADT的益处：
		1.	可以隐藏实现细节。
		2.	改动不会影响到整个程序。
		3.	让接口能提供更多信息。
		4.	更容易提高性能。
		5.	让程序的正确性更显而易见。
		6.	程序更具自我说明性。
		7.	无须在程序内到处传递数据。
		8.	你可以像在现实世界中那样操作实体。
		继承：
		1.	用public继承来实现“是一个”的关系。
		2.	要么使用继承并进行详细说明，要么就不要用它。
		3.	遵循Liskov替换原则。
		4.	确保只继承需要继承的部分。
		5.	不要“覆盖”一个不可覆盖的成员函数。
		6.	把共用的接口、数据及操作放到继承树中尽可能高的位置。
		7.	只有一个实例的类是值得怀疑的。
		8.	只有一个派生类的基类也值得怀疑。
		9.	派生后覆盖了某个子程序，但在其中没做任何操作，这种情况也值得怀疑。
		10.	避免让继承体系过深。
		11.	尽量使用多态，避免大量的类型检查。
		12.	让所有数据都是private（而非protected）。
		成员函数和数据成员：
		1.	让类中子程序的数量尽可能少。
		2.	禁止隐式地产生你不需要的成员函数和运算符。
		3.	减少类所调用的不同子程序的数量。
		4.	对其他类的子程序的间接调用要尽可能少。
		5.	应尽量减少类和类之间相互合作的范围。
		构造函数
		1.	如果可能，应该在所有的构造函数中初始化所有的数据成员。
		2.	用私有构造函数来强制实现单件属性。
		3.	优先采用深层复本，除非论证可行，才采用浅层复本。
		创建类的理由
		1.	对现实世界中的对象建模。
		2.	对抽象对象建模。
		3.	降低复杂度。
		4.	隔离复杂度。
		5.	隐藏实现细节。
		6.	限制变化所影响的范围。
		7.	隐藏全局数据。
		8.	让参数传递更顺畅。
		9.	创建中心控制点。
		10.	让代码更易于重用。
		11.	为程序族做计划。
		12.	把相关操作放到一起。
		13.	实现特定的重构。
		要点：
		1.	类的接口应提供一致的抽象。很多问题都是由于违背该原则而引起的。
		2.	类的接口应隐藏一些信息——如某个系统接口、某项设计决策、或一些实现细节。
		3.	包含往往比继承更为可取——除非你要对“是一个”的关系建模。
		4.	继承是一种有用的工具，但它却会增加复杂度，这有违于软件的首要技术使用——管理复杂度。
		5.	类是管理复杂度的首选工具。要在设计类时给予足够的关注，才能实现这一目标。
	第7章 高质量的子程序
		创建子程序的正当理由：
		1.	降低复杂度。
		2.	引入中间、易懂的抽象。
		3.	避免代码重复。
		4.	支持子类化。
		5.	隐藏顺序。
		6.	隐藏指针操作。
		7.	提高可移植性。
		8.	简化复杂的布尔判断。
		9.	改善性能。
		10.	确保所有的子程序都很小。
		好的子程序名字：
		1.	描述子程序所做的所有事情。
		2.	避免使用无意义、模糊或表述不清的动词。
		3.	不要仅通过数字来形成不同的子程序名字。
		4.	根据需要确定子程序名字的长度。
		5.	给函数命名时要对返回值有所描述。
		6.	给过程起名时使用语气强烈的动词加宾语的形式。
		7.	准确使用对仗词。
		8.	为常用操作建立命名规则。
		如何使用子程序参数：
		1.	按照输入——修改——输出的顺序排列参数。
		2.	考虑自己创建in和out关键字。
		3.	如果几个子程序都用了类似的一些参数，应该让这些参数的排列顺序保持一致。
		4.	使用所有的参数。
		5.	把状态或出错变量放在最后。
		6.	不要把子程序的参数用做工作变量。
		7.	在接口中对参数的假定加以说明。
		8.	把子程序的参数个数限制在大约7个以内。
		9.	考虑对参数采用某种表示输入、修改、输出的命名规则。
		10.	为子程序传递用以维持其接口抽象的变量或对象。
		11.	使用具名参数。
		12.	确保实际参数与形式参数相匹配。
		要点：
		1.	创建子程序最主要的目的是提高程序的可管理性，当然也有其他一些好的理由。
			其中，节省代码空间只是一个次要原因；提高可读性、可靠性和可修改性等原因都更重要一些。
		2.	有时候，把一些简单的操作写成独立的子程序也非常有价值。
		3.	子程序可以按照其内聚性分为很多类，而你应该让大多数子程序具有功能上的内聚性，这是最佳的一种内聚性。
		4.	子程序的名字是它的质量的指示器。如果名字糟糕但恰如其分，那就说明这个子程序设计得很差劲。
			如果名字糟糕而且又不准确，那么它就反映不出程序是干什么的。
			不管怎样，糟糕的名字都意味着程序需要修改。
		5.	只有在某个子程序的主要目的是返回由其名字所描述的特定结果时，才应该使用函数。
		6.	细心的程序员会非常谨慎地使用宏，而且只在万不得已时才用。
	第8章 防范式编程
		防御式编程的主要思想是：
		子程序应该不因传入错误数据而被破坏，哪怕是由其他子程序产生的错误数据。
		处理非法数据：
		1.	检查所有来源于外部的数据的值。
		2.	检查子程序所有输入参数的值。
		3.	决定如何处理错误的输入数据。
		可以用断言检查：
		1.	输入参数或输出参数的取值处于预期的范围内。
		2.	子程序开始（或者结束）执行时文件或流是处于打开（或关闭）的状态。
		3.	子程序开始（或者结束）执行时，文件或流的读写位置处于开头（或结尾）处。
		4.	文件或流已用只读、只写或可读可写方式打开。
		5.	仅用于输入的变量的没有被子程序所修改。
		6.	指针非空。
		7.	传入子程序的数组或其他容器至少能容纳X个数据元素。
		8.	表已初始化，存储着真实的数值。
		9.	一个经过高度优化的复杂子程序的运算结果和相对缓慢但代码清晰的子程序的运算结果相一致。
		使用断言的指导建议：
		1.	用错误处理代码来处理预期会发生的状况，用断言来处理绝不应该发生的状况。
		2.	避免把需要执行的代码放在断言中。
		3.	用断言来注解并验证前条件和后条件。
		4.	对于高健壮性的代码，应该先使用断言再处理错误。
		错误处理技术：
		1.	返回中立值。
		2.	换用下一个正确的数据。
		3.	返回与前次相同的数据。
		4.	抵用最接近的合法值。
		5.	把警告信息记录到日志文件中。
		6.	返回一个错误码。
		7.	调用错误处理子程序或对象。
		8.	当错误发生时显示出错消息。
		9.	用最妥当的方式在局部处理错误。
		10.	关闭程序。
		异常：
		1.	用异常通知程序的其他部分，发生了不可忽略的错误。
		2.	只在真正例外的情况下才抛出异常。
		3.	不能用异常来推卸责任。
		4.	在恰当的抽象层次抛出异常。
		5.	在异常消息中加入关于导致异常发生的全部信息。
		6.	避免使用空的catch语句。
		7.	了解所用函数库可能抛出的异常。
		8.	考虑创建一个集中的异常报告机制。
		9.	把项目中对异常的使用标准化。
		进攻式编程：
		1.	确保断言语句使程序终止运行。不要让程序员养成坏习惯，一碰到已知问题就按回国键把它路过。
			让问题引起的麻烦越大越好，这样它才能被修复。
		2.	安全填充分配到的所有内存，这样可以让你检测内存分配错误。
		3.	安全填充已分配到的所有文件和流，这样可以让你排查出文件格式错误。
		4.	确保每一个case语句中的default分支或else分支都能产生严重错误（比如说让程序终止运行），或者至少让这些错误不会被忽视。
		5.	在删除一个对象之前把它填满垃圾数据。
		6.	让程序把它的错误日志文件用电子邮件发给你，这样你就能了解到在已发布的软件中还发生了哪些错误——如果这对于你所开发的软件适用的话。
		确定在产品代码中该保留多少防御式代码：
		1.	保留那些检查重要错误的代码。
		2.	去掉检查细微错误的代码。
		3.	去掉可以导致程序硬性崩溃的代码。
		4.	保留可以让程序稳妥地崩溃的代码。
		5.	为你的技术支持人员记录错误信息。
		6.	确认留在代码中的错误消息是友好的。
		要点：
		1.	最终产品代码中对错误的处理方式要比“垃圾进，垃圾出”复杂得多。
		2.	防御式编程技术可以让错误更容易发现、更容易修改，并减少错误对产品代码的破坏。
		3.	断言可以帮助人尽早发现错误，尤其是在大型系统和高可靠性的系统中，以及快速变化的代码中。
		4.	关于如何处理错误输入的决策是一项关键的错误处理决策，也是一项关皱起宾高层设计决策。
		5.	异常提供了一种与代码正常流程角度不同的错误处理手段。
			如果留心使用异常，它可以成为程序员们知识工具箱中的一项有益补充，同时也应该在异常和其他错误处理手段之间进行权衡比较。
		6.	针对产品代码的限制并不适用于开发中的软件。你可以复用这一优势在开发中添加有助于更快地排查错误的代码。
	第9章 伪代码编程过程		
		子程序的质量标准：
		1.	检查子程序的接口。
		2.	检查整体的设计质量。
		3.	检查子程序中的变量。
		4.	检查子程序的语句和逻辑。
		5.	检查子程序的布局。
		6.	检查子程序的文档。
		7.	除去冗余的注释。
		要点：
		1.	创建类和子程序通常都是一个迭代的过程。在创建子程序的过程中获得的认识常常会反过来影响类的设计。
		2.	每一步完成后都要检查你的工作成果，还要鼓励其他人帮你来检查。
			这样你就会在投入精力最少的时候，用最低的成本发现错误。
第3部分 变量
	第10章 使用变量的一般事项
		变量初始化原则：
		1.	在声明变量的时候初始化。
		2.	在靠近变量第一次使用的位置初始化它。
		3.	理想情况下，在靠近第一次使用变量的位置声明和定义该变量。
		4.	在可能的情况下使用final或者const。
		5.	特别注意计数器和累加器。
		6.	在类的构造函数里初始化该类的数据成员。
		7.	检查是否需要重新初始化。
		8.	一次性初始化具名常量：可用执行代码来初始化变量。
		9.	使用编译器设置来自动初始化所有变量。
		10.	利用编译器的警告信息。
		11.	检查输入参数的合法性。
		12.	使用内存访问检查工具来检查错误的指针。
		13.	在程序开始时初始化工作内存。
		减少作用域的一般原则：
		1.	在循环开始之前再去初始化该循环里使用的变量，而不是在该循环所属的子程序的开始处初始化这些变量。
		2.	直到变量即将被使用时再为其赋值。
		3.	把相关语句放在一起。
		4.	把相关语句组提取成单独的子程序。
		5.	开始时采用最严格的可见性，然后根据需要扩展变量的作用域。
		要点：
		1.	数据初始化过程很容易出错，所以请用本章描述的初始化方法来避免由于非预期的初始值而造成的错误。
		2.	最小化每个变量的作用域。把同一变量的引用点集中在一起。把变量限定在子程序或类的范围之内。避免使用全局数据。
		3.	把使用相同变量的语句尽可能集中在一起。
		4.	早期绑定会减低灵活性，但有助于减少复杂度。晚期绑定可以增加灵活性，同时增加复杂度。
		5.	把每个变量用于唯一的用途。

