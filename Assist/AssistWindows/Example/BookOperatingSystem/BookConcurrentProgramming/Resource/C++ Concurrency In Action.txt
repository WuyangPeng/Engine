C++ 并发编程实战（C++ Concurrency In Action）

官方网站：    
http://www.manning.com/CPlusPlusConcurrencyinAction

★★★
作者：Anthony Williams

知识点 
1.	并发编程基础知识。 

致谢
前言
	路线图
	谁应该阅读本书
	如何使用本书
	代码约定和下载
	软件需求
	作者在线
资源
第1章 你好，C++并发世界  
	1.1 什么是并发  
		1.1.1 计算机系统中的并发  
		1.1.2 并发的途径  
	1.2 为什么使用并发  
		1.2.1 为了划分关注点而使用并发  
		1.2.2 为了性能而使用并发  
		1.2.3 什么时候不使用并发  
	1.3 在C++中使用并发和多线程  
		1.3.1 C++多线程历程  
		1.3.2 新标准中的并发支持  
		1.3.3 C++线程库的效率  
		1.3.4 平台相关的工具  
	1.4 开始入门  
	1.5 小结  
第2章 管理线程  
	2.1 基本线程管理  
		2.1.1 启动线程  
		2.1.2 等待线程完成  
		2.1.3 在异常环境下的等待  
		2.1.4 在后台运行线程  
	2.2 传递参数给线程函数  
	2.3 转移线程的所有权  
	2.4 在运行时选择线程数量  
	2.5 标识线程  
	2.6 小结  
第3章 在线程间共享数据  
	3.1 线程之间共享数据的问题  
		3.1.1 竞争条件  
		3.1.2 避免有问题的竞争条件  
	3.2 用互斥元保护共享数据  
		3.2.1 使用C++中的互斥元  
		3.2.2 为保护共享数据精心组织代码  
		3.2.3 发现接口中固有的竞争条件  
		3.2.4 死锁：问题和解决方案  
		3.2.5 避免死锁的进一步指南  
		3.2.6 用std::unique_lock灵活锁定  
		3.2.7 在作用域之间转移锁的所有权  
		3.2.8 锁定在恰当的粒度  
	3.3 用于共享数据保护的替代工具  
		3.3.1 在初始化时保护共享数据  
		3.3.2 保护很少更新的数据结构  
		3.3.3 递归锁  
	3.4 小结  
第4章 同步并发操作  
	4.1 等待事件或其他条件  
		4.1.1 用条件变量等待条件  
		4.1.2 使用条件变量建立一个线程安全队列  
	4.2 使用future等待一次性事件  
		4.2.1 从后台任务中返回值  
		4.2.2 将任务与future相关联  
		4.2.3 生成std::promise  
		4.2.4 为future保存异常  
		4.2.5 等待自多个线程  
	4.3 有时间限制的等待  
		4.3.1 时钟  
		4.3.2 时间段  
		4.3.3 时间点  
		4.3.4 接受超时的函数  
	4.4 使用操作同步来简化代码  
		4.4.1 带有future的函数式编程  
		4.4.2 具有消息传递的同步操作  
	4.5 小结  
第5章 C++内存模型和原子类型上操作  
	5.1 内存模型基础  
		5.1.1 对象和内存位置  
		5.1.2 对象、内存位置以及并发  
		5.1.3 修改顺序  
	5.2 C++中的原子操作及类型  
		5.2.1 标准原子类型  
		5.2.2 std::atomic_flag上的操作  
		5.2.3 基于std::atomicbool的操作  
		5.2.4 std::atomicT*上的操作：指针算术运算  
		5.2.5 标准原子整型的操作  
		5.2.6 std::atomic初级类模板  
		5.2.7 原子操作的自由函数  
	5.3 同步操作和强制顺序  
		5.3.1 synchronizes-with关系  
		5.3.2 happens-before关系  
		5.3.3 原子操作的内存顺序  
		5.3.4 释放序列和synchronizes-with  
		5.3.5 屏障  
		5.3.6 用原子操作排序非原子操作  
	5.4 小结  
第6章 设计基于锁的并发数据结构  
	6.1 为并发设计的含义是什么  
	6.2 基于锁的并发数据结构  
		6.2.1 使用锁的线程安全栈  
		6.2.2 使用锁和条件变量的线程安全队列  
		6.2.3 使用细粒度锁和条件变量的线程安全队列  
	6.3 设计更复杂的基于锁的数据结构  
		6.3.1 编写一个使用锁的线程安全查找表  
		6.3.2 编写一个使用锁的线程安全链表  
	6.4 小结  
第7章 设计无锁的并发数据结构  
	7.1 定义和结果  
		7.1.1 非阻塞数据结构的类型  
		7.1.2 无锁数据结构  
		7.1.3 无等待的数据结构  
		7.1.4 无锁数据结构的优点与缺点  
	7.2 无锁数据结构的例子  
		7.2.1 编写不用锁的线程安全栈  
		7.2.2 停止恼人的泄漏：在无锁数据结构中管理内存  
		7.2.3 用风险指针检测不能被回收的结点  
		7.2.4 使用引用计数检测结点  
		7.2.5 将内存模型应用至无锁栈  
		7.2.6 编写不用锁的线程安全队列  
	7.3 编写无锁数据结构的准则  
		7.3.1 准则：使用std::memory_order_seq_cst作为原型  
		7.3.2 准则：使用无锁内存回收模式  
		7.3.3 准则：当心ABA问题  
		7.3.4 准则：识别忙于等待的循环以及辅助其他线程  
	7.4 小结  
第8章 设计并发代码  
	8.1 在线程间划分工作的技术  
		8.1.1 处理开始前在线程间划分数据  
		8.1.2 递归地划分数据  
		8.1.3 以任务类型划分工作  
	8.2 影响并发代码性能的因素  
		8.2.1 有多少个处理器  
		8.2.2 数据竞争和乒乓缓存  
		8.2.3 假共享  
		8.2.4 数据应该多紧密  
		8.2.5 过度订阅和过多的任务切换  
	8.3 为多线程性能设计数据结构  
		8.3.1 为复杂操作划分数组元素  
		8.3.2 其他数据结构中的数据访问方式  
	8.4 为并发设计时的额外考虑  
		8.4.1 并行算法中的异常安全  
		8.4.2 可扩展性和阿姆达尔定律  
		8.4.3 用多线程隐藏延迟  
		8.4.4 用并发提高响应性  
	8.5 在实践中设计并发代码  
		8.5.1 std::for_each的并行实现  
		8.5.2 std::find的并行实现  
		8.5.3 std::partial_sum的并行实现  
	8.6 总结  
第9章 高级线程管理  
	9.1 线程池  
		9.1.1 最简单的线程池  
		9.1.2 等待提交给线程池的任务  
		9.1.3 等待其他任务的任务  
		9.1.4 避免工作队列上的竞争  
		9.1.5 工作窃取  
	9.2 中断线程  
		9.2.1 启动和中断另一个线程  
		9.2.2 检测一个线程是否被中断  
		9.2.3 中断等待条件变量  
		9.2.4 中断在std::condition_variable_any上的等待  
		9.2.5 中断其他阻塞调用  
		9.2.6 处理中断  
		9.2.7 在应用退出时中断后台任务  
	9.3 总结  
第10章 多线程应用的测试与调试  
	10.1 并发相关错误的类型  
		10.1.1 不必要的阻塞  
		10.1.2 竞争条件  
	10.2 定位并发相关的错误的技巧  
		10.2.1 审阅代码以定位潜在的错误  
		10.2.2 通过测试定位并发相关的错误  
		10.2.3 可测试性设计  
		10.2.4 多线程测试技术  
		10.2.5 构建多线程的测试代码  
		10.2.6 测试多线程代码的性能  
	10.3 总结  
附录A 附录A C++11部分语言特性简明参考  
附录B 并发类库简要对比
附录C 消息传递框架与完事的ATM示例
附录D C++线程类库参考