C++ 编程思想（Thinking in C++）
（第2版）

官方网站 
http://www.BruceEckel.com 、https://www.mindviewllc.com/ 、http://www.MindView.net/ （已失效）。

编译器：
https://digitalmars.com/、 http://gcc.gnu.org/ 。

编译工具：
http://www.cygwin.com/、 http://www.gnu.org/software/make/。

第1卷 标准C++引导（Volume One:Introduction to Standard C++）
★★
作者：Bruce Eckel。
其他书籍：《Java 编程思想》、《Scala编程思想》。

知识点
1. C++基础知识。
2. C++基础知识练习。
3. makefile文件的编写（3.11）。
4. 编程准则（附录B）。

代码
1.  书籍代码。
2.  练习代码。
3.  Thinking in C代码。

要点
1.  不能把默认参数作为一个标志去决定执行函数的哪一块。
    在这种情况下，就应该把函数成两个或多个重载的函数（7.6 小结）。
2.	头文件被包含的顺序是从“最特殊到最一般”。在本地目录中的任何头文件首先被包含，
	然后是我们自己的所有“工具”头文件，随后是第三方库头文件，接着是标准C++库头文件和C库头文件（附录A）。
3.	用数据成员表示值的变化，用虚函数表示行为的变化（附录B）。
4.	用值来抛出异常，用引用来捕获异常（附录B）。
5.	充分复用编译器的错误检查功能，用完全警告方式编译我们的全部代码，修改我们的代码，直到消除所有的警告为止（附录B）。
6.	宁可犯编译错误也不要犯运行错误（附录B）。
7.	建立一个用户定义的terminate()函数来记录引起异常的错误，然后释放系统资源，并退出程序（附录B）。
8.	如果一个析构函数调用了任何函数，这些函数都可能抛出异常。一个析构函数不能抛出异常。
	所以任何调用了其他函数的析构函数都应该捕获和管理它自己的异常（附录B）。
9.	不要重载全局new和delete，可以在类的基础上去重载它们（附录B）。

前言
	★ 像任何人类语言一样，C++提供了一种表达思想的方法。如果这种表达方法是成功的，那么当问题变得更大和更复杂时，该方法将会明显地表现出比其他方法更容易和更灵活的优点。
	★ 读者就当在头脑中建立一个模型，以便逐步理解这种语言，直到炉火纯青的程度。
	★ 用C++进行思考。
	0.1 第2版中的新内容
		0.1.1 第2卷的内容是什么
		0.1.2 如何得到第2卷
	0.2 预备知识
	0.3 学习C++
	0.4 目标
	0.5 各章概要
		★	C++被认为是混合的面向对象的编程语言。
	0.6 练习
		0.6.1 练习的答案
	0.7 源代码
	0.8 语言标准
		0.8.1 语言支持
	0.9 本书的CD ROM
	0.10 CD ROM、课堂讨论和咨询
	0.11 错误
	0.12 关于封面
	0.13 感谢
第1章 对象导言
	1.1 抽象的过程
	1.2 对象有一个接口
	1.3 实现的隐藏
	1.4 实现的重用
	1.5 继承 重用接口
		1.5.1 is-a关系和is-like-a关系
	1.6 具有多态性的可互换对象
	1.7 创建和销毁对象
	1.8 异常处理 应对错误
	1.9 分析和设计
		1.9.1 第0阶段 制定计划
			1.9.1.1 任务陈述
		1.9.2 第1阶段 我们在做什么
		1.9.3 第2阶段 我们将如何建立对象
			1.9.3.1 对象设计的五个阶段
			1.9.3.2 对象开发准则
		1.9.4 第3阶段 创建核心
		1.9.5 第4阶段 迭代用例
		1.9.6 第5阶段 进化
		1.9.7 计划的回报
	1.10 极限编程
		1.10.1 先写测试
		1.10.2 结对编程
	1.11 为什么C++会成功
		1.11.1 一个较好的C
		1.11.2 延续式的学习过程
		1.11.3 效率
		1.11.4 系统更容易静态和理解
		1.11.5 尽量使用库
		1.11.6 使用模板的源代码重用
		1.11.7 错误处理
		1.11.8 大型程序设计
	1.12 为向OOP转变而采取的策略
		1.12.1 指导方针
			1.12.1.1 训练
			1.12.1.2 低风险项目
			1.12.1.3 来自成功的模型
			1.12.1.4 使用已有的类库
			1.12.1.5 不要用C++重写已有的代码
		1.12.2 管理的障碍
			1.12.2.1 启动的代价
			1.12.2.2 性能问题
			1.12.2.3 常见的设计错误
	1.13 小结
第2章 对象的创建与使用
	2.1 语言的翻译过程
		2.1.1 解释器
		2.1.2 编译器
		2.1.3 编译过程
			2.1.3.1 静态类型检查
	2.2 分段编译工具
		2.2.1 声明与定义
			2.2.1.1 函数声2.1.2 编译器明的语法
			2.2.1.2 一点说明 
			2.2.1.3 函数的定义
			2.2.1.4 变量声明的语法
			2.2.1.5 包含头文件
			2.2.1.6 标准C++ include语句格式
		2.2.2 连接
		2.2.3 使用库文件
			2.2.3.1 连接器如何查找库
			2.2.3.2 秘密的附加模块
			2.2.3.3 使用简单的C语言库
	2.3 编写第一个C++程序
		2.3.1 使用iostream类
		2.3.2 名字空间
		2.3.3 程序的基本结构
		2.3.4 “Hello,World!”
		2.3.5 运行编译器
	2.4 关于输入输出流
		2.4.1 字符数组的拼接
		2.4.2 读取输入数据
		2.4.3 调用其他程序
	2.5 字符串简介
	2.6 文件的读写
	2.7 vector简介
	2.8 小结
	2.9 练习
第3章 C++中的C
	3.1 创建函数
		3.1.1 函数的返回值
		3.1.2 使用C的函数库
		3.1.3 通过库管理器创建自己的库
	3.2 执行控制语句
		3.2.1 真和假
		3.2.2 if-else语句
		3.2.3 while语句
		3.2.4 do-while语句
		3.2.5 for语句
		3.2.6 关键字break和continue
		3.2.7 swi3.2.2 if-else语句tch语句
		3.2.8 使用和滥用goto
		3.2.9 递归
	3.3 运算符简介
		3.3.1 优先级
		3.3.2 自增和自减
	3.4 数据类型简介
		3.4.1 基本内部类型
		3.4.2 bool类型与true和false
		3.4.3 说明符
		3.4.4 指针简介
		3.4.5 修改外部对象
		3.4.6 C++引用简介
		3.4.7 用指针和引用作为修饰符
	3.5 作用域
	3.6 指定存储空间分配
		3.6.1 全局变量
		3.6.2 局部变量
			3.6.2.1 寄存器变量
		3.6.3 静态变量
		3.6.4 外部变量
			3.6.4.1 连接
		3.6.5 变量
			3.6.5.1 常量值
		3.6.6 volatlle变量
	3.7 运算符及其作用
		3.7.1 赋值
		3.7.2 数学运算符
			3.7.2.1 预处理宏介绍
		3.7.3 关系运算符
		3.7.4 逻辑运算符
		3.7.5 位运算符
		3.7.6 移位运算符
		3.7.7 一元运算符
		3.7.8 三元运算符
		3.7.9 逗号运算符
		3.7.10 使用运算符时的常见问题
		3.7.11 转换运算符
		3.7.12 C++的显示转换
			3.7.12.1 静态转换（static_cast）
			3.7.12.2 常量转换（const_cast）
			3.7.12.3 重解释转换（reinterpret_cast）
		3.7.13 sizeof——独立运算符
		3.7.14 asm关键字
		3.7.15 显示运算符
	3.8 创建复合类型
		3.8.1 用typedef命名别名
		3.8.2 用struct把变量结合在一起
			3.8.2.1 指针和struct
		3.8.3 用enum提高程序清晰度
			3.8.3.1 枚举类型检查
		3.8.4 用union节省内存
		3.8.5 数组
			3.8.5.1 指针和数组
			3.8.5.2 探究浮点格式
			3.8.5.3 指针算术
	3.9 调试技巧
		3.9.1 调试标记
			3.9.1.1 预处理器调试标记
			3.9.1.2 运行期调试标记
		3.9.2 把变量和表达式转换成字符串
		3.9.3 C语言assert()宏
	3.10 函数地址
		3.10.1 定义函数指针
		3.10.2 复杂的声明和定义
		3.10.3 使用函数指针
		3.10.4 指向函数的指针数组
	3.11 make 管理分段编译
		3.11.1 make的行为
			3.11.1.1 宏
			3.11.1.2 后缀规则
			3.11.1.3 默认目标
		3.11.2 本书中的makefile
		3.11.3 makefile的一个例子
	3.12 小结
	3.13 练习
第4章 数据抽象
	4.1 一个袖珍C库
		4.1.1 动态存储分配
		4.1.2 有害的猜测
	4.2 哪儿出问题
	4.3 基本对象
	4.4 什么是对象
	4.5 抽象数据类型
	4.6 对象细节
	4.7 头文件形式
		4.7.1 头文件的重要性
		4.7.2 多次声明问题
		4.7.3 预处理器指示#define、#ifdef和#endif
		4.7.4 头文件的标准
		4.7.5 头文件中的名字空间
		4.7.6 在项目中使用头文件
	4.8 嵌套结构
		4.8.1 全局作用域解析
	4.9 小结
	4.10 练习
第5章 隐藏实现
	5.1 设置限制
	5.2	C++的访问控制
		5.2.1 protected说明符
	5.3 友元
		5.3.1 嵌套友元
		5.3.2 它是纯面向对象的吗
	5.4 对象布局
	5.5 类
		5.5.1 用访问控制来修改Stash
		5.5.2 用访问控制来修改Stack
	5.6 句柄类
		5.6.1 隐藏实现
		5.6.2 减少重复编译
	5.7 小结
	5.8 练习
第6章 初始化与清除
	6.1 用构造函数确保初始化
	6.2 用析构函数确保清除
	6.3 清除定义块
		6.3.1 for循环
		6.3.2 内存分配
	6.4 带有构造函数和析构函数的Stash
	6.5 带有构造函数和析构函数的Stack
	6.6 集合初始化
	6.7 默认构造函数
	6.8 小结
	6.9 练习
第7章 函数重载与默认参数
	7.1 名字修饰
		7.1.1 用返回值重载
		7.1.2 类型安全连接
	7.2 重载的例子
	7.3 联合
	7.4 默认参数
		7.4.1 占位符参数
	7.5 选择重载还是默认参数
	7.6 小结
	7.7 练习
第8章 常量
	8.1 值替代
		8.1.1 头文件里的const
		8.1.2 const的安全性
		8.1.3 集合
		8.1.4 与C语言的区别
	8.2 指针
		8.2.1 指向const的指针
		8.2.2 const指针
		8.2.3 赋值和类型检查
	8.3 函数参数和返回值
		8.3.1 传递const值
		8.3.2 返回const值
			8.3.2.1 临时量
		8.3.3 传递和返回地址
			8.3.3.1 标准参数传递
	8.4 类
		8.4.1 类里的const
			8.4.1.1 构造函数初始化列表
			8.4.1.2 内部类型的“构造函数”
		8.4.2 编译期间类里的常量
			8.4.2.1 旧代码中的“enum hack”
		8.4.3 const对象和成员函数
			8.4.3.1 可变的 按位const和按逻辑const
			8.4.3.2 可读存储能力
	8.5 volatile
	8.6 小结
	8.7 练习
第9章 内联函数
	9.1 预处理器的缺陷
		9.1.1 宏和访问
	9.2 内联函数
		9.2.1 类内部的内联函数
		9.2.2 访问函数
			9.2.2.1 访问器和修改器
	9.3 带内联函数的Stash和Stack
	9.4 内联函数和编译器
		9.4.1 限制
		9.4.2 向前引用
		9.4.3 在构造函数和析构函数里隐藏行为
	9.5 减少混乱
	9.6 预处理器的更多特征
		9.6.1 标志粘贴
	9.7 改进的错误检查
	9.8 小结
	9.9 练习
第10章 名字控制
	10.1 来自C语言中的静态元素
		10.1.1 函数内部的静态变量
			10.1.1.1 函数内部的静态对象
			10.1.1.2 静态对象的析构函数
		10.1.2 控制连接
		10.1.3 其他存储类型说明符
	10.2 名字空间
		10.2.1 创建一个名字空间
			10.2.1.1 未命名的名字空间
			10.2.1.2 友元
		10.2.2 使用名字空间
			10.2.2.1 作用域解析
			10.2.2.2 使用指令
			10.2.2.3 使用声明
		10.2.3 名字空间的使用
	10.3 C++中的静态成员
		10.3.1 定义静态数据成员的存储
			10.3.1.1 静态数组的初始化
		10.3.2 嵌套类和局部类
		10.3.3 静态成员函数
	10.4 静态初始化的相依性
		10.4.1 怎么办
			10.4.1.1 技术一
			10.4.1.2 技术二
	10.5 替代连接说明
	10.6 小结
	10.7 练习
第11章 引用和拷贝构造函数
	11.1 C++中的指针
	11.2 C++中的引用
		11.2.1 函数中的引用
			11.2.1.1 常量引用
			11.2.1.2 指针引用
		11.2.2 参数传递准则
	11.3 拷贝构造函数
		11.3.1 按值传递和返回
			11.3.1.1 传递和返回大对象
			11.3.1.2 函数调用栈框架
			11.3.1.3 重入
			11.3.1.4 位拷贝与初始化
		11.3.2 拷贝构造函数
			11.3.2.1 临时对象
		11.3.3 默认拷贝构造函数
		11.3.4 替代拷贝构造函数的方法
			11.3.4.1 防止按值传递
			11.3.4.2 改变外部对象的函数
	11.4 指向成员的指针
		11.4.1 函数
			11.4.1.1 一个例子
	11.5 小结
	11.6 练习
第12章 运算符重载
	12.1 两个极端
	12.2 语法
	12.3 可重载的运算符
		12.3.1 一元运算符
			12.3.1.1 自增和自减
		12.3.2 二元运算符
		12.3.3 参数和返回值
			12.3.3.1 作为常量通过传值方式返回
			12.3.3.2 返回值优化
		12.3.4 不常用的运算符
			12.3.4.1 operator,
			12.3.4.2 operator->
			12.3.4.3 嵌入的迭代器
			12.3.4.4 operator->*
		12.3.5 不能重载的运算符
	12.4 非成员运算符
		12.4.1 基本方针
	12.5 重载赋值符
		12.5.1 operator=的行为
			12.5.1.1 类中指针
			12.5.1.2 引用计数
			12.5.1.3 自动创建operator=
	12.6 自动类型转换
		12.6.1 构造函数转换
			12.6.1.1 阻止构造函数转换
		12.6.2 运算符转换
			12.6.2.1 反身性
		12.6.3 类型转换例子
		12.6.4 自动类型转换的缺陷
			12.6.4.1 隐藏的行为
	12.7 小结
	12.8 练习
第13章 动态对象创建
	13.1 对象创建
		13.1.1 C从堆中获取存储单元的方法
		13.1.2 operator new
		13.1.3 operator delete
		13.1.4 一个简单的例子
		13.1.5 内存管理的开销
	13.2 重新设计前面的例子
		13.2.1 使用delete void*可能会出错
		13.2.2 对指针的清除责任
		13.2.3 指针的Stash
			13.2.3.1 一个测试程序
	13.3 用于数组的new和delete
		13.3.1 使指针更像数组
	13.4 耗尽内存
	13.5 重载new和delete
		13.5.1 重载全局new和delete
		13.5.2 对于一个类重载new和delete
		13.5.3 为数组重载new和delete
		13.5.4 构造函数调用
		13.5.5 定位new和delete
	13.6 小结
	13.7 练习
第14章 继承和组合
	14.1 组合语法
	14.2 继承语法
	14.3 构造函数的初始化表达式表
		14.3.1 成员对象初始化
		14.3.2 在初始化表达式表中的内部类型
	14.4 组合和继承的联合
		14.4.1 构造函数和析构函数调用的次序
	14.5 名字隐藏
	14.6 非自动继承的函数
		14.6.1 继承和静态成员函数
	14.7 组合与继承的选择
		14.7.1 子类型设置
		14.7.2 私有继承
	14.8 protected
		14.8.1 protected继承
	14.9 运算符的重载与继承
	14.10 多重继承
	14.11 渐增式开发
	14.12 向上类型转换
		14.12.1 为什么要“向上类型转换”
		14.12.2 向上类型转换和拷贝构造函数
		14.12.3 组合与继承（再论）
		14.12.4 指针和引用的向上类型转换
		14.12.5 危机
	14.13 小结
	14.14 练习
第15章 多态性和虚函数
	15.1 C++程序员的演变
	15.2 向上类型转换
	15.3 问题
		15.3.1 函数调用捆绑
	15.4 虚函数
		15.4.1 扩展性
	15.5 C++如何实现晚捆绑
		15.5.1 存放类型信息
		15.5.2 虚函数功能图示
		15.5.3 撩开面纱
		15.5.4 安装vpointer
		15.5.5 对象是不同的
	15.6 为什么需要虚函数
	15.7 抽象基类和纯虚函数
		15.7.1 纯虚定义
	15.8 继承和VTABLE
		15.8.1 对象切片
	15.9 重载和重新定义
		15.9.1 变量返回类型
	15.10 虚函数和构造函数
		15.10.1 构造函数调用次序
		15.10.2 虚函数在构造函数中的行为
	15.11 析构函数和虚拟析构函数
		15.11.1 纯虚析构函数
		15.11.2 析构函数中的虚机制
		15.11.3 创建基于对象的继承
	15.12 运算符重载
	15.13 向下类型转换
	15.14 小结
	15.15 练习
第16章 模板介绍
	16.1 容器
		16.1.1 容器的需求
	16.2 模板综述
		16.2.1 模板方法
	16.3 模板语法 
		16.3.1 非内联函数定义
			16.3.1.1 头文件
		16.3.2 作为模板的IntStack
		16.3.3 模板中的常量 
	16.4 作为模板的Stash和Stack
		16.4.1 模板化的指针Stash
	16.5 打开和关闭所有权
	16.6 以值存放对象
	16.7 迭代器简介
		16.7.1 带有迭代器的栈
		16.7.2 带有迭代器的PStash
	16.8 为什么使用迭代器
		16.8.1 函数模板
	16.9 小结
	16.10 练习
附录A 编码风格
	A.1 常规
	A.2 文件名
	A.3 开始和结束注释标记
	A.4 圆括号、大括号和缩排
	A.5 标识符名
	A.6 头文件的包含顺序
	A.7 在头文件上包含警卫
	A.8 使用名字空间
	A.9 require()和assure()的使用
附录B 编程准则
附录C 推荐读物
	C.1 C
	C.2 基本C++
		C.2.1 我自己的书
	C.3 深入研究和死角分析
	C.4 分析和设计
索引

第2卷 实用编程技术（Volume Two:Practical Programming）
★★☆
作者：Bruce Eckel、Chuck Allison。
其他书籍：Bruce Eckel《Java 编程思想》、《Scala编程思想》，Chuck Allison《C和C++代码精粹》。
 
知识点
1.	C++标准库知识。
2.	C++练习。
3.	一个简单的单元测试框架（2.2）。
4.	设计模式（第10章）。
5.	并发（第11章）。
6.	依赖库ZThread。

代码
1.  书籍代码。

要点
1.	什么时候避免异常：（1）不要在异步事件中使用异常。（2）不要在处理简单错误的时候使用异常。
	（3）不要将异常用于程序的流程控制。（4）不要强迫自己使用异常。（5）新异常，老代码（1.9 在编程中使用异常）。
2.	只要能用，就做最简单的（10.15 小结）。

前言
	目标
	各章简介
		★ 决定采用异常处理机制是影响代码设计向良性方向发展的重要方法。
	练习
	源代码
	编译器
	语言标准
	研讨班和咨询
	错误
	关于封面
	致谢
第一部分 建立稳定的系统
	第1章 异常处理
		1.1 传统的错误处理
		1.2 抛出异常
		1.3 捕获异常
			1.3.1 try块
			1.3.2 异常处理器
			1.3.3 终止和恢复
		1.4 异常匹配
			1.4.1 捕获所有异常
			1.4.2 重新抛出异常
			1.4.3 不捕获异常 
		1.5 清理
			1.5.1 资源管理
			1.5.2 使所有事物都成为对象
			1.5.3 auto_ptr
			1.5.4 函数级的try块
		1.6 标准异常
		1.7 异常规格说明 
			1.7.1 更好的异常规格说明
			1.7.2 异常规格说明和继承
			1.7.3 什么时候不使用异常规格说明
		1.8 异常安全
		1.9 在编程中使用异常
			1.9.1 什么时候避免异常
			1.9.2 异常的典型应用
		1.10 使用异常造成的开销
		1.11 小结
		1.12 练习
	第2章 防御性编程
		2.1 断言
		2.2 一个简单的单元测试框架
			2.2.1 自动测试
			2.2.2 TestSuite框架
			2.2.3 测试套件
			2.2.4 测试框架的源代码
		2.3 调试技术
			2.3.1 用于代码跟踪的宏
			2.3.2 跟踪文件
			2.3.3 发现内存泄漏
		2.4 小结
		2.5 练习
第二部分 标准C++库
	第3章 深入理解字符串
		3.1 字符串的内部是什么
		3.2 创建并初始化C++字符串
		3.3 对字符串进行操作
			3.3.1 追加、插入和连接字符串
			3.2.2 替换字符串中的字符
			3.3.3 使用非成员重载运算符连接
		3.4 字符串的查找
			3.4.1 反射查找
			3.4.2 查找一组字符第1次或最后一次出现的位置
			3.4.3 从字符串中删除字符
			3.4.4 字符串的比较
			3.4.5 字符串和字符的特性
		3.5 字符串的应用
		3.6 小结
		3.7 练习
	第4章 输入输出流
		4.1 为什么引入输入输出流
		4.2 救助输入输出流
			4.2.1 插入符和提取符
			4.2.2 通常用法
			4.2.3 按行输入
		4.3 处理流错误
		4.4 文件输入输出流
			4.4.1 一个文件处理的例子
			4.4.2 打开模式
		4.5 输入输出流缓冲
		4.6 在输入输出流中定位
		4.7 字符串输入输出流
			4.7.1 输入字符串流
			4.7.2 输出字符串流
		4.8 输出流的格式化
			4.8.1 格式化标志
			4.8.2 格式化域
			4.8.3 宽度、填充和精度设置
			4.8.4 一个完整的例子
		4.9 操纵算子
			4.9.1 带参数的操纵算子
			4.9.2 创建操纵算子
			4.9.3 效用算子
		4.10 输入输出流程序举例
			4.10.1 维护类库的源代码
			4.10.2 检测编译器错误
			4.10.3 一个简单的数据记录器
		4.11 国际化
			4.11.1 宽字符流
			4.11.2 区域性字符流
		4.12 小结
		4.13 练习
	第5章 深入理解模板
		5.1 模板参数
			5.1.1 无类型模板参数
			5.1.2 默认模板参数
			5.1.3 模板类型的模板参数
			5.1.4 typename关键字
			5.1.5 以template关键字作为提示
			5.1.6 成员模板
		5.2 有关函数模板的几个问题
			5.2.1 函数模板参数的类型推断
			5.2.2 函数模板重载
			5.2.3 以一个已生成的函数模板地址作为参数
			5.2.4 将函数应用到STL序列容器中
			5.2.5 函数模板的半有序
		5.3 模板特化
			5.3.1 显式特化
			5.3.2 半特化
			5.3.3 一个实例
			5.3.4 防止模板代码膨胀
		5.4 名称查找问题
			5.4.1 模板中的名称
			5.4.2 模板和友元
		5.5 模板编程中的习语
			5.5.1 特征
			5.5.2 策略
			5.5.3 奇特的递归模板模式
		5.6 模板元编程
			5.6.1 编译时编程
			5.6.2 表达式模板
		5.7 模板编译模型
			5.7.1 包含模型
			5.7.2 显式实例化
			5.7.3 分离模型
		5.8 小结
		5.9 练习
	第6章 通用算法
		6.1 概述
			6.1.1 判定函数
			6.1.2 流迭代器
			6.1.3 算法复杂性
		6.2 函数对象
			6.2.1 函数对象的分类
			6.2.2 自动创建函数对象
			6.2.3 可调整的函数对象
			6.2.4 更多的函数对象例子
			6.2.5 函数指针适配器
			6.2.6 编写自己的函数对象适配器
		6.3 STL算法目录
			6.3.1 实例创建的支持工具
			6.3.2 填充和生成
			6.3.3 计数
			6.3.4 操作序列
			6.3.5 查找和替换
			6.3.6 比较范围
			6.3.7 删除元素
			6.3.8 对已排序的序列进行排序和运算
			6.3.9 堆运算
			6.3.10 对某一范围内的所有元素进行运算
			6.3.11 数值算法
			6.3.12 通用实用程序
		6.4 创建自己的STL风格算法
		6.5 小结
		6.6 练习
	第7章 通用容器
		7.1 容器和迭代器
		7.2 概述
			7.2.1 字符串容器
			7.2.2 从STL容器继承
		7.3 更多迭代器
			7.3.1 可逆容器中的迭代器
			7.3.2 迭代器的种类
			7.3.3 预定义迭代器
		7.4 基本序列容器 vector、list和deque
			7.4.1 基本序列容器的操作
			7.4.2 向量
			7.4.3 双端队列
			7.4.4 序列容器间的转换
			7.4.5 被检查的随机访问
			7.4.6 链表
			7.4.7 交换序列
		7.5 集合 
		7.6 堆栈
		7.7 队列
		7.8 优先队列
		7.9 持有二进制位
			7.9.1 bitset<n>
			7.9.2 vector<bool>
		7.10 关联式容器
			7.10.1 用于关联式容器的发生器和填充器
			7.10.2 不可思议的映像
			7.10.3 多重映像和重复的关键字
			7.10.4 多重集合
		7.11 将STL容器联合使用
		7.12 清除容器的指针
		7.13 创建自己的容器
		7.14 对STL的扩充
		7.15 非STL容器
		7.16 小结
		7.17 练习
第三部分 专题
	第8章 运行时类型识别
		8.1 运行时类型转换
		8.2 typeid 操作符
			8.2.1 类型转换到中间层次类型
			8.2.2 void型指针
			8.2.3 运用带模板的RTTI
		8.3 多重继承
		8.4 合理使用RTTI
		8.5 RTTI的机制和开销
		8.6 小结
		8.7 练习
	第9章 多重继承
		9.1 概论
		9.2 接口继承
		9.3 实现继承
		9.4 重复子对象
		9.5 虚基类
		9.6 名字查找问题
		9.7 避免使用多重继承
		9.8 扩充一个接口
		9.9 小结
		9.10 练习
	第10章 设计模式
		10.1 模式的概念
		10.2 模式分类
		10.3 简化习语
			10.3.1 信使
			10.3.2 收集参数
		10.4 单件
		10.5 命令 选择操作
		10.6 消除对象耦合
			10.6.1 代理模式 作为其他对象的前端
			10.6.2 状态模式 改变对象的行为
		10.7 适配器模式
		10.8 模板方法模式
		10.9 策略模式 运行时选择算法
		10.10 职责链模式 尝试采用一系列策略模式
		10.11 工厂模式 封装对象的创建
			10.11.1 多态工厂
			10.11.2 抽象工厂
			10.11.3 虚构造函数
		10.12 构建器模式 创建复杂对象
		10.13 观察者模式
			10.13.1 “内部类”方法
			10.13.2 观察者模式举例
		10.14 多重派遣
		10.15 小结
		10.16 练习
	第11章 并发
		11.1 动机
		11.2 C++中的并发
		11.3 定义任务
		11.4 使用线程
			11.4.1 创建有响应有用户界面
			11.4.2 使用执行器简化工作
			11.4.3 让步
			11.4.4 休眠
			11.4.5 优先权
		11.5 共享有限资源
			11.5.1 保证对象的存在
			11.5.2 不恰当地访问资源
			11.5.3 访问控制
			11.5.4 使用保护简化编码
			11.5.5 线程本地存储
		11.6 终止任务
			11.6.1 防止输入/输出流冲突
			11.6.2 举例观赏植物园
			11.6.3 阻塞时终止
			11.6.4 中断
		11.7 线程间协作
			11.7.1 等待和信号
			11.7.2 生产者——消费者关系
			11.7.3 用队列解决线程处理的问题
			11.7.4 广播
		11.8 死锁
		11.9 小结
		11.10 练习
	附录
		附录A 推荐读物
			A.1 基本C++
				A.1.1 Bruce的书
				A.1.2 Chuck的书
			A.2 深入理解C++
			A.3 设计模式
		附录B 其他
		索引