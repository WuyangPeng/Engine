游戏编程模式（Game Programming Patterns）

★★★
作者 Robert Nystrom

官方网站 
https://www.ptpress.com.cn/shopping/buy?bookId=bbf95882-dea0-43ad-b798-efd6546f9748

第1篇 概述
	第1章 架构、性能和游戏
		1.1 什么是软件架构
			1.1.1 什么是好的软件架构
			1.1.2 你如何做出改变 
			1.1.3 我们如何从解耦中受益 
		1.2 有什么代价 
		1.3 性能和速度
		1.4 坏代码中的好代码 
		1.5 寻求平衡 
		1.6 简单性  
		1.7 准备出发  
第2篇 再探设计模式
	第2章 命令模式
		2.1 配置输入
		2.2 关于角色的说明 
		2.3 撤销和重做
		2.4 类风格化还是函数风格化
		2.5 参考 
	第3章 享元模式
		3.1 森林之树
		3.2 一千个实例 
		3.3 享元模式
		3.4 扎根之地
		3.5 性能表现如何
		3.6 参考 
	第4章 观察者模式
		4.1 解锁成就 
		4.2 这一切是怎么工作的
			4.2.1 观察者
			4.2.2 被观察者
			4.2.3 可被观察的物理模块
		4.3 它太慢了 
		4.4 太多的动态内存分配
			4.4.1 链式观察者
			4.4.2 链表节点池
		4.5 余下的问题
			4.5.1 销毁被观察者和观察者 
			4.5.2 不用担心，我们有GC
			4.5.3 接下来呢
		4.6 观察者模式的现状
		4.7 观察者模式的未来 
	第5章 原型模式
		5.1 原型设计模式
			5.1.1 原型模式效果如何
			5.1.2 生成器函数
			5.1.3 模板
			5.1.4 头等公民类型
		5.2 原型语言范式
			5.2.1 Self 语言
			5.2.2 结果如何
			5.2.3 JavaScript如何
		5.3 原型数据建模　 
	第6章 单例模式
		6.1 单例模式
			6.1.1 确保一个类只有一个实例
			6.1.2 提供一个全局指针以访问唯一实例　 
		6.2 使用情境　 
		6.3 后悔使用单例的原因
			6.3.1 它是一个全局变量　 
			6.3.2 它是个画蛇添足的解决方案　 
			6.3.3 延迟初始化剥离了你的控制　 
		6.4 那么我们该怎么做　 
			6.4.1 看你是否需要类　 
			6.4.2 将类限制为单一实例　 
			6.4.3 为实例提供便捷的访问方式　 
		6.5 剩下的问题　 
	第7章 状态模式
		7.1 我们曾经相遇过
		7.2 救星：有限状态机
		7.3 枚举和分支　
		7.4 状态模式　
			7.4.1 一个状态接口
			7.4.2 为每一个状态定义一个类　 
			7.4.3 状态委托　 
		7.5 状态对象应该放在哪里呢　
			7.5.1 静态状态　 
			7.5.2 实例化状态　 
		7.6 进入状态和退出状态的行为　
		7.7 有什么收获吗　 
		7.8 并发状态机　
		7.9 层次状态机　 
		7.10 下推自动机　 
		7.11 现在知道它们有多有用了吧　 
第3篇 序列型模式
	第8章 双缓冲
	第9章 游戏循环
	第10章 更新方法
第4篇 行为型模式
	第11章 字节码
	第12章 子类沙盒
	第13章 类型对象
第5篇 解耦型模式
	第14章 组件模式
	第15章 事件队列
	第16章 服务定位器
第6篇 优化型模式
	第17章 数据局部性
	第18章 脏标记模式
	第19章 对象池
	第20章 空间分区