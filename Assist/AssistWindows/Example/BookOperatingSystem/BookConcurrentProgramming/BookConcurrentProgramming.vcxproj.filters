<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="源文件">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="头文件">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="资源文件">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="资源文件\Todo">
      <UniqueIdentifier>{23d1b12f-af8d-48c2-a559-f983a36983cf}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book">
      <UniqueIdentifier>{732c0a11-24e7-4da4-ae4e-a4e05a39f43d}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）">
      <UniqueIdentifier>{7428553b-f3e4-43fa-9855-600dedab0b92}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）">
      <UniqueIdentifier>{706dbec1-5e87-421c-a9b3-0b480d8c74a5}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Parallel and Distributed Programming Using C++（C++ 并行与分布式编程）">
      <UniqueIdentifier>{076fdfa8-615d-4e73-a6d2-ccf5b6e8c5eb}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）">
      <UniqueIdentifier>{7ff66e67-3c36-47a4-bab9-2dc8ce7db74d}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）">
      <UniqueIdentifier>{9e8553fe-8288-4ac1-a83c-ca8b532de85b}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）">
      <UniqueIdentifier>{03210c41-6c1e-4357-b25e-f408b7b0c930}</UniqueIdentifier>
    </Filter>
    <Filter Include="Placeholder 头文件">
      <UniqueIdentifier>{57472c8b-b50d-4498-a6b7-d509d7026191}</UniqueIdentifier>
    </Filter>
    <Filter Include="Placeholder 源文件">
      <UniqueIdentifier>{e7cc3027-2d54-4916-a90d-1762a5daf0f7}</UniqueIdentifier>
    </Filter>
    <Filter Include="Helper 头文件">
      <UniqueIdentifier>{3374e439-2aa6-4be4-ae75-1416ada8d8d8}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\0.">
      <UniqueIdentifier>{dc125555-a406-4692-8289-9daed3c71dda}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\0.\0.1 序">
      <UniqueIdentifier>{df5f5dd0-4ad9-4a7a-b16b-7b969d4e192b}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\0.\0.2 前言">
      <UniqueIdentifier>{13ae03b4-ccab-40da-91dc-19fe69350925}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\0.\0.2 前言\0.2.1 本书的结构">
      <UniqueIdentifier>{65f023d9-9b40-4784-b4f4-4d2b848174eb}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\0.\0.2 前言\0.2.2 代码要求">
      <UniqueIdentifier>{e57e72b4-6ae9-44a9-842d-e2d060c11a69}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\0.\0.2 前言\0.2.3 致谢">
      <UniqueIdentifier>{a75e46fb-9032-40d3-8931-8cf61313153f}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\0.\0.2 前言\0.2.4 作者简介">
      <UniqueIdentifier>{ef39d2fa-74ce-4d06-a011-0097087029bf}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第1部分 概念">
      <UniqueIdentifier>{fc5a0079-8605-4e2a-9dc6-097f6f38a4cd}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第1部分 概念\第1章 概述">
      <UniqueIdentifier>{4c7cfd00-cb65-4e7f-a7dd-d51eefcbc04f}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第1部分 概念\第1章 概述\1.1 为什么需要并发">
      <UniqueIdentifier>{cdee55d4-b9a7-4ba8-afe9-eea33a1faccb}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第1部分 概念\第1章 概述\1.2 程序架构与并发">
      <UniqueIdentifier>{8ce25346-3002-455c-81fc-684f7322d0bc}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第1部分 概念\第1章 概述\1.3 并行的层次">
      <UniqueIdentifier>{37d76606-7485-40a7-a983-b17fbb82249a}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第1部分 概念\第1章 概述\1.4 为什么不需要并发">
      <UniqueIdentifier>{1ac55660-a6a5-4e28-b5e7-a6d808859ae6}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第1部分 概念\第1章 概述\1.5 小结">
      <UniqueIdentifier>{fa5fa7ec-1465-42b1-91b0-e6a5dedf2654}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第1部分 概念\第1章 概述\延伸阅读">
      <UniqueIdentifier>{8eb84ac9-eb4d-4a98-bc56-4be4cb95149f}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第1部分 概念\第2章 同步与时间">
      <UniqueIdentifier>{7e5b4cb5-275f-4db0-8a4c-2083aa88eacb}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第1部分 概念\第2章 同步与时间\2.1 程序状态的管理">
      <UniqueIdentifier>{b6ab97d3-906e-4b2e-9239-9d29cee77531}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第1部分 概念\第2章 同步与时间\2.1 程序状态的管理\2.1.1 共享状态与私有状态的区分">
      <UniqueIdentifier>{52f0f046-fb73-4081-b61c-eee21ecead76}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第1部分 概念\第2章 同步与时间\2.1 程序状态的管理\2.1.2 状态机与时间">
      <UniqueIdentifier>{264bea8b-9af8-4d6c-86ac-aee9e24936f5}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第1部分 概念\第2章 同步与时间\2.1 程序状态的管理\2.1.3 独立性">
      <UniqueIdentifier>{f699aff5-a084-4d1a-b07e-0e7ed1b3b7b2}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第1部分 概念\第2章 同步与时间\2.1 程序状态的管理\2.1.4 不变性">
      <UniqueIdentifier>{62481d89-0f40-4d16-b612-65590fc0407f}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第1部分 概念\第2章 同步与时间\2.2 同步：种类与实现技术">
      <UniqueIdentifier>{4e04e15a-ea0a-4c6d-a474-31db8984750c}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第1部分 概念\第2章 同步与时间\2.2 同步：种类与实现技术\2.2.1 数据同步">
      <UniqueIdentifier>{4b5f4463-6ec5-4735-b187-e4735fae24d3}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第1部分 概念\第2章 同步与时间\2.2 同步：种类与实现技术\2.2.2 协作与控制同步">
      <UniqueIdentifier>{7bbfcbdb-9e62-4ec8-876e-5a3c1c2b3480}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第1部分 概念\第2章 同步与时间\2.3 小结">
      <UniqueIdentifier>{d2c61fcc-e99f-4e36-87b5-a0396b82713a}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第1部分 概念\第2章 同步与时间\延伸阅读">
      <UniqueIdentifier>{c4d1eaf1-9983-474e-b9b2-121d34610562}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第2部分 机制">
      <UniqueIdentifier>{72dcb934-e6f3-4eae-a688-245e73dad999}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第2部分 机制\第3章 线程">
      <UniqueIdentifier>{1e2c0248-24fc-4b94-ac44-c3c850e86c2f}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第2部分 机制\第3章 线程\3.1 从高层面上来看线程">
      <UniqueIdentifier>{c9858ab0-9e3e-4937-b7d0-9f5a9c3460b7}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第2部分 机制\第3章 线程\3.1 从高层面上来看线程\3.1.1 Windows线程是什么">
      <UniqueIdentifier>{4f0ae8a7-8080-4d1b-8cda-782730415edf}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第2部分 机制\第3章 线程\3.1 从高层面上来看线程\3.1.2 CLR线程是什么">
      <UniqueIdentifier>{e67de9b9-33ec-46be-bf1b-b11e1206b84a}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第2部分 机制\第3章 线程\3.1 从高层面上来看线程\3.1.3 显式线程操作及其替代方法">
      <UniqueIdentifier>{828b414f-b27b-407d-bc6d-b67d3a470cce}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第2部分 机制\第3章 线程\3.2 线程的诞生与消亡">
      <UniqueIdentifier>{b4760975-0303-4702-b2a5-70fbd6b9995e}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第2部分 机制\第3章 线程\3.2 线程的诞生与消亡\3.2.1 线程的创建">
      <UniqueIdentifier>{dbb50261-3bc9-4e5e-9772-f4680ed99567}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第2部分 机制\第3章 线程\3.2 线程的诞生与消亡\3.2.2 线程终止">
      <UniqueIdentifier>{11dee53d-3b5c-48b4-9eda-d94164fb9403}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第2部分 机制\第3章 线程\3.2 线程的诞生与消亡\3.2.3 DllMain">
      <UniqueIdentifier>{5d889867-fd79-459a-b042-0bfe751dc47b}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第2部分 机制\第3章 线程\3.2 线程的诞生与消亡\3.2.4 线程局部存储">
      <UniqueIdentifier>{aab2e337-d9ef-4cb3-83d5-93253db16785}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第2部分 机制\第3章 线程\3.3 小结">
      <UniqueIdentifier>{77c68da2-9447-41b7-9af9-d373add5e31e}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第2部分 机制\第3章 线程\延伸阅读">
      <UniqueIdentifier>{354ed1cf-1170-476d-ab03-b51cce4f0d4f}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第2部分 机制\第4章 线程的高级内容">
      <UniqueIdentifier>{e8bd4004-154c-45ca-97a1-2ab3d1056477}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第2部分 机制\第4章 线程的高级内容\4.1 线程的状态">
      <UniqueIdentifier>{ceffcb32-1c96-422b-80c4-089a9d6cc97a}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第2部分 机制\第4章 线程的高级内容\4.1 线程的状态\4.1.1 用户态线程栈">
      <UniqueIdentifier>{689171aa-c89d-4d77-a1cb-146b080c3729}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第2部分 机制\第4章 线程的高级内容\4.1 线程的状态\4.1.2 内部数据结构（KTHREAD、ETHREAD和TEB）">
      <UniqueIdentifier>{4b16eca4-808d-465e-a89c-b5de098b7912}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第2部分 机制\第4章 线程的高级内容\4.1 线程的状态\4.1.3 上下文">
      <UniqueIdentifier>{17e21354-4406-447e-bde1-2258437d8f25}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第2部分 机制\第4章 线程的高级内容\4.2 线程的创建过程与终止过程">
      <UniqueIdentifier>{e3650148-4c94-4bd5-8d02-0a8806607abd}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第2部分 机制\第4章 线程的高级内容\4.2 线程的创建过程与终止过程\4.2.1 线程创建的具体流程">
      <UniqueIdentifier>{7337010f-d033-4a9b-ab8f-bd401efcab8e}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第2部分 机制\第4章 线程的高级内容\4.2 线程的创建过程与终止过程\4.2.2 线程终止的具体流程">
      <UniqueIdentifier>{b8925e6f-73b9-4430-94f1-2b06e7f1f73a}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第2部分 机制\第4章 线程的高级内容\4.3 线程调度">
      <UniqueIdentifier>{35298bb1-89bf-4e03-a063-aaca94fab2f5}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第2部分 机制\第4章 线程的高级内容\4.3 线程调度\4.3.1 线程的状态">
      <UniqueIdentifier>{a37adab4-5ea4-4d8b-8f1a-3b91666c6402}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第2部分 机制\第4章 线程的高级内容\4.3 线程调度\4.3.2 优先级">
      <UniqueIdentifier>{d9dcff67-3f2b-4b17-b4c9-3ef823701ed7}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第2部分 机制\第4章 线程的高级内容\4.3 线程调度\4.3.3 时间片">
      <UniqueIdentifier>{1f957076-d917-4ea3-bddf-7768653e3e92}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第2部分 机制\第4章 线程的高级内容\4.3 线程调度\4.3.4 优先级与时间片调整">
      <UniqueIdentifier>{cd2428a7-1fda-4136-8503-070a62fd1436}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第2部分 机制\第4章 线程的高级内容\4.3 线程调度\4.3.5 睡眠与退让">
      <UniqueIdentifier>{08036eeb-1615-4ef8-acd7-9e0b7b787515}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第2部分 机制\第4章 线程的高级内容\4.3 线程调度\4.3.6 挂起">
      <UniqueIdentifier>{904aa92f-b3aa-47a3-b49d-0465b8c1b9af}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第2部分 机制\第4章 线程的高级内容\4.3 线程调度\4.3.7 关联性：优先在某个CPU上运行">
      <UniqueIdentifier>{62e41e5b-1635-4961-88d0-576eccfc7a53}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第2部分 机制\第4章 线程的高级内容\4.4 小结">
      <UniqueIdentifier>{af769e03-84bf-4e4d-bd2d-d00307bc3f8c}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第2部分 机制\第4章 线程的高级内容\延伸阅读">
      <UniqueIdentifier>{292e77a4-e8fd-4068-b900-ade6fc54f711}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第2部分 机制\第5章 Windows内核同步机制">
      <UniqueIdentifier>{20b7a4d5-1a20-44ca-b454-aae2639af089}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第2部分 机制\第5章 Windows内核同步机制\5.1 基础知识：触发和等待">
      <UniqueIdentifier>{8bf15ec5-66b8-4922-b8be-8ee08a4779a3}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第2部分 机制\第5章 Windows内核同步机制\5.1 基础知识：触发和等待\5.1.1 为什么要使用内核对象">
      <UniqueIdentifier>{06a6b9ae-34c5-4029-bc2f-cddb7c611bf0}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第2部分 机制\第5章 Windows内核同步机制\5.1 基础知识：触发和等待\5.1.2 在非托管代码中执行等待操作">
      <UniqueIdentifier>{c9d2f1be-95ba-415e-aa3f-005db27f44bf}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第2部分 机制\第5章 Windows内核同步机制\5.1 基础知识：触发和等待\5.1.3 托管代码">
      <UniqueIdentifier>{9922225f-4757-417a-98d0-07ef28d740fb}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第2部分 机制\第5章 Windows内核同步机制\5.1 基础知识：触发和等待\5.1.4 异步过程调用">
      <UniqueIdentifier>{76de0465-2096-4a38-a9c7-b17805059f52}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第2部分 机制\第5章 Windows内核同步机制\5.2 内核对象的使用">
      <UniqueIdentifier>{4f23e0c1-6823-4857-81c8-f9a325d3f61d}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第2部分 机制\第5章 Windows内核同步机制\5.2 内核对象的使用\5.2.1 互斥体">
      <UniqueIdentifier>{37063a0a-fbb2-43b8-97e6-7741ec8e035e}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第2部分 机制\第5章 Windows内核同步机制\5.2 内核对象的使用\5.2.2 信号量">
      <UniqueIdentifier>{cc7dea53-fe08-45bb-aa2b-4beab38bac3b}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第2部分 机制\第5章 Windows内核同步机制\5.2 内核对象的使用\5.2.3 互斥体/信号量使用示例：阻塞/有界的队列">
      <UniqueIdentifier>{5a5be850-b690-4fa5-93d7-bf0b1750a3fb}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第2部分 机制\第5章 Windows内核同步机制\5.2 内核对象的使用\5.2.4 自动重置事件和手动重置事件">
      <UniqueIdentifier>{1997fc5f-678a-44ad-9600-6e1657fdf1ad}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第2部分 机制\第5章 Windows内核同步机制\5.2 内核对象的使用\5.2.5 等待定时器">
      <UniqueIdentifier>{334c5a39-e0b8-4117-bd72-c2546887bd1e}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第2部分 机制\第5章 Windows内核同步机制\5.2 内核对象的使用\5.2.6 触发对象与自动等待">
      <UniqueIdentifier>{d0da8dc9-b6fa-47f9-8530-a81e3bd86c5b}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第2部分 机制\第5章 Windows内核同步机制\5.2 内核对象的使用\5.2.7 内核对象的调试">
      <UniqueIdentifier>{a94fbbbe-96d7-4912-9120-22bab4f1a265}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第2部分 机制\第5章 Windows内核同步机制\5.3 小结">
      <UniqueIdentifier>{203dd8c3-4f44-487e-9ba6-88f6209d0658}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第2部分 机制\第5章 Windows内核同步机制\延伸阅读">
      <UniqueIdentifier>{00f94470-7c56-4bf3-9fd5-b86c21e9e7c4}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第2部分 机制\第6章 数据同步与控制同步">
      <UniqueIdentifier>{7b592124-98d0-40dd-b684-b573fb34f63b}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第2部分 机制\第6章 数据同步与控制同步\6.1 互斥">
      <UniqueIdentifier>{1fb790d3-e33a-4e5e-ae18-138d522708c4}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第2部分 机制\第6章 数据同步与控制同步\6.1 互斥\6.1.1 Win32临界区">
      <UniqueIdentifier>{78ec9130-e67f-44b6-b8e7-f66b79738bb2}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第2部分 机制\第6章 数据同步与控制同步\6.1 互斥\6.1.2 CLR锁">
      <UniqueIdentifier>{5b451d7c-cac1-4de6-975e-374f179648c5}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第2部分 机制\第6章 数据同步与控制同步\6.2 读/写锁（RWL）">
      <UniqueIdentifier>{7255371f-46b2-4cb0-bb88-62ca61b4c684}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第2部分 机制\第6章 数据同步与控制同步\6.2 读/写锁（RWL）\6.2.1 WindowsVista中的轻量级读/写锁">
      <UniqueIdentifier>{54540eb5-59ba-48e7-be55-ffe3a2eafacf}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第2部分 机制\第6章 数据同步与控制同步\6.2 读/写锁（RWL）\6.2.2 .NEI框架中的轻量级读/写锁">
      <UniqueIdentifier>{f35b6fdc-2d82-466b-8883-57070ff1a582}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第2部分 机制\第6章 数据同步与控制同步\6.2 读/写锁（RWL）\6.2.3 .NET框架中原来的读/写锁">
      <UniqueIdentifier>{17ac39c0-add6-4514-b4b2-e40e0a1c5620}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第2部分 机制\第6章 数据同步与控制同步\6.3 条件变量">
      <UniqueIdentifier>{df2d4b58-2614-49f4-a8e1-fdbdb8c3695a}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第2部分 机制\第6章 数据同步与控制同步\6.3 条件变量\6.3.1 WindowsVista条件变量">
      <UniqueIdentifier>{df08ea3f-a29e-489b-b29a-f0f146554b2d}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第2部分 机制\第6章 数据同步与控制同步\6.3 条件变量\6.3.2 .NET框架的Monitor">
      <UniqueIdentifier>{d59c27cf-193b-4a4c-b3f5-24996021adf3}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第2部分 机制\第6章 数据同步与控制同步\6.3 条件变量\6.3.3 被守护区域">
      <UniqueIdentifier>{dc7dd114-89dc-4de7-98d7-ca41fb502995}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第2部分 机制\第6章 数据同步与控制同步\6.4 小结">
      <UniqueIdentifier>{187fcf3d-4284-437a-95b8-9a2bae9ad6a5}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第2部分 机制\第6章 数据同步与控制同步\延伸阅读">
      <UniqueIdentifier>{e5c4af7e-a8c3-429d-8202-38ce4204289b}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第2部分 机制\第7章 线程池">
      <UniqueIdentifier>{60fb8ca2-a3e5-45bd-8529-48cb5f1f0d82}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第2部分 机制\第7章 线程池\7.1 线程池的基本知识">
      <UniqueIdentifier>{b8b1e1c1-c8f9-48f6-9ecc-d9b587cf7d77}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第2部分 机制\第7章 线程池\7.1 线程池的基本知识\7.1.1 三种方式：WindowsVista、Windows遗留代码以及CLR">
      <UniqueIdentifier>{4ce3ae0a-369d-4b44-aea4-71f18f329387}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第2部分 机制\第7章 线程池\7.1 线程池的基本知识\7.1.2 通用功能">
      <UniqueIdentifier>{95100ff3-8349-4fd6-85d5-5893ade8f642}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第2部分 机制\第7章 线程池\7.2 Windows线程池">
      <UniqueIdentifier>{91e82d04-b62d-4909-96e6-589c1d6c7e04}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第2部分 机制\第7章 线程池\7.2 Windows线程池\7.2.1 WindowsVista线程池">
      <UniqueIdentifier>{3e2a7fb8-7058-4b66-bb28-a179407526c5}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第2部分 机制\第7章 线程池\7.2 Windows线程池\7.2.2 遗留的Win32线程池">
      <UniqueIdentifier>{2efa7d4e-539c-4f85-8103-ebccd2815520}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第2部分 机制\第7章 线程池\7.3 CLR线程池">
      <UniqueIdentifier>{f17dcd84-9c30-4cbe-9fec-077cf84a00ad}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第2部分 机制\第7章 线程池\7.3 CLR线程池\7.3.1 工作项">
      <UniqueIdentifier>{a7ecbd65-d38c-441b-8342-094a9aaf5001}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第2部分 机制\第7章 线程池\7.3 CLR线程池\7.3.2 I/O完成端口">
      <UniqueIdentifier>{821b90d0-35b7-44e1-9b65-8992bb85b41a}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第2部分 机制\第7章 线程池\7.3 CLR线程池\7.3.3 定时器">
      <UniqueIdentifier>{3765e50b-ce18-46bd-b4e8-4bfbd2527a5a}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第2部分 机制\第7章 线程池\7.3 CLR线程池\7.3.4 注册等待">
      <UniqueIdentifier>{5857c0f2-2fe3-4c66-9d04-08779367f1d8}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第2部分 机制\第7章 线程池\7.3 CLR线程池\7.3.5 记住（再次提醒）：你并不拥有这些线程">
      <UniqueIdentifier>{b8a46b0b-f1b0-4d42-8a97-301ad395de16}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第2部分 机制\第7章 线程池\7.3 CLR线程池\7.3.6 线程池的线程管理">
      <UniqueIdentifier>{9ea149d0-91f2-4fb5-9923-43872ba37669}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第2部分 机制\第7章 线程池\7.3 CLR线程池\7.3.7 调试">
      <UniqueIdentifier>{92e0ddce-70e3-48bb-bdf5-ee8a7dc800e3}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第2部分 机制\第7章 线程池\7.3 CLR线程池\7.3.8 案例分析：优先级分层以及在线程池之上的隔离性">
      <UniqueIdentifier>{058e9e72-ee5d-477f-8537-ca540db5345a}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第2部分 机制\第7章 线程池\7.4 在使用线程池时的性能">
      <UniqueIdentifier>{5d3e7325-96d0-4d03-9772-cdd5f386cb55}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第2部分 机制\第7章 线程池\7.5 小结">
      <UniqueIdentifier>{35f74bb4-c9d2-46e0-bbc9-6b0b478bd85d}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第2部分 机制\第7章 线程池\延伸阅读">
      <UniqueIdentifier>{9f623d36-761f-43ac-ab7b-869b1afb0621}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第2部分 机制\第8章 异步编程模型">
      <UniqueIdentifier>{2b0b510a-ca63-41e5-821e-60db34329aa7}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第2部分 机制\第8章 异步编程模型\8.1 异步编程模型（APM）">
      <UniqueIdentifier>{e95fd2f9-fa5d-41f9-965b-1a168f488686}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第2部分 机制\第8章 异步编程模型\8.1 异步编程模型（APM）\8.1.1 汇集：四种方式">
      <UniqueIdentifier>{2d698e2a-6d8b-43bf-b575-585af39f4711}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第2部分 机制\第8章 异步编程模型\8.1 异步编程模型（APM）\8.1.2 实现IAsyncResult">
      <UniqueIdentifier>{deb7bf8f-43ee-4e23-a1bb-cc3a886654ea}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第2部分 机制\第8章 异步编程模型\8.1 异步编程模型（APM）\8.1.3 在.NET框架的哪些地方使用了APM">
      <UniqueIdentifier>{9fa11a37-11d6-4e34-81ed-294e0e7b3908}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第2部分 机制\第8章 异步编程模型\8.1 异步编程模型（APM）\8.1.4 ASP.NET异步页">
      <UniqueIdentifier>{61f67421-a1f0-4148-89ee-20f69f0f3780}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第2部分 机制\第8章 异步编程模型\8.2 基于事件的异步模式">
      <UniqueIdentifier>{cb80558e-d6e7-4a6f-9f17-5da7986e6948}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第2部分 机制\第8章 异步编程模型\8.2 基于事件的异步模式\8.2.1 基础知识">
      <UniqueIdentifier>{fda2833c-5004-4521-b082-82d60558d218}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第2部分 机制\第8章 异步编程模型\8.2 基于事件的异步模式\8.2.2 支持取消">
      <UniqueIdentifier>{3d817d8a-1944-46db-8823-45a92b943d74}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第2部分 机制\第8章 异步编程模型\8.2 基于事件的异步模式\8.2.3 支持进度报告以及增量结果">
      <UniqueIdentifier>{02edb448-537e-40d3-a060-0564431108be}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第2部分 机制\第8章 异步编程模型\8.2 基于事件的异步模式\8.2.4 在.NET框架的哪些地方将使用EAP">
      <UniqueIdentifier>{37bd3b65-f9e4-44e5-9875-6530bdc02801}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第2部分 机制\第8章 异步编程模型\8.3 小结">
      <UniqueIdentifier>{3c401db0-ce5e-40f2-a961-a459d4e5eb4f}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第2部分 机制\第8章 异步编程模型\延伸阅读">
      <UniqueIdentifier>{0d7b148e-9f04-4956-966b-63302b6d4636}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第2部分 机制\第9章 纤程">
      <UniqueIdentifier>{9b88345a-c261-46bb-9f7f-0142a62ba51a}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第2部分 机制\第9章 纤程\9.1 纤程简介优点与缺点">
      <UniqueIdentifier>{0ceffe54-78cb-449b-8bfc-938535593ba7}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第2部分 机制\第9章 纤程\9.2 纤程的使用">
      <UniqueIdentifier>{1c838194-303e-48eb-8f79-f9a6e9a49d47}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第2部分 机制\第9章 纤程\9.2 纤程的使用\9.2.1 创建新的纤程">
      <UniqueIdentifier>{d9cba10e-8a2c-4816-a4e6-3d7170205f58}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第2部分 机制\第9章 纤程\9.2 纤程的使用\9.2.2 将线程转换为纤程">
      <UniqueIdentifier>{758e872d-8bb0-436e-aacb-66e2b6447f67}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第2部分 机制\第9章 纤程\9.2 纤程的使用\9.2.3 判断线程是否为纤程">
      <UniqueIdentifier>{882dbb59-21bb-42ce-baed-c463a1ffadc8}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第2部分 机制\第9章 纤程\9.2 纤程的使用\9.2.4 纤程间的切换">
      <UniqueIdentifier>{6e302e4e-3c2d-4214-8f46-3dd4888b9883}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第2部分 机制\第9章 纤程\9.2 纤程的使用\9.2.5 删除纤程">
      <UniqueIdentifier>{9b1a80dd-d20e-4207-96cf-aa335fe5f763}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第2部分 机制\第9章 纤程\9.2 纤程的使用\9.2.6 切换当前线程的示例">
      <UniqueIdentifier>{2572ddb2-3098-4707-b44c-7a84f8447019}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第2部分 机制\第9章 纤程\9.3 与纤程相关的其他主题">
      <UniqueIdentifier>{cbcfdbfc-0029-4481-9899-84eb4cdbc80a}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第2部分 机制\第9章 纤程\9.3 与纤程相关的其他主题\9.3.1 纤程局部存储">
      <UniqueIdentifier>{4abedb80-302c-4d76-b6a9-aa521f069b13}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第2部分 机制\第9章 纤程\9.3 与纤程相关的其他主题\9.3.2 线程关联性">
      <UniqueIdentifier>{90624371-aaa6-4699-aa55-781a7f904d18}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第2部分 机制\第9章 纤程\9.3 与纤程相关的其他主题\9.3.3 案例分析：纤程与CLR">
      <UniqueIdentifier>{a0d9c971-76cc-46cd-ab08-930dae2e2f4d}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第2部分 机制\第9章 纤程\9.4 构建用户态的调度器">
      <UniqueIdentifier>{e3e19d9b-bac9-4ab5-a804-524d64ef2dc9}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第2部分 机制\第9章 纤程\9.4 构建用户态的调度器\9.4.1 实现">
      <UniqueIdentifier>{bbbd25f7-269b-4f97-aeef-c1a02048b6a8}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第2部分 机制\第9章 纤程\9.4 构建用户态的调度器\9.4.2 关于栈阻塞与无栈阻塞">
      <UniqueIdentifier>{cd933348-0609-4600-8194-63a58c0b5025}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第2部分 机制\第9章 纤程\9.5 小结">
      <UniqueIdentifier>{1570aa59-6742-4f06-81b4-cd88037fd60c}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第2部分 机制\第9章 纤程\延伸阅读">
      <UniqueIdentifier>{a45480cc-36ef-462b-96fa-03c4b53aad4a}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第3部分 技术">
      <UniqueIdentifier>{d2a7bc7f-c5fc-4b3e-a90a-4e18efff28dd}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第3部分 技术\第10章 内存模型与无锁编程">
      <UniqueIdentifier>{c545e09d-46f7-4104-b9af-91eb53b97a5d}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第3部分 技术\第10章 内存模型与无锁编程\10.1 内存加载与存储等操作的重新排序">
      <UniqueIdentifier>{d5034fae-e743-486d-9e21-aac9b5d01a4b}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第3部分 技术\第10章 内存模型与无锁编程\10.1 内存加载与存储等操作的重新排序\10.1.1 实际运行的顺序并非总是编写的顺序">
      <UniqueIdentifier>{c18a5e81-ba6d-49aa-8c96-64e76f80354e}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第3部分 技术\第10章 内存模型与无锁编程\10.1 内存加载与存储等操作的重新排序\10.1.2 将临界域作为栅栏">
      <UniqueIdentifier>{acbbff95-b031-4f12-bb68-8dc788eece90}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第3部分 技术\第10章 内存模型与无锁编程\10.1 内存加载与存储等操作的重新排序\10.1.3 数据依赖性及其对重排的影响">
      <UniqueIdentifier>{31bc37f8-94c3-4899-a05e-782e199df468}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第3部分 技术\第10章 内存模型与无锁编程\10.2 硬件原子性">
      <UniqueIdentifier>{c172d669-b484-4739-a91e-ae8b5d732bbb}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第3部分 技术\第10章 内存模型与无锁编程\10.2 硬件原子性\10.2.1 普通加载指令和存储指令的原子性">
      <UniqueIdentifier>{e5994665-b468-43d7-a421-bd9bddd51ba6}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第3部分 技术\第10章 内存模型与无锁编程\10.2 硬件原子性\10.2.2 互锁操作">
      <UniqueIdentifier>{c614f491-b806-4a43-827b-34b9b774a325}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第3部分 技术\第10章 内存模型与无锁编程\10.3 内存一致性模型">
      <UniqueIdentifier>{4d374946-17a7-4296-be42-b1bf61c55cca}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第3部分 技术\第10章 内存模型与无锁编程\10.3 内存一致性模型\10.3.1 硬件内存模型">
      <UniqueIdentifier>{8c432c2f-f750-48f9-9bdb-135857ca6031}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第3部分 技术\第10章 内存模型与无锁编程\10.3 内存一致性模型\10.3.2 内存栅栏">
      <UniqueIdentifier>{f79ecb4a-d1fa-4013-bf59-3265951570d7}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第3部分 技术\第10章 内存模型与无锁编程\10.3 内存一致性模型\10.3.3 .NET内存模型">
      <UniqueIdentifier>{e05daea4-2f21-4ac2-93d8-abecc08af895}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第3部分 技术\第10章 内存模型与无锁编程\10.3 内存一致性模型\10.3.4 无锁编程">
      <UniqueIdentifier>{6251c7df-482f-4c25-8f85-8b26009e67fa}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第3部分 技术\第10章 内存模型与无锁编程\10.4 低锁代码的示例">
      <UniqueIdentifier>{4c4af74b-4e94-4eb9-a36c-34cde62da004}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第3部分 技术\第10章 内存模型与无锁编程\10.4 低锁代码的示例\10.4.1 延迟初始化与双重检查锁定">
      <UniqueIdentifier>{2919135a-00ab-4084-ad61-faf5fafe0ba4}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第3部分 技术\第10章 内存模型与无锁编程\10.4 低锁代码的示例\10.4.2 无阻塞栈和ABA问题">
      <UniqueIdentifier>{9d7026a7-58e5-46b3-a36a-c14e3cfbe6ff}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第3部分 技术\第10章 内存模型与无锁编程\10.4 低锁代码的示例\10.4.3 重新回顾Dekker的算法">
      <UniqueIdentifier>{4b55b0e5-cc48-4051-81ad-dbb35ecf2c21}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第3部分 技术\第10章 内存模型与无锁编程\10.5 小结">
      <UniqueIdentifier>{6bc5d062-c5c8-49ad-b392-c700c636fc9e}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第3部分 技术\第10章 内存模型与无锁编程\延伸阅读">
      <UniqueIdentifier>{6e9b924e-04c1-4477-b171-7d072313dd17}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第3部分 技术\第11章 并发的危害">
      <UniqueIdentifier>{66593b76-5e0f-405b-9a36-3d402307360f}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第3部分 技术\第11章 并发的危害\11.1 正确性危害">
      <UniqueIdentifier>{0a67a0d6-9fd5-4df3-8b4d-63c7aa386986}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第3部分 技术\第11章 并发的危害\11.1 正确性危害\11.1.3 锁与进程关闭">
      <UniqueIdentifier>{58531927-79f4-4cb6-945e-b1ed0fbb784c}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第3部分 技术\第11章 并发的危害\11.1 正确性危害\11.1.1 数据竞争">
      <UniqueIdentifier>{1767d0eb-e08f-4e03-b459-3d6bf9431027}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第3部分 技术\第11章 并发的危害\11.1 正确性危害\11.1.2 递归与重入">
      <UniqueIdentifier>{d7fbaf91-1d02-4e07-973a-d311861be967}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第3部分 技术\第11章 并发的危害\11.2 活跃性危害">
      <UniqueIdentifier>{0a3ebb1b-f7f3-49d9-baa0-ba2636471aaf}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第3部分 技术\第11章 并发的危害\11.2 活跃性危害\11.2.1 死锁">
      <UniqueIdentifier>{c465445b-c9fc-4d5a-aa79-3d3b0fba4b47}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第3部分 技术\第11章 并发的危害\11.2 活跃性危害\11.2.2 遗失的唤醒">
      <UniqueIdentifier>{5231b76b-2e77-4bf7-afd8-fb063de86023}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第3部分 技术\第11章 并发的危害\11.2 活跃性危害\11.2.3 活锁">
      <UniqueIdentifier>{7fbace6a-9651-476b-819e-246527680c5b}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第3部分 技术\第11章 并发的危害\11.2 活跃性危害\11.2.4 锁护送效应">
      <UniqueIdentifier>{46ddc915-9ea7-46b0-a2b8-eb9c2886f1b2}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第3部分 技术\第11章 并发的危害\11.2 活跃性危害\11.2.5 “蜂拥”现象">
      <UniqueIdentifier>{387bd92c-4355-49d5-99c8-0e7b26ad1385}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第3部分 技术\第11章 并发的危害\11.2 活跃性危害\11.2.6 两步舞">
      <UniqueIdentifier>{e5f62e63-2f19-482c-aa91-43451fed3b2d}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第3部分 技术\第11章 并发的危害\11.2 活跃性危害\11.2.7 优先级反转与饥饿">
      <UniqueIdentifier>{133c1d2a-db9d-4b17-9f31-c5f420d7d7ba}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第3部分 技术\第11章 并发的危害\11.3 小结">
      <UniqueIdentifier>{215bbf75-f8e2-4ba5-8b71-5416c6ccaa46}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第3部分 技术\第11章 并发的危害\延伸阅读">
      <UniqueIdentifier>{78872a21-c865-4c9a-afff-243f3592c8d4}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第3部分 技术\第12章 并行容器">
      <UniqueIdentifier>{175d5639-c6a2-43b1-9cad-13e59495fb75}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第3部分 技术\第12章 并行容器\12.1 细粒度锁定">
      <UniqueIdentifier>{6c2d028e-d395-45f3-be84-f8489eb381fc}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第3部分 技术\第12章 并行容器\12.1 细粒度锁定\12.1.1 数组">
      <UniqueIdentifier>{e5c0c96d-0ddf-4370-b50b-dbaac0513fde}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第3部分 技术\第12章 并行容器\12.1 细粒度锁定\12.1.2 FIFO队列">
      <UniqueIdentifier>{ee808496-ed41-43d9-a06a-a7b50c099723}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第3部分 技术\第12章 并行容器\12.1 细粒度锁定\12.1.3 链表">
      <UniqueIdentifier>{50e939a7-15ff-434f-94f1-a575ff165942}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第3部分 技术\第12章 并行容器\12.1 细粒度锁定\12.1.4 字典（散列表）">
      <UniqueIdentifier>{16ce44e2-feb8-44cd-bb15-e8e3122e10f1}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第3部分 技术\第12章 并行容器\12.2 无锁">
      <UniqueIdentifier>{99025d56-15e4-4225-b861-2d78cd7bf0e4}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第3部分 技术\第12章 并行容器\12.2 无锁\12.2.1 无锁FIFO队列">
      <UniqueIdentifier>{345e5a49-7342-42db-8187-e3becf8c6288}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第3部分 技术\第12章 并行容器\12.2 无锁\12.2.2 工作密迁队列">
      <UniqueIdentifier>{5ae8db87-02ee-46d7-8e7f-15dda0d177d3}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第3部分 技术\第12章 并行容器\12.3 协作式容器">
      <UniqueIdentifier>{8c7c23b8-c31e-4936-8f3c-2a373263db31}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第3部分 技术\第12章 并行容器\12.3 协作式容器\12.3.1 生产者/消费者数据结构">
      <UniqueIdentifier>{b57a689e-24c4-4de4-8190-9c8aa5fcef9b}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第3部分 技术\第12章 并行容器\12.3 协作式容器\12.3.2 通过栅栏来分阶段计算">
      <UniqueIdentifier>{9d8d78c2-aa4b-493a-ae83-b78ea7d4fbd2}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第3部分 技术\第12章 并行容器\12.4 小结">
      <UniqueIdentifier>{62161463-e962-4615-82d9-0010c89309e3}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第3部分 技术\第12章 并行容器\延伸阅读">
      <UniqueIdentifier>{4e5adcf4-2f00-40b5-b243-10a7e9ce41d1}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第3部分 技术\第13章 数据并行与任务并行">
      <UniqueIdentifier>{7b389407-54ba-465b-9d6a-9d3571033978}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第3部分 技术\第13章 数据并行与任务并行\13.1 数据并行">
      <UniqueIdentifier>{fb348b4c-3c58-4fb0-85d9-c85f3bd50306}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第3部分 技术\第13章 数据并行与任务并行\13.2 任务并行">
      <UniqueIdentifier>{0fc500eb-9c9b-4c97-b0fa-2f1ba2cfecd6}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第3部分 技术\第13章 数据并行与任务并行\13.2 任务并行\13.2.1 分支/合并算法">
      <UniqueIdentifier>{adf784f9-2657-4663-b8c5-909f8652de18}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第3部分 技术\第13章 数据并行与任务并行\13.2 任务并行\13.2.2 数据流并行（Future抽象与Promise抽象）">
      <UniqueIdentifier>{f44a3567-9bba-49dd-940b-54147d753b22}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第3部分 技术\第13章 数据并行与任务并行\13.2 任务并行\13.2.3 递归">
      <UniqueIdentifier>{dcc56a55-55da-408d-83fc-a6823efb0d1e}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第3部分 技术\第13章 数据并行与任务并行\13.2 任务并行\13.2.4 流水线">
      <UniqueIdentifier>{6c0fd128-0d6c-47e5-80f2-d4c0b9b3539b}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第3部分 技术\第13章 数据并行与任务并行\13.2 任务并行\13.2.5 查找">
      <UniqueIdentifier>{0e830020-85bf-434b-aae0-1b71131f96aa}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第3部分 技术\第13章 数据并行与任务并行\13.3 基于消息的并行">
      <UniqueIdentifier>{73e9654c-8d9a-435c-876c-1fca209e2191}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第3部分 技术\第13章 数据并行与任务并行\13.4 一些共同问题">
      <UniqueIdentifier>{068e4ec7-b365-410b-af19-f04c32ec0d79}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第3部分 技术\第13章 数据并行与任务并行\13.4 一些共同问题\13.4.1 并发的异常">
      <UniqueIdentifier>{2b7d55f0-e92d-452f-b4f2-cb2de83d3408}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第3部分 技术\第13章 数据并行与任务并行\13.4 一些共同问题\13.4.2 取消">
      <UniqueIdentifier>{4753b1be-4808-40e2-8a76-dc3e7299ed71}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第3部分 技术\第13章 数据并行与任务并行\13.5 小结">
      <UniqueIdentifier>{b0977016-490f-4f20-926a-510fcef9b74e}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第3部分 技术\第13章 数据并行与任务并行\延伸阅读">
      <UniqueIdentifier>{4a923a07-b603-4c7a-b4c8-a5485718fb7e}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第3部分 技术\第14章 性能与可伸缩性">
      <UniqueIdentifier>{3f29d72e-11ae-409b-976b-d94b27f1ea59}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第3部分 技术\第14章 性能与可伸缩性\14.1 并行硬件架构">
      <UniqueIdentifier>{3edc8ca5-f65c-429d-bc2b-bf3fb85bb2ad}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第3部分 技术\第14章 性能与可伸缩性\14.1 并行硬件架构\14.1.1 SMP、CMP与HT">
      <UniqueIdentifier>{327927d7-632d-4b45-8c61-5cb6be948206}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第3部分 技术\第14章 性能与可伸缩性\14.1 并行硬件架构\14.1.2 超标量执行">
      <UniqueIdentifier>{653c4913-152f-4a3c-94a8-095a85a3bccb}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第3部分 技术\第14章 性能与可伸缩性\14.1 并行硬件架构\14.1.3 内存的层次结构">
      <UniqueIdentifier>{636d6c93-5b53-43cf-87c4-42b41649bca0}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第3部分 技术\第14章 性能与可伸缩性\14.1 并行硬件架构\14.1.4 Visual Studio中的性能分析工具">
      <UniqueIdentifier>{b0bf5a3b-15e6-437d-8d0d-baf3d865ed73}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第3部分 技术\第14章 性能与可伸缩性\14.2 加速比：并行代码与串行代码">
      <UniqueIdentifier>{117435df-1d03-4aa4-a7dd-26e31ce9fd96}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第3部分 技术\第14章 性能与可伸缩性\14.2 加速比：并行代码与串行代码\14.2.1 决定“采用并行”">
      <UniqueIdentifier>{7e4d7814-facf-4224-8c85-010e1fca97fd}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第3部分 技术\第14章 性能与可伸缩性\14.2 加速比：并行代码与串行代码\14.2.2 测量并行带来的性能提升">
      <UniqueIdentifier>{bf420129-691f-45d1-812f-21cb7268253b}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第3部分 技术\第14章 性能与可伸缩性\14.2 加速比：并行代码与串行代码\14.2.3 Amdahl定律">
      <UniqueIdentifier>{5a4de4f1-bfed-47dc-b9d1-234b7295df6f}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第3部分 技术\第14章 性能与可伸缩性\14.2 加速比：并行代码与串行代码\14.2.4 关键路径以及负载不均衡">
      <UniqueIdentifier>{fd991630-6322-4eed-8ee6-bddf30269633}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第3部分 技术\第14章 性能与可伸缩性\14.2 加速比：并行代码与串行代码\14.2.5 垃圾收集与可伸缩性">
      <UniqueIdentifier>{cb8ebbd7-3423-4c60-b184-543a374b395f}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第3部分 技术\第14章 性能与可伸缩性\14.3 自旋等待">
      <UniqueIdentifier>{c7db56d6-f2dc-4bc6-87be-99ad3a9aaf84}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第3部分 技术\第14章 性能与可伸缩性\14.3 自旋等待\14.3.1 如何在Windows上正确地自旋">
      <UniqueIdentifier>{f0f97bd2-fc60-49d4-a1b3-128e972c5f5b}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第3部分 技术\第14章 性能与可伸缩性\14.3 自旋等待\14.3.2 纯自旋锁">
      <UniqueIdentifier>{ab17ce08-f738-4b40-9a77-495605a846ed}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第3部分 技术\第14章 性能与可伸缩性\14.3 自旋等待\14.3.3 Mellor-Crummey-Scott（MCS）锁">
      <UniqueIdentifier>{768681f5-5271-4152-b1f8-a9d10901d7fb}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第3部分 技术\第14章 性能与可伸缩性\14.4 小结">
      <UniqueIdentifier>{6a1b8f85-4e28-4e20-b8b2-e49e1d53fb7f}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第3部分 技术\第14章 性能与可伸缩性\延伸阅读">
      <UniqueIdentifier>{29fe9903-9ffb-429a-b475-d9e6b4f40b41}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第4部分 系统">
      <UniqueIdentifier>{32fe4925-fa1f-4477-a027-c1d0abce1b3e}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第4部分 系统\第15章 输入与输出">
      <UniqueIdentifier>{fc7acc3f-7e2a-49d1-b5d4-50f493792088}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第4部分 系统\第15章 输入与输出\15.1 重叠I/O">
      <UniqueIdentifier>{77bde4fb-14b5-4bfb-93f6-9de5c3d1c952}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第4部分 系统\第15章 输入与输出\15.1 重叠I/O\15.1.1 重叠对象">
      <UniqueIdentifier>{1114a276-ceec-4829-9828-562ac33837b5}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第4部分 系统\第15章 输入与输出\15.1 重叠I/O\15.1.2 Win32异步：I/O">
      <UniqueIdentifier>{ea66f433-4a48-461a-a823-4066cfef5f6f}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第4部分 系统\第15章 输入与输出\15.1 重叠I/O\15.1.3 .NET框架的异步I/O">
      <UniqueIdentifier>{11f57a45-b985-4d7b-9b27-0fd9c561a5db}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第4部分 系统\第15章 输入与输出\15.2 I/O取消">
      <UniqueIdentifier>{edd8f032-32f9-4bff-b886-a961f20e52db}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第4部分 系统\第15章 输入与输出\15.2 I/O取消\15.2.1 当前线程的异步I/O取消">
      <UniqueIdentifier>{5b31e8e0-7020-469a-859d-c5970303951d}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第4部分 系统\第15章 输入与输出\15.2 I/O取消\15.2.2 其他线程上的同步I/O取消">
      <UniqueIdentifier>{ad996ff8-aa05-489a-b212-c19f2d79bea8}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第4部分 系统\第15章 输入与输出\15.2 I/O取消\15.2.3 任意线程的异步I/O取消">
      <UniqueIdentifier>{5d7e6044-9c70-4717-ae3f-68f1752f2386}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第4部分 系统\第15章 输入与输出\15.3 小结">
      <UniqueIdentifier>{660bbd65-6050-4dd4-8c83-da254ad81e05}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第4部分 系统\第15章 输入与输出\延伸阅读">
      <UniqueIdentifier>{34c872e9-ff7c-4e30-9835-802a3d229fca}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第4部分 系统\第16章 图形用户界面">
      <UniqueIdentifier>{7e9f101d-6e1b-4274-8fea-dba3960d4fba}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第4部分 系统\第16章 图形用户界面\16.1 GUI线程模型">
      <UniqueIdentifier>{a0eff0c3-ef2d-4e75-a5c4-7b3231b77b05}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第4部分 系统\第16章 图形用户界面\16.1 GUI线程模型\16.1.1 单线程套间（STA）">
      <UniqueIdentifier>{d65ea636-eccf-48c7-88fa-eb2cea2ced6a}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第4部分 系统\第16章 图形用户界面\16.1 GUI线程模型\16.1.2 响应度：它是什么">
      <UniqueIdentifier>{62d5faf5-f16f-4db6-bf7c-2ad744a7239d}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第4部分 系统\第16章 图形用户界面\16.2.NET异步GUI功能">
      <UniqueIdentifier>{baccb845-2dce-4911-8f0c-7309d915c356}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第4部分 系统\第16章 图形用户界面\16.2.NET异步GUI功能\16.2.1.NET的GUI框架">
      <UniqueIdentifier>{c70f4d24-d241-48a1-9f84-0d51d3e85333}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第4部分 系统\第16章 图形用户界面\16.2.NET异步GUI功能\16.2.2 同步上下文">
      <UniqueIdentifier>{8e18efd2-e7e3-4eb1-bc0b-f2f5c254c016}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第4部分 系统\第16章 图形用户界面\16.2.NET异步GUI功能\16.2.3 异步操作">
      <UniqueIdentifier>{c74a41b7-bddd-4e38-9665-4dff2fa73840}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第4部分 系统\第16章 图形用户界面\16.2.NET异步GUI功能\16.2.4 一个方便的类：BackgroundWorker">
      <UniqueIdentifier>{d2ba6a38-f3d4-44e9-810f-6732c4a47b63}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第4部分 系统\第16章 图形用户界面\16.3 小结">
      <UniqueIdentifier>{ad5e0192-3e2e-4bda-a10c-765d6de60097}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第4部分 系统\第16章 图形用户界面\延伸阅读">
      <UniqueIdentifier>{7380d448-c020-4f2d-9ac1-500f8bd7fe0e}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第5部分 附录">
      <UniqueIdentifier>{3978098b-18d3-403c-830e-da8551c4c149}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第5部分 附录\附录A 为.NET并发程序设计可重用的库">
      <UniqueIdentifier>{2b0b3052-043c-44e0-ab6c-43828c36fadc}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Concurrent Programming On Windows（Windows 并发编程指南）\第5部分 附录\附录B .NET的并行扩展">
      <UniqueIdentifier>{67c7c65d-7f0d-442b-847b-b2ba26a08fa6}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Parallel and Distributed Programming Using C++（C++ 并行与分布式编程）\0. 序言">
      <UniqueIdentifier>{d4040f9e-1c18-4e9b-8857-ea16aa219969}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Parallel and Distributed Programming Using C++（C++ 并行与分布式编程）\0. 序言\0.1 并行和分布式编程的挑战">
      <UniqueIdentifier>{bf8c6ab9-431c-458c-983c-4c5004a505d6}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Parallel and Distributed Programming Using C++（C++ 并行与分布式编程）\0. 序言\0.2 并行和分布式编程的方法">
      <UniqueIdentifier>{5e1f671e-915f-4e67-b273-4b3b8a7ac204}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Parallel and Distributed Programming Using C++（C++ 并行与分布式编程）\0. 序言\0.3 为什么选用C++">
      <UniqueIdentifier>{95b124e2-7dae-45f8-abdc-67a88350a7dd}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Parallel and Distributed Programming Using C++（C++ 并行与分布式编程）\0. 序言\0.4 并行和分布式编程的库">
      <UniqueIdentifier>{879a0513-8cf0-40d0-8fe9-ac8c6a79025b}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Parallel and Distributed Programming Using C++（C++ 并行与分布式编程）\0. 序言\0.5 新的单一UNIX规范标准">
      <UniqueIdentifier>{446d8c8e-29cb-4b15-bc13-dc64e028c414}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Parallel and Distributed Programming Using C++（C++ 并行与分布式编程）\0. 序言\0.6 本书面向的读者">
      <UniqueIdentifier>{e3597ec9-caf0-44c5-8312-17e7cfa2c6ea}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Parallel and Distributed Programming Using C++（C++ 并行与分布式编程）\0. 序言\0.7 支持的开发环境">
      <UniqueIdentifier>{9d309313-e271-4ad6-bce8-3f1e61e52f11}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Parallel and Distributed Programming Using C++（C++ 并行与分布式编程）\0. 序言\0.8 补充">
      <UniqueIdentifier>{838a0526-7e26-4a7c-b3b5-dd3c44b7f170}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Parallel and Distributed Programming Using C++（C++ 并行与分布式编程）\0. 序言\0.9 致谢">
      <UniqueIdentifier>{da0e1d79-b241-4267-a08e-62c6cac68866}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Parallel and Distributed Programming Using C++（C++ 并行与分布式编程）\第1章 并发编程的乐趣">
      <UniqueIdentifier>{97c1a493-fefc-48b1-a4e8-5178e0b9e4ec}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Parallel and Distributed Programming Using C++（C++ 并行与分布式编程）\第1章 并发编程的乐趣\1.1 什么是并发？">
      <UniqueIdentifier>{9e4abc1d-cf98-4977-9dff-de075fedfba6}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Parallel and Distributed Programming Using C++（C++ 并行与分布式编程）\第1章 并发编程的乐趣\1.2 并行编程的优点">
      <UniqueIdentifier>{80b47604-7d03-4b32-870c-50f926ff3fd3}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Parallel and Distributed Programming Using C++（C++ 并行与分布式编程）\第1章 并发编程的乐趣\1.3 分布式编程的优点">
      <UniqueIdentifier>{054244c1-b61c-458a-be25-4dd16d74c150}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Parallel and Distributed Programming Using C++（C++ 并行与分布式编程）\第1章 并发编程的乐趣\1.4 最少的工作需求">
      <UniqueIdentifier>{19f42276-8f0d-433b-be7d-013561ce4c72}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Parallel and Distributed Programming Using C++（C++ 并行与分布式编程）\第1章 并发编程的乐趣\1.5 软件并发的基本层次">
      <UniqueIdentifier>{3aad3b8c-52a0-4b66-928e-1d285da6de21}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Parallel and Distributed Programming Using C++（C++ 并行与分布式编程）\第1章 并发编程的乐趣\1.6 C++中没有支持并行性的关键字">
      <UniqueIdentifier>{2ddd9587-88fc-48a5-83e7-1a85fdd5b5c4}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Parallel and Distributed Programming Using C++（C++ 并行与分布式编程）\第1章 并发编程的乐趣\1.7 并行和分布式编程的编程环境">
      <UniqueIdentifier>{8074d47c-a937-41b6-b4fe-292cbe355cd2}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Parallel and Distributed Programming Using C++（C++ 并行与分布式编程）\第1章 并发编程的乐趣\小结——关于并发">
      <UniqueIdentifier>{8b5eed9a-db52-4678-a11c-d50197d9eca3}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Parallel and Distributed Programming Using C++（C++ 并行与分布式编程）\第2章 并行和分布式编程的挑战">
      <UniqueIdentifier>{62d70e8a-65e8-449e-a585-c9b390a0c604}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Parallel and Distributed Programming Using C++（C++ 并行与分布式编程）\第2章 并行和分布式编程的挑战\2.1 范例转移">
      <UniqueIdentifier>{c71aa97e-d0e2-4607-81ae-1337d5321ef4}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Parallel and Distributed Programming Using C++（C++ 并行与分布式编程）\第2章 并行和分布式编程的挑战\2.2 协调问题">
      <UniqueIdentifier>{a0de86b7-ebf6-4411-b6fb-74473f0c035c}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Parallel and Distributed Programming Using C++（C++ 并行与分布式编程）\第2章 并行和分布式编程的挑战\2.3 间或的硬件失效与软件退出">
      <UniqueIdentifier>{2c094e26-f6b4-4394-9c6f-dcb0279b5f8e}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Parallel and Distributed Programming Using C++（C++ 并行与分布式编程）\第2章 并行和分布式编程的挑战\2.4 过多的并行化或分布式可能产生负面后果">
      <UniqueIdentifier>{ccf07c30-ba28-40c7-a6e0-3391939873ca}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Parallel and Distributed Programming Using C++（C++ 并行与分布式编程）\第2章 并行和分布式编程的挑战\2.5 选择一种好的体系结构需要进行研究">
      <UniqueIdentifier>{d8a45726-6db4-4c2d-b323-9dd020a9ca9f}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Parallel and Distributed Programming Using C++（C++ 并行与分布式编程）\第2章 并行和分布式编程的挑战\2.6 对不同测试和调试技术的需求">
      <UniqueIdentifier>{6828f4ab-eb73-4a2a-bee7-86dc40020d30}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Parallel and Distributed Programming Using C++（C++ 并行与分布式编程）\第2章 并行和分布式编程的挑战\2.7 在并行或分布式设计中必须进行交流">
      <UniqueIdentifier>{377f52d1-b67a-4369-b6bb-ad330ba4e0b9}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Parallel and Distributed Programming Using C++（C++ 并行与分布式编程）\第2章 并行和分布式编程的挑战\小结">
      <UniqueIdentifier>{5d32514e-779d-4138-809b-d13c9b6a02c7}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Parallel and Distributed Programming Using C++（C++ 并行与分布式编程）\第3章 将C++程序分成多个任务">
      <UniqueIdentifier>{a2ab10d5-03ce-4365-b03a-e7386eb03bb0}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Parallel and Distributed Programming Using C++（C++ 并行与分布式编程）\第3章 将C++程序分成多个任务\3.1 进程的定义">
      <UniqueIdentifier>{8c33fb37-a153-4fad-bbe4-8fab90fca721}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Parallel and Distributed Programming Using C++（C++ 并行与分布式编程）\第3章 将C++程序分成多个任务\3.2 进程剖析">
      <UniqueIdentifier>{06ddb39d-df5b-4e44-aef9-997ae7e0bb2f}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Parallel and Distributed Programming Using C++（C++ 并行与分布式编程）\第3章 将C++程序分成多个任务\3.3 进程状态">
      <UniqueIdentifier>{6c1a4fce-2842-4d8c-9060-b453ab53d591}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Parallel and Distributed Programming Using C++（C++ 并行与分布式编程）\第3章 将C++程序分成多个任务\3.4 进程调度">
      <UniqueIdentifier>{529d6918-0112-4c55-9d36-9749290f0f71}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Parallel and Distributed Programming Using C++（C++ 并行与分布式编程）\第3章 将C++程序分成多个任务\3.5 上下文切换">
      <UniqueIdentifier>{68057764-9349-4043-8af0-02c36744c4fb}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Parallel and Distributed Programming Using C++（C++ 并行与分布式编程）\第3章 将C++程序分成多个任务\3.6 创建进程">
      <UniqueIdentifier>{16bf29c2-d927-4a9d-bf4a-f8cde2dd119e}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Parallel and Distributed Programming Using C++（C++ 并行与分布式编程）\第3章 将C++程序分成多个任务\3.7 终止进程">
      <UniqueIdentifier>{f7587fb1-5b8b-45e0-8124-acd11c1a509a}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Parallel and Distributed Programming Using C++（C++ 并行与分布式编程）\第3章 将C++程序分成多个任务\3.8 进程资源">
      <UniqueIdentifier>{0513816d-bb7a-4aee-82f3-615d976b8512}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Parallel and Distributed Programming Using C++（C++ 并行与分布式编程）\第3章 将C++程序分成多个任务\3.9 什么是异步进程和同步进程">
      <UniqueIdentifier>{5d29aeef-1be1-4876-be51-a01d2ea18aa4}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Parallel and Distributed Programming Using C++（C++ 并行与分布式编程）\第3章 将C++程序分成多个任务\3.10 将程序分成多个任务">
      <UniqueIdentifier>{456b876d-534a-4205-942f-66d0c393bc68}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Parallel and Distributed Programming Using C++（C++ 并行与分布式编程）\第3章 将C++程序分成多个任务\小结">
      <UniqueIdentifier>{9fd0585f-d7ae-4a14-b048-927bca9c463d}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Parallel and Distributed Programming Using C++（C++ 并行与分布式编程）\第4章 将C++程序分成多个线程">
      <UniqueIdentifier>{335f5efd-a594-47b1-8deb-8c145fff257e}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Parallel and Distributed Programming Using C++（C++ 并行与分布式编程）\第4章 将C++程序分成多个线程\4.1 线程的定义">
      <UniqueIdentifier>{3995696f-793b-41cd-a04e-2da62effbb2c}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Parallel and Distributed Programming Using C++（C++ 并行与分布式编程）\第4章 将C++程序分成多个线程\4.2 线程剖析">
      <UniqueIdentifier>{68b22f57-50b3-4cdf-80cb-964a40fa89e6}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Parallel and Distributed Programming Using C++（C++ 并行与分布式编程）\第4章 将C++程序分成多个线程\4.3 线程调度">
      <UniqueIdentifier>{2ec33c24-5b99-4a09-82a3-e88e3756dbdf}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Parallel and Distributed Programming Using C++（C++ 并行与分布式编程）\第4章 将C++程序分成多个线程\4.4 线程资源">
      <UniqueIdentifier>{9c53eb1d-4513-4a2d-b517-a5765c497298}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Parallel and Distributed Programming Using C++（C++ 并行与分布式编程）\第4章 将C++程序分成多个线程\4.5 线程模型">
      <UniqueIdentifier>{2cda5609-0fec-4b65-87ab-39536b9ab2ac}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Parallel and Distributed Programming Using C++（C++ 并行与分布式编程）\第4章 将C++程序分成多个线程\4.6 Pthread库介绍">
      <UniqueIdentifier>{a72abeae-394a-4c6d-a5c9-00e69450fd3c}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Parallel and Distributed Programming Using C++（C++ 并行与分布式编程）\第4章 将C++程序分成多个线程\4.7 简单多线程程序剖析">
      <UniqueIdentifier>{ac529bb8-20f5-42dc-a906-fd26e819c4d1}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Parallel and Distributed Programming Using C++（C++ 并行与分布式编程）\第4章 将C++程序分成多个线程\4.8 创建线程">
      <UniqueIdentifier>{0e7daba6-444a-42df-94ef-ba0757e3559c}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Parallel and Distributed Programming Using C++（C++ 并行与分布式编程）\第4章 将C++程序分成多个线程\4.9 管理线程">
      <UniqueIdentifier>{a2154942-9cc1-406a-916b-2ea77db224ac}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Parallel and Distributed Programming Using C++（C++ 并行与分布式编程）\第4章 将C++程序分成多个线程\4.10 线程安全和线程库">
      <UniqueIdentifier>{523dbc01-d69f-4631-84d5-6433efa05765}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Parallel and Distributed Programming Using C++（C++ 并行与分布式编程）\第4章 将C++程序分成多个线程\4.11 将程序分解成多个线程">
      <UniqueIdentifier>{d0033632-0323-4e8c-a6ca-85bf3f07e11f}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Parallel and Distributed Programming Using C++（C++ 并行与分布式编程）\第4章 将C++程序分成多个线程\小结">
      <UniqueIdentifier>{9907d18d-2e27-4e01-ac60-9c9fe6883542}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Parallel and Distributed Programming Using C++（C++ 并行与分布式编程）\第5章 任务间并发的同步">
      <UniqueIdentifier>{6332a1cc-d8e9-4b20-92d2-e6a00bc79cc9}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Parallel and Distributed Programming Using C++（C++ 并行与分布式编程）\第5章 任务间并发的同步\5.1 执行顺序的协调">
      <UniqueIdentifier>{aecae277-dec9-4f69-a44c-7479bd4925e1}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Parallel and Distributed Programming Using C++（C++ 并行与分布式编程）\第5章 任务间并发的同步\5.2 同步数据访问">
      <UniqueIdentifier>{45dd314a-f9fc-43b0-ba55-5c9b8cdb7e04}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Parallel and Distributed Programming Using C++（C++ 并行与分布式编程）\第5章 任务间并发的同步\5.3 什么是信号量？">
      <UniqueIdentifier>{00fcd34c-20b9-449f-aada-e25de7f07fc3}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Parallel and Distributed Programming Using C++（C++ 并行与分布式编程）\第5章 任务间并发的同步\5.4 面向对象的同步方法">
      <UniqueIdentifier>{14e3732e-62d5-4f1c-84c1-e97b37d05fb9}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Parallel and Distributed Programming Using C++（C++ 并行与分布式编程）\第5章 任务间并发的同步\小结">
      <UniqueIdentifier>{10a5d580-89d9-4266-8bdf-bc0df1ad6d28}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Parallel and Distributed Programming Using C++（C++ 并行与分布式编程）\第6章 通过PVM为C++增加并行编程能力">
      <UniqueIdentifier>{8cc15a4b-2867-409c-8bc7-d05585fd5ff9}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Parallel and Distributed Programming Using C++（C++ 并行与分布式编程）\第6章 通过PVM为C++增加并行编程能力\6.1 PVM支持的经典并行模型">
      <UniqueIdentifier>{9f2b9687-49cb-4da0-bdf3-101b9f87bdef}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Parallel and Distributed Programming Using C++（C++ 并行与分布式编程）\第6章 通过PVM为C++增加并行编程能力\6.2 为C++语言提供的PVM库">
      <UniqueIdentifier>{fc21039d-9b6c-4a39-8779-1de97e4f72ba}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Parallel and Distributed Programming Using C++（C++ 并行与分布式编程）\第6章 通过PVM为C++增加并行编程能力\6.3 PVM的基本机制">
      <UniqueIdentifier>{5a0a849f-f981-421e-86df-d7e7170a57d9}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Parallel and Distributed Programming Using C++（C++ 并行与分布式编程）\第6章 通过PVM为C++增加并行编程能力\6.4 在PVM任务中访问标准输入（stdin）和标准输出（stdout）">
      <UniqueIdentifier>{2037bb66-abf7-432a-8c32-ddf9c6c94575}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Parallel and Distributed Programming Using C++（C++ 并行与分布式编程）\第6章 通过PVM为C++增加并行编程能力\小结">
      <UniqueIdentifier>{7e765242-93c6-4558-815f-f7cb6e4f6734}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Parallel and Distributed Programming Using C++（C++ 并行与分布式编程）\第7章 错误处理、异常和软件可靠性">
      <UniqueIdentifier>{0838ec78-62fa-4b91-af15-224ebcd2212f}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Parallel and Distributed Programming Using C++（C++ 并行与分布式编程）\第7章 错误处理、异常和软件可靠性\7.1 什么是软件可靠性？">
      <UniqueIdentifier>{f066d617-4b64-4837-8fc6-d0390ea3c74b}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Parallel and Distributed Programming Using C++（C++ 并行与分布式编程）\第7章 错误处理、异常和软件可靠性\7.2 软件层和硬件组件中的失效">
      <UniqueIdentifier>{bc9a0f71-9fd3-40c6-9837-dc79cd9f1288}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Parallel and Distributed Programming Using C++（C++ 并行与分布式编程）\第7章 错误处理、异常和软件可靠性\7.3 依赖于软件规范的缺陷定义">
      <UniqueIdentifier>{229cee28-8195-49a0-b0a6-b6d64c260706}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Parallel and Distributed Programming Using C++（C++ 并行与分布式编程）\第7章 错误处理、异常和软件可靠性\7.4 考虑在哪里处理缺陷与在哪里处理异常">
      <UniqueIdentifier>{fb06631c-8048-4ae8-ae5b-edeb98eecde3}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Parallel and Distributed Programming Using C++（C++ 并行与分布式编程）\第7章 错误处理、异常和软件可靠性\7.5 软件可靠性：一个简单方案">
      <UniqueIdentifier>{021e0c0c-0edb-47a5-8466-faa5b879be8d}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Parallel and Distributed Programming Using C++（C++ 并行与分布式编程）\第7章 错误处理、异常和软件可靠性\7.6 在错误处理中使用Map对象">
      <UniqueIdentifier>{67f5cef3-c2c2-47f0-bb9e-af353ae43fe6}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Parallel and Distributed Programming Using C++（C++ 并行与分布式编程）\第7章 错误处理、异常和软件可靠性\7.7 C++的异常处理机制">
      <UniqueIdentifier>{8dc87d62-a679-4029-b3c9-2a12b8427ee1}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Parallel and Distributed Programming Using C++（C++ 并行与分布式编程）\第7章 错误处理、异常和软件可靠性\7.8 事件图、逻辑表达式和逻辑图">
      <UniqueIdentifier>{517a67df-7c9e-4e4a-be46-cf5d85f7e304}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Parallel and Distributed Programming Using C++（C++ 并行与分布式编程）\第7章 错误处理、异常和软件可靠性\小结">
      <UniqueIdentifier>{accbf536-ec9d-4078-97d2-b835a5916d02}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Parallel and Distributed Programming Using C++（C++ 并行与分布式编程）\第8章 C++分布式面向对象编程">
      <UniqueIdentifier>{8a139137-04f4-44f0-a983-f83ff9cb300e}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Parallel and Distributed Programming Using C++（C++ 并行与分布式编程）\第8章 C++分布式面向对象编程\8.1 工作的分解与封装">
      <UniqueIdentifier>{69baca43-2a0e-4bea-9e4f-063066e9784f}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Parallel and Distributed Programming Using C++（C++ 并行与分布式编程）\第8章 C++分布式面向对象编程\8.2 访问其他地址空间中对象">
      <UniqueIdentifier>{759a54f8-df60-4993-b6fe-1493a6490b24}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Parallel and Distributed Programming Using C++（C++ 并行与分布式编程）\第8章 C++分布式面向对象编程\8.3 基本CORBA消费者剖析">
      <UniqueIdentifier>{60f97b76-8456-4bae-a17d-2692efb4ae2d}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Parallel and Distributed Programming Using C++（C++ 并行与分布式编程）\第8章 C++分布式面向对象编程\8.4 CORBA生产者剖析">
      <UniqueIdentifier>{3f33edef-2670-49e2-8e8b-eca8fb9b2193}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Parallel and Distributed Programming Using C++（C++ 并行与分布式编程）\第8章 C++分布式面向对象编程\8.5 CORBA应用程序的基本设计蓝图">
      <UniqueIdentifier>{b9225da8-331c-4a6d-9a5e-4fc56448736f}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Parallel and Distributed Programming Using C++（C++ 并行与分布式编程）\第8章 C++分布式面向对象编程\8.6 名字服务">
      <UniqueIdentifier>{600ce9c7-62df-4379-b453-21efd9c0e753}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Parallel and Distributed Programming Using C++（C++ 并行与分布式编程）\第8章 C++分布式面向对象编程\8.7 深入了解对象适配器">
      <UniqueIdentifier>{04d16953-516f-4475-b763-00da133c7c79}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Parallel and Distributed Programming Using C++（C++ 并行与分布式编程）\第8章 C++分布式面向对象编程\8.8 实现池与接口池">
      <UniqueIdentifier>{296f6622-fd5d-4c41-bd92-d35ae843bb40}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Parallel and Distributed Programming Using C++（C++ 并行与分布式编程）\第8章 C++分布式面向对象编程\8.9 使用CORBA的简单分布式Web服务">
      <UniqueIdentifier>{efdd80b6-6205-4ccf-b238-91798b677155}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Parallel and Distributed Programming Using C++（C++ 并行与分布式编程）\第8章 C++分布式面向对象编程\8.10 交易服务">
      <UniqueIdentifier>{b1266113-65bb-4a53-a26c-2d96c674b905}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Parallel and Distributed Programming Using C++（C++ 并行与分布式编程）\第8章 C++分布式面向对象编程\8.11 客户/服务器范例">
      <UniqueIdentifier>{5a14aab9-9ba3-4d84-9f7a-a52081fb1051}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Parallel and Distributed Programming Using C++（C++ 并行与分布式编程）\第8章 C++分布式面向对象编程\小结">
      <UniqueIdentifier>{d816ed4c-9f97-4ff7-b06b-d0359c44f0ff}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Parallel and Distributed Programming Using C++（C++ 并行与分布式编程）\第9章 MPI与使用模板的SPMD和MPMD模型">
      <UniqueIdentifier>{72d772b5-ee4c-4d4e-9574-9f29aa002cb3}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Parallel and Distributed Programming Using C++（C++ 并行与分布式编程）\第9章 MPI与使用模板的SPMD和MPMD模型\9.1 MPI的工作分解结构">
      <UniqueIdentifier>{588927ea-41de-4b06-bef7-0408b70cba6c}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Parallel and Distributed Programming Using C++（C++ 并行与分布式编程）\第9章 MPI与使用模板的SPMD和MPMD模型\9.2 使用模板函数表示MPI任务">
      <UniqueIdentifier>{680397be-1c54-4e2f-a15f-8d32141bfc0d}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Parallel and Distributed Programming Using C++（C++ 并行与分布式编程）\第9章 MPI与使用模板的SPMD和MPMD模型\9.3 简化MPI通信">
      <UniqueIdentifier>{e1f42f3d-94c2-47c9-b76b-359eb77855c7}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Parallel and Distributed Programming Using C++（C++ 并行与分布式编程）\第9章 MPI与使用模板的SPMD和MPMD模型\小结">
      <UniqueIdentifier>{3f4e6d73-ede5-471e-a3d4-108314e0b571}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Parallel and Distributed Programming Using C++（C++ 并行与分布式编程）\第10章 可视化并发和分布式系统设计">
      <UniqueIdentifier>{a7ec0d58-b5d0-4946-963e-f48d9a111c1b}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Parallel and Distributed Programming Using C++（C++ 并行与分布式编程）\第10章 可视化并发和分布式系统设计\10.1 可视化结构">
      <UniqueIdentifier>{a2b2609d-490d-4980-9bb6-0082bb133bb1}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Parallel and Distributed Programming Using C++（C++ 并行与分布式编程）\第10章 可视化并发和分布式系统设计\10.2 可视化并发行为">
      <UniqueIdentifier>{fc976deb-af61-4890-b53b-d4075c0a654e}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Parallel and Distributed Programming Using C++（C++ 并行与分布式编程）\第10章 可视化并发和分布式系统设计\10.3 可视化整个系统">
      <UniqueIdentifier>{b495cb13-b0a0-4417-9c91-68b230f1391d}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Parallel and Distributed Programming Using C++（C++ 并行与分布式编程）\第10章 可视化并发和分布式系统设计\小结">
      <UniqueIdentifier>{b10527fe-33bd-486d-a89f-058191ef8e4f}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Parallel and Distributed Programming Using C++（C++ 并行与分布式编程）\第11章 设计支持并发的组件">
      <UniqueIdentifier>{c9f164ad-87e5-445b-925f-4ddcdbb4b121}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Parallel and Distributed Programming Using C++（C++ 并行与分布式编程）\第11章 设计支持并发的组件\11.1 使用接口类">
      <UniqueIdentifier>{427a3ff9-ae5f-4ddd-82c1-d75a05495ea6}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Parallel and Distributed Programming Using C++（C++ 并行与分布式编程）\第11章 设计支持并发的组件\11.2 深入了解面向对象的互斥和接口类">
      <UniqueIdentifier>{a77bb2b8-e2e7-42ab-873c-24e756970d96}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Parallel and Distributed Programming Using C++（C++ 并行与分布式编程）\第11章 设计支持并发的组件\11.3 保持流隐喻">
      <UniqueIdentifier>{9be3b618-d2fd-4bd1-9d92-2879c8f333f7}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Parallel and Distributed Programming Using C++（C++ 并行与分布式编程）\第11章 设计支持并发的组件\11.4 与PVM流协同工作的自定义类的设计">
      <UniqueIdentifier>{a65a0d3a-1888-4a2c-b692-7d59f5d2b348}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Parallel and Distributed Programming Using C++（C++ 并行与分布式编程）\第11章 设计支持并发的组件\11.5 把面向对象的管道和fifo作为低级建块">
      <UniqueIdentifier>{89b32640-efd0-4a41-9be1-03cab3d14f68}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Parallel and Distributed Programming Using C++（C++ 并行与分布式编程）\第11章 设计支持并发的组件\11.6 支持并发的框架类组件">
      <UniqueIdentifier>{b901e7ac-d6ea-453e-9027-1e1c5bb0534d}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Parallel and Distributed Programming Using C++（C++ 并行与分布式编程）\第11章 设计支持并发的组件\小结">
      <UniqueIdentifier>{48461362-689c-401e-8f7d-7e0e03e5d2f2}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Parallel and Distributed Programming Using C++（C++ 并行与分布式编程）\第12章 实现面向agent的体系结构">
      <UniqueIdentifier>{cec6bfd4-d845-4fb2-98ae-48933170fca0}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Parallel and Distributed Programming Using C++（C++ 并行与分布式编程）\第12章 实现面向agent的体系结构\12.1 什么是agent？">
      <UniqueIdentifier>{0681a365-b665-4cf2-9d08-2bba7465f731}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Parallel and Distributed Programming Using C++（C++ 并行与分布式编程）\第12章 实现面向agent的体系结构\12.2 什么是面向agent编程？">
      <UniqueIdentifier>{9cf11b8a-73ba-4feb-8214-601a9cee0913}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Parallel and Distributed Programming Using C++（C++ 并行与分布式编程）\第12章 实现面向agent的体系结构\12.3 基本agent组件">
      <UniqueIdentifier>{fe4714e2-46fa-4c93-9a30-4fb480b25af6}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Parallel and Distributed Programming Using C++（C++ 并行与分布式编程）\第12章 实现面向agent的体系结构\12.4 用C++实现agent">
      <UniqueIdentifier>{86f57cd4-8095-448c-b5a5-8d8b9863cfd9}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Parallel and Distributed Programming Using C++（C++ 并行与分布式编程）\第12章 实现面向agent的体系结构\12.5 多agent系统">
      <UniqueIdentifier>{8f42ef4f-50b7-48c3-b8a0-64d41d4520c9}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Parallel and Distributed Programming Using C++（C++ 并行与分布式编程）\第12章 实现面向agent的体系结构\小结">
      <UniqueIdentifier>{d7047562-75f9-4779-99bf-aff6e982c6d7}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Parallel and Distributed Programming Using C++（C++ 并行与分布式编程）\第13章 使用PVM、线程和C++组件的黑板体系结构">
      <UniqueIdentifier>{b6df7cb4-2d3d-4359-9710-8335b30a195b}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Parallel and Distributed Programming Using C++（C++ 并行与分布式编程）\第13章 使用PVM、线程和C++组件的黑板体系结构\13.1 黑板模型">
      <UniqueIdentifier>{6c9e3ec7-fb44-4a27-beb8-10b54b6ed6a3}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Parallel and Distributed Programming Using C++（C++ 并行与分布式编程）\第13章 使用PVM、线程和C++组件的黑板体系结构\13.2 构造黑板的方法">
      <UniqueIdentifier>{c0c406de-e13f-4c90-97ed-1c0382c37478}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Parallel and Distributed Programming Using C++（C++ 并行与分布式编程）\第13章 使用PVM、线程和C++组件的黑板体系结构\13.3 知识库剖析">
      <UniqueIdentifier>{8d8df153-154b-4ffa-8ce4-219dbed00303}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Parallel and Distributed Programming Using C++（C++ 并行与分布式编程）\第13章 使用PVM、线程和C++组件的黑板体系结构\13.4 黑板的控制策略">
      <UniqueIdentifier>{e29d09ee-277c-4e7d-90d1-c5763311245d}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Parallel and Distributed Programming Using C++（C++ 并行与分布式编程）\第13章 使用PVM、线程和C++组件的黑板体系结构\13.5 使用CORBA对象实现黑板">
      <UniqueIdentifier>{050205a5-4989-4109-95bb-6a4b342c5244}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Parallel and Distributed Programming Using C++（C++ 并行与分布式编程）\第13章 使用PVM、线程和C++组件的黑板体系结构\13.6 使用全局对象实现黑板">
      <UniqueIdentifier>{14cd27a0-b32f-404a-9d10-b4990d4fc70a}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Parallel and Distributed Programming Using C++（C++ 并行与分布式编程）\第13章 使用PVM、线程和C++组件的黑板体系结构\13.7 使用Pthread激活知识库">
      <UniqueIdentifier>{26b750fc-2223-44ff-96c2-3f93db0ef093}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Parallel and Distributed Programming Using C++（C++ 并行与分布式编程）\第13章 使用PVM、线程和C++组件的黑板体系结构\小结">
      <UniqueIdentifier>{707bd6e7-566a-4cc2-90e0-ddab86ab662e}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Parallel and Distributed Programming Using C++（C++ 并行与分布式编程）\附录A 类与对象图解">
      <UniqueIdentifier>{32d40bf9-d841-42da-a454-372af64bccf4}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Parallel and Distributed Programming Using C++（C++ 并行与分布式编程）\附录B 系统接口">
      <UniqueIdentifier>{48ade444-08b7-4d1b-8e3b-c2d8c7dcc8dc}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\0.">
      <UniqueIdentifier>{dcf7cb01-2ab4-4c9f-9603-58e880eef64d}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\0.\0.1 致谢">
      <UniqueIdentifier>{ac9e666b-cc74-40b6-9d7d-5ece9fca677c}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\0.\0.2 前言">
      <UniqueIdentifier>{4fd2814c-3011-4dc0-a2ce-2a6700d28968}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\0.\0.2 前言\0.2.1 路线图">
      <UniqueIdentifier>{a2c381c8-2f92-400f-a518-e602100eeacf}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\0.\0.2 前言\0.2.2 谁应该阅读本书">
      <UniqueIdentifier>{3032b5e5-ce5f-4319-9d8f-a4ff33dce561}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\0.\0.2 前言\0.2.3 如何使用本书">
      <UniqueIdentifier>{d7736726-8103-48e4-8f75-877b420c7421}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\0.\0.2 前言\0.2.4 代码约定和下载">
      <UniqueIdentifier>{9e568540-c5e0-4f05-9fd6-6c2cf37209d2}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\0.\0.2 前言\0.2.5 软件需求">
      <UniqueIdentifier>{e24b5d96-37c1-45ac-9e3a-0c4a87108e26}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\0.\0.2 前言\0.2.6 作者在线">
      <UniqueIdentifier>{f717c064-c660-489f-9cf6-90442274e5c4}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\0.\0.3 资源">
      <UniqueIdentifier>{ba350398-83d5-49c5-9752-328751f9ae40}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第1章 你好，C++并发世界">
      <UniqueIdentifier>{a827e1a8-82d9-4651-9946-1af33864075f}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第1章 你好，C++并发世界\1.1 什么是并发">
      <UniqueIdentifier>{7f09be1b-fc92-414b-9c5e-72191442335d}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第1章 你好，C++并发世界\1.1 什么是并发\1.1.1 计算机系统中的并发">
      <UniqueIdentifier>{8a50f115-7434-452c-81c6-73240576b887}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第1章 你好，C++并发世界\1.1 什么是并发\1.1.2 并发的途径">
      <UniqueIdentifier>{3ae659a2-79ad-455b-b830-69b30572dd84}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第1章 你好，C++并发世界\1.2 为什么使用并发">
      <UniqueIdentifier>{90885fa3-2924-439f-a530-9461076cb36f}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第1章 你好，C++并发世界\1.2 为什么使用并发\1.2.1 为了划分关注点而使用并发">
      <UniqueIdentifier>{093053f5-804a-42fb-bf6c-dfaabfa1fe05}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第1章 你好，C++并发世界\1.2 为什么使用并发\1.2.2 为了性能而使用并发">
      <UniqueIdentifier>{791b1e7b-dbf5-46f1-bd7c-31c1f4e23fca}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第1章 你好，C++并发世界\1.2 为什么使用并发\1.2.3 什么时候不使用并发">
      <UniqueIdentifier>{d8384144-f3e4-473c-85c6-60d43fcdd074}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第1章 你好，C++并发世界\1.3 在C++中使用并发和多线程">
      <UniqueIdentifier>{b8f111b2-ec25-4aa1-abbc-786bb37e9a4e}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第1章 你好，C++并发世界\1.4 开始入门">
      <UniqueIdentifier>{b767ecb4-2fb5-4337-955e-36069849b3fb}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第1章 你好，C++并发世界\1.5 小结">
      <UniqueIdentifier>{9f2aa775-9946-4d6f-8564-19c8dfe75462}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第1章 你好，C++并发世界\1.3 在C++中使用并发和多线程\1.3.1 C++多线程历程">
      <UniqueIdentifier>{bb81780f-5cd3-4f98-a19c-32ebd7abb054}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第1章 你好，C++并发世界\1.3 在C++中使用并发和多线程\1.3.2 新标准中的并发支持">
      <UniqueIdentifier>{6c6e16f4-577c-41c8-953c-b9bbe9f2d1de}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第1章 你好，C++并发世界\1.3 在C++中使用并发和多线程\1.3.3 C++线程库的效率">
      <UniqueIdentifier>{6dceee23-2f12-4d9f-9a56-088ddb8fa58a}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第1章 你好，C++并发世界\1.3 在C++中使用并发和多线程\1.3.4 平台相关的工具">
      <UniqueIdentifier>{ff53c87f-58f2-4466-a633-702c389b9154}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第2章 管理线程">
      <UniqueIdentifier>{6802d1ba-6b2d-425d-ac40-424bd5959da2}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第2章 管理线程\2.1 基本线程管理">
      <UniqueIdentifier>{30030947-e951-4a3d-9d4c-cd9208fa726e}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第2章 管理线程\2.1 基本线程管理\2.1.1 启动线程">
      <UniqueIdentifier>{03a87611-6b81-4c8c-a8a9-1bb2070dd520}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第2章 管理线程\2.1 基本线程管理\2.1.2 等待线程完成">
      <UniqueIdentifier>{21a9574c-3dc4-43e3-ac13-d8b9240faf3e}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第2章 管理线程\2.1 基本线程管理\2.1.3 在异常环境下的等待">
      <UniqueIdentifier>{5da74efe-f688-4c03-8f2b-21faa3555326}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第2章 管理线程\2.1 基本线程管理\2.1.4 在后台运行线程">
      <UniqueIdentifier>{f5f1d90f-245f-47b8-961a-1ae03c7ceeb7}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第2章 管理线程\2.2 传递参数给线程函数">
      <UniqueIdentifier>{48e0bbd7-2062-4c5f-9f6f-dbdc66ae500f}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第2章 管理线程\2.3 转移线程的所有权">
      <UniqueIdentifier>{22c347ae-7261-4304-b35f-fe14aedcd92a}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第2章 管理线程\2.4 在运行时选择线程数量">
      <UniqueIdentifier>{c1627ac8-67c4-475f-b903-4484f3f4fae0}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第2章 管理线程\2.5 标识线程">
      <UniqueIdentifier>{2e48a7ff-365c-4c1d-a4cb-7a7412390362}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第2章 管理线程\2.6 小结">
      <UniqueIdentifier>{57730c91-d238-4a88-9052-7d3bd81bc970}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第3章 在线程间共享数据">
      <UniqueIdentifier>{b2460382-d7c4-45d6-b20c-16939726d505}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第3章 在线程间共享数据\3.1 线程之间共享数据的问题">
      <UniqueIdentifier>{58d73171-8fcd-4837-bd7e-705e4ad4680b}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第3章 在线程间共享数据\3.1 线程之间共享数据的问题\3.1.1 竞争条件">
      <UniqueIdentifier>{25304b07-fe70-4d37-b8b7-75476e0f63d3}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第3章 在线程间共享数据\3.1 线程之间共享数据的问题\3.1.2 避免有问题的竞争条件">
      <UniqueIdentifier>{8c023747-406e-47b7-9ea7-2318e4a59687}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第3章 在线程间共享数据\3.2 用互斥元保护共享数据">
      <UniqueIdentifier>{25eb4122-bfef-487f-a1ce-754608862fe5}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第3章 在线程间共享数据\3.2 用互斥元保护共享数据\3.2.1 使用C++中的互斥元">
      <UniqueIdentifier>{f8bf6cb5-9e45-4ccb-920c-d44bffc840cf}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第3章 在线程间共享数据\3.2 用互斥元保护共享数据\3.2.2 为保护共享数据精心组织代码">
      <UniqueIdentifier>{af51ea3e-efdb-4d1f-97cd-325b648242ac}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第3章 在线程间共享数据\3.2 用互斥元保护共享数据\3.2.3 发现接口中固有的竞争条件">
      <UniqueIdentifier>{33245ef2-3425-479e-8a45-3768ed3ef5cd}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第3章 在线程间共享数据\3.2 用互斥元保护共享数据\3.2.4 死锁：问题和解决方案">
      <UniqueIdentifier>{6817e1c2-7cb8-4bb9-b639-aaae73203323}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第3章 在线程间共享数据\3.2 用互斥元保护共享数据\3.2.5 避免死锁的进一步指南">
      <UniqueIdentifier>{4024e255-3683-4707-be19-59599b02b002}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第3章 在线程间共享数据\3.2 用互斥元保护共享数据\3.2.6 用std::unique_lock灵活锁定">
      <UniqueIdentifier>{30adb6f5-a442-4421-9f55-d23286847f01}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第3章 在线程间共享数据\3.2 用互斥元保护共享数据\3.2.7 在作用域之间转移锁的所有权">
      <UniqueIdentifier>{e5c5dd76-9760-4c2b-b183-6dfe83bcc393}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第3章 在线程间共享数据\3.2 用互斥元保护共享数据\3.2.8 锁定在恰当的粒度">
      <UniqueIdentifier>{9630f0e0-0b79-433b-9b33-018bcf6e4c30}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第3章 在线程间共享数据\3.3 用于共享数据保护的替代工具">
      <UniqueIdentifier>{06f853fe-cf44-456b-99b0-0d33f6aa4c7a}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第3章 在线程间共享数据\3.3 用于共享数据保护的替代工具\3.3.1 在初始化时保护共享数据">
      <UniqueIdentifier>{9601902f-a1d0-4802-b574-69e24871a4b6}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第3章 在线程间共享数据\3.3 用于共享数据保护的替代工具\3.3.2 保护很少更新的数据结构">
      <UniqueIdentifier>{894ac8ff-c3ab-4ef1-a253-cdb3226ef8d9}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第3章 在线程间共享数据\3.3 用于共享数据保护的替代工具\3.3.3 递归锁">
      <UniqueIdentifier>{d15e7153-31a0-4e93-929f-7e5aae531233}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第3章 在线程间共享数据\3.4 小结">
      <UniqueIdentifier>{1e10cb1b-21c9-47ac-8913-d4111d796d48}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第4章 同步并发操作">
      <UniqueIdentifier>{bd2d5f66-1919-42bc-9781-23487efa995e}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第4章 同步并发操作\4.1 等待事件或其他条件">
      <UniqueIdentifier>{af965320-3bc7-401e-b6cf-8c0115b6e7b4}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第4章 同步并发操作\4.1 等待事件或其他条件\4.1.1 用条件变量等待条件">
      <UniqueIdentifier>{3f3ceb3c-6e6a-4ecb-9882-9aa72685e504}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第4章 同步并发操作\4.1 等待事件或其他条件\4.1.2 使用条件变量建立一个线程安全队列">
      <UniqueIdentifier>{5405ec0a-0eba-4059-b3a2-967d6b56e919}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第4章 同步并发操作\4.2 使用future等待一次性事件">
      <UniqueIdentifier>{6e0e01e9-b61a-4b87-a3b5-f254eeaa6ef4}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第4章 同步并发操作\4.2 使用future等待一次性事件\4.2.1 从后台任务中返回值">
      <UniqueIdentifier>{c1a00f08-fe28-4d97-b58a-0e1b70058b4a}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第4章 同步并发操作\4.2 使用future等待一次性事件\4.2.2 将任务与future相关联">
      <UniqueIdentifier>{e94370b7-c7f8-4d97-a1ac-b75d2c033066}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第4章 同步并发操作\4.2 使用future等待一次性事件\4.2.3 生成std::promise">
      <UniqueIdentifier>{dc44350e-1339-4435-baf7-6c0f441890e4}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第4章 同步并发操作\4.2 使用future等待一次性事件\4.2.4 为future保存异常">
      <UniqueIdentifier>{2ff1c393-535a-4111-8958-f9a9d620865b}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第4章 同步并发操作\4.2 使用future等待一次性事件\4.2.5 等待自多个线程">
      <UniqueIdentifier>{8c11be47-b9b8-414e-9917-be35ff0255ca}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第4章 同步并发操作\4.3 有时间限制的等待">
      <UniqueIdentifier>{b46916db-698a-4fda-9b7e-7190afbd3e47}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第4章 同步并发操作\4.3 有时间限制的等待\4.3.1 时钟">
      <UniqueIdentifier>{90a2af50-ccbc-4b96-aadc-276644a13008}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第4章 同步并发操作\4.3 有时间限制的等待\4.3.2 时间段">
      <UniqueIdentifier>{2a5d55c6-09de-48b6-885e-8cb5d6990262}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第4章 同步并发操作\4.3 有时间限制的等待\4.3.3 时间点">
      <UniqueIdentifier>{5ac54bc9-94ad-43f9-aaab-d64f25a3ef46}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第4章 同步并发操作\4.3 有时间限制的等待\4.3.4 接受超时的函数">
      <UniqueIdentifier>{3c6af607-ba52-462b-b103-450bea18fc59}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第4章 同步并发操作\4.4 使用操作同步来简化代码">
      <UniqueIdentifier>{fd7aa347-dacc-4b4e-a623-2475a7abcfab}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第4章 同步并发操作\4.4 使用操作同步来简化代码\4.4.1 带有future的函数式编程">
      <UniqueIdentifier>{40f7f1d7-583a-412e-8f39-b61073f1222a}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第4章 同步并发操作\4.4 使用操作同步来简化代码\4.4.2 具有消息传递的同步操作">
      <UniqueIdentifier>{c30a94b5-ec6c-452b-abd0-e33ab4b99b4a}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第4章 同步并发操作\4.5 小结">
      <UniqueIdentifier>{e6f8ddc0-54f6-47f4-9352-af9a589e6be3}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第5章 C++内存模型和原子类型上操作">
      <UniqueIdentifier>{98f6d927-45f6-41d1-ae50-44f68781a2d6}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第5章 C++内存模型和原子类型上操作\5.1 内存模型基础">
      <UniqueIdentifier>{d46959fb-cfbd-4960-932b-246ebbf5bc40}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第5章 C++内存模型和原子类型上操作\5.1 内存模型基础\5.1.1 对象和内存位置">
      <UniqueIdentifier>{da9553b4-7d5c-497c-8fca-ddc27b508e9b}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第5章 C++内存模型和原子类型上操作\5.1 内存模型基础\5.1.2 对象、内存位置以及并发">
      <UniqueIdentifier>{42bbcb7a-0ad4-4f6c-841d-840d200ec530}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第5章 C++内存模型和原子类型上操作\5.1 内存模型基础\5.1.3 修改顺序">
      <UniqueIdentifier>{bf89fa1d-3b46-45fe-9843-6d18d717e90c}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第5章 C++内存模型和原子类型上操作\5.2 C++中的原子操作及类型">
      <UniqueIdentifier>{ed18d9bd-4cf7-44fb-a848-cc1cba216c21}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第5章 C++内存模型和原子类型上操作\5.2 C++中的原子操作及类型\5.2.1 标准原子类型">
      <UniqueIdentifier>{7de34fab-d513-4da6-9c64-ad6592396218}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第5章 C++内存模型和原子类型上操作\5.2 C++中的原子操作及类型\5.2.2 std::atomic_flag上的操作">
      <UniqueIdentifier>{d4f4df98-7117-4a72-90dc-d6030657a0ca}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第5章 C++内存模型和原子类型上操作\5.2 C++中的原子操作及类型\5.2.3 基于std::atomicbool的操作">
      <UniqueIdentifier>{ca52cd28-d106-4c2c-b1cf-2c6671e9f2d0}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第5章 C++内存模型和原子类型上操作\5.2 C++中的原子操作及类型\5.2.4 std::atomicT%2a上的操作：指针算术运算">
      <UniqueIdentifier>{57de05a5-dc86-464f-814d-dad8ed590e3f}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第5章 C++内存模型和原子类型上操作\5.2 C++中的原子操作及类型\5.2.5 标准原子整型的操作">
      <UniqueIdentifier>{5b100b0e-40fe-4400-9217-2d97e64bb785}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第5章 C++内存模型和原子类型上操作\5.2 C++中的原子操作及类型\5.2.6 std::atomic初级类模板">
      <UniqueIdentifier>{43a61f6a-fe69-49f8-96e0-696a8989004a}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第5章 C++内存模型和原子类型上操作\5.2 C++中的原子操作及类型\5.2.7 原子操作的自由函数">
      <UniqueIdentifier>{d8eb0775-ccda-4b44-9482-f024e2c4cf4a}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第5章 C++内存模型和原子类型上操作\5.3 同步操作和强制顺序">
      <UniqueIdentifier>{81593452-af8f-45cd-8d35-346e74a3cf0b}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第5章 C++内存模型和原子类型上操作\5.3 同步操作和强制顺序\5.3.1 synchronizes-with关系">
      <UniqueIdentifier>{3503402b-b391-465d-baf2-fe983a286afb}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第5章 C++内存模型和原子类型上操作\5.3 同步操作和强制顺序\5.3.2 happens-before关系">
      <UniqueIdentifier>{717edd99-2b2f-4fc9-a4a7-4b53e6ef0d8c}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第5章 C++内存模型和原子类型上操作\5.3 同步操作和强制顺序\5.3.3 原子操作的内存顺序">
      <UniqueIdentifier>{9954df53-91ec-48cc-8e40-204bd600fa9e}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第5章 C++内存模型和原子类型上操作\5.3 同步操作和强制顺序\5.3.4 释放序列和synchronizes-with">
      <UniqueIdentifier>{64dcce09-8858-4edb-98c3-c8d95faa0174}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第5章 C++内存模型和原子类型上操作\5.3 同步操作和强制顺序\5.3.5 屏障">
      <UniqueIdentifier>{38abbdba-51b1-48db-a9cf-f4d4bd86617a}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第5章 C++内存模型和原子类型上操作\5.3 同步操作和强制顺序\5.3.6 用原子操作排序非原子操作">
      <UniqueIdentifier>{9e58b023-a0d7-44e2-9a74-af74cd4cd82e}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第5章 C++内存模型和原子类型上操作\5.4 小结">
      <UniqueIdentifier>{8c0be165-1800-4eda-b974-bf3f8dbac1a6}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第6章 设计基于锁的并发数据结构">
      <UniqueIdentifier>{b5bb6366-5705-4c2d-8a26-7e3d81f9e985}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第6章 设计基于锁的并发数据结构\6.1 为并发设计的含义是什么">
      <UniqueIdentifier>{4c21a251-d1f6-48bb-8dfd-0e1143f2944e}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第6章 设计基于锁的并发数据结构\6.2 基于锁的并发数据结构">
      <UniqueIdentifier>{9557645a-faa1-4ca5-977b-c6c2ba780459}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第6章 设计基于锁的并发数据结构\6.2 基于锁的并发数据结构\6.2.1 使用锁的线程安全栈">
      <UniqueIdentifier>{fc66aa22-83d4-4ca7-a1f1-f8b8c23ed4a4}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第6章 设计基于锁的并发数据结构\6.2 基于锁的并发数据结构\6.2.2 使用锁和条件变量的线程安全队列">
      <UniqueIdentifier>{192cb810-5c52-4589-8582-f19416f89cde}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第6章 设计基于锁的并发数据结构\6.2 基于锁的并发数据结构\6.2.3 使用细粒度锁和条件变量的线程安全队列">
      <UniqueIdentifier>{a1418ec5-3d43-41a9-aa0b-c2df2a0809ed}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第6章 设计基于锁的并发数据结构\6.3 设计更复杂的基于锁的数据结构">
      <UniqueIdentifier>{8fe11f70-a38f-44a0-8709-c09bbe3bef4b}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第6章 设计基于锁的并发数据结构\6.3 设计更复杂的基于锁的数据结构\6.3.1 编写一个使用锁的线程安全查找表">
      <UniqueIdentifier>{11a15901-b01f-437e-b9b4-c63d0fac1757}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第6章 设计基于锁的并发数据结构\6.3 设计更复杂的基于锁的数据结构\6.3.2 编写一个使用锁的线程安全链表">
      <UniqueIdentifier>{5f35051c-bbce-464b-8f60-912d3a89035f}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第6章 设计基于锁的并发数据结构\6.4 小结">
      <UniqueIdentifier>{a93f4664-839a-4cbb-9736-f307c8db50d8}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第7章 设计无锁的并发数据结构">
      <UniqueIdentifier>{9a587237-5175-4555-a6dc-22c3e2591ed2}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第7章 设计无锁的并发数据结构\7.1 定义和结果">
      <UniqueIdentifier>{3b2f9d09-4011-45f9-acda-255933459f1b}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第7章 设计无锁的并发数据结构\7.1 定义和结果\7.1.1 非阻塞数据结构的类型">
      <UniqueIdentifier>{57cde482-416f-4199-8ad6-861959e48927}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第7章 设计无锁的并发数据结构\7.1 定义和结果\7.1.2 无锁数据结构">
      <UniqueIdentifier>{52711f30-2165-4f72-a3b1-f366d5f3d1c2}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第7章 设计无锁的并发数据结构\7.1 定义和结果\7.1.3 无等待的数据结构">
      <UniqueIdentifier>{e7bc0090-96e4-4bb7-b4db-89892643a3b6}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第7章 设计无锁的并发数据结构\7.1 定义和结果\7.1.4 无锁数据结构的优点与缺点">
      <UniqueIdentifier>{2c9a5c8f-a425-4d42-a4af-e6488572d48c}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第7章 设计无锁的并发数据结构\7.2 无锁数据结构的例子">
      <UniqueIdentifier>{61a28d3d-3fd3-462b-b9e1-f0edd467b653}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第7章 设计无锁的并发数据结构\7.2 无锁数据结构的例子\7.2.1 编写不用锁的线程安全栈">
      <UniqueIdentifier>{00c7e02d-b7fa-4eea-8417-f2176057a355}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第7章 设计无锁的并发数据结构\7.2 无锁数据结构的例子\7.2.2 停止恼人的泄漏：在无锁数据结构中管理内存">
      <UniqueIdentifier>{64a72945-02ed-4341-8d45-4e42b37cd53f}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第7章 设计无锁的并发数据结构\7.2 无锁数据结构的例子\7.2.3 用风险指针检测不能被回收的结点">
      <UniqueIdentifier>{db1d055f-0d9d-4954-ae56-0c5f28af0311}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第7章 设计无锁的并发数据结构\7.2 无锁数据结构的例子\7.2.4 使用引用计数检测结点">
      <UniqueIdentifier>{97433d64-147b-4491-9fd6-b58caf375e6b}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第7章 设计无锁的并发数据结构\7.2 无锁数据结构的例子\7.2.5 将内存模型应用至无锁栈">
      <UniqueIdentifier>{8a487de3-9bcc-446a-ab03-33ba9d98563a}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第7章 设计无锁的并发数据结构\7.2 无锁数据结构的例子\7.2.6 编写不用锁的线程安全队列">
      <UniqueIdentifier>{28db6023-1c5f-4d31-9924-2b5add276b83}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第7章 设计无锁的并发数据结构\7.3 编写无锁数据结构的准则">
      <UniqueIdentifier>{d3c95af8-f3f6-4f47-b8d6-9787a41bfac4}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第7章 设计无锁的并发数据结构\7.3 编写无锁数据结构的准则\7.3.1 准则：使用std::memory_order_seq_cst作为原型">
      <UniqueIdentifier>{9d101ca4-3f85-430c-b1f1-ffa8a8060764}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第7章 设计无锁的并发数据结构\7.3 编写无锁数据结构的准则\7.3.2 准则：使用无锁内存回收模式">
      <UniqueIdentifier>{4841cb30-be02-4456-a61d-8e9decd85a80}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第7章 设计无锁的并发数据结构\7.3 编写无锁数据结构的准则\7.3.3 准则：当心ABA问题">
      <UniqueIdentifier>{b124e0f0-c241-41b7-8c87-8615c79c913d}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第7章 设计无锁的并发数据结构\7.3 编写无锁数据结构的准则\7.3.4 准则：识别忙于等待的循环以及辅助其他线程">
      <UniqueIdentifier>{5ec437b5-f22a-426c-8dce-bc8816b7ab81}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第7章 设计无锁的并发数据结构\7.4 小结">
      <UniqueIdentifier>{3b1463d2-4de9-45dd-a7dd-79460b15d053}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第8章 设计并发代码">
      <UniqueIdentifier>{2908d954-52f5-45ac-b8c5-027fe1e9744d}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第8章 设计并发代码\8.1 在线程间划分工作的技术">
      <UniqueIdentifier>{728f824c-9219-487a-9ecc-9647270f1438}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第8章 设计并发代码\8.1 在线程间划分工作的技术\8.1.1 处理开始前在线程间划分数据">
      <UniqueIdentifier>{2067eb32-a60d-4c5d-833b-67049cdfb076}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第8章 设计并发代码\8.1 在线程间划分工作的技术\8.1.2 递归地划分数据">
      <UniqueIdentifier>{d08c47b3-2205-48c7-9c0a-9ff9455d8b01}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第8章 设计并发代码\8.1 在线程间划分工作的技术\8.1.3 以任务类型划分工作">
      <UniqueIdentifier>{338df76f-30e9-4ad5-88c2-4bceb5309815}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第8章 设计并发代码\8.2 影响并发代码性能的因素">
      <UniqueIdentifier>{48671bde-2b78-4735-ae54-27e4d31e1278}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第8章 设计并发代码\8.2 影响并发代码性能的因素\8.2.1 有多少个处理器">
      <UniqueIdentifier>{254179c3-9f58-440e-a00f-4ac7a3b7509b}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第8章 设计并发代码\8.2 影响并发代码性能的因素\8.2.2 数据竞争和乒乓缓存">
      <UniqueIdentifier>{fa5ed904-0444-42c1-98bc-0e3614ac73ce}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第8章 设计并发代码\8.2 影响并发代码性能的因素\8.2.3 假共享">
      <UniqueIdentifier>{543934cb-119a-4d20-aa1c-85a8776a9a1e}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第8章 设计并发代码\8.2 影响并发代码性能的因素\8.2.4 数据应该多紧密">
      <UniqueIdentifier>{98fe1530-16cb-40a8-b0cf-09d4cbf67306}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第8章 设计并发代码\8.2 影响并发代码性能的因素\8.2.5 过度订阅和过多的任务切换">
      <UniqueIdentifier>{38ddf47e-357f-4866-b39c-36591156ef7f}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第8章 设计并发代码\8.3 为多线程性能设计数据结构">
      <UniqueIdentifier>{be94fa3c-930f-4418-9283-f3e33d20e56e}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第8章 设计并发代码\8.3 为多线程性能设计数据结构\8.3.1 为复杂操作划分数组元素">
      <UniqueIdentifier>{df646c7b-b299-49d2-9396-8001bc0e4c9e}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第8章 设计并发代码\8.3 为多线程性能设计数据结构\8.3.2 其他数据结构中的数据访问方式">
      <UniqueIdentifier>{972b4d6b-de31-496c-ae2e-fbb843b1c5b6}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第8章 设计并发代码\8.4 为并发设计时的额外考虑">
      <UniqueIdentifier>{0302aebe-fe64-49f0-8c78-fd12033a1b7b}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第8章 设计并发代码\8.4 为并发设计时的额外考虑\8.4.1 并行算法中的异常安全">
      <UniqueIdentifier>{39474364-7f95-4fcb-a448-8a6c3350eec1}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第8章 设计并发代码\8.4 为并发设计时的额外考虑\8.4.2 可扩展性和阿姆达尔定律">
      <UniqueIdentifier>{4fa7c8c7-be32-495a-8c37-d117637f0b7c}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第8章 设计并发代码\8.4 为并发设计时的额外考虑\8.4.3 用多线程隐藏延迟">
      <UniqueIdentifier>{41fc3514-cf35-4d48-b501-8486fdfd339d}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第8章 设计并发代码\8.4 为并发设计时的额外考虑\8.4.4 用并发提高响应性">
      <UniqueIdentifier>{a3d04ce8-fe9f-4836-9b22-669b6b6225e6}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第8章 设计并发代码\8.5 在实践中设计并发代码">
      <UniqueIdentifier>{21351254-dfdf-4e90-8b34-5a0e59c1e3cf}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第8章 设计并发代码\8.5 在实践中设计并发代码\8.5.1 std::for_each的并行实现">
      <UniqueIdentifier>{61032c23-171d-4fa8-a677-dc91b7f72674}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第8章 设计并发代码\8.5 在实践中设计并发代码\8.5.2 std::find的并行实现">
      <UniqueIdentifier>{843c4759-f983-423f-97bf-a6fd1c0193b4}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第8章 设计并发代码\8.5 在实践中设计并发代码\8.5.3 std::partial_sum的并行实现">
      <UniqueIdentifier>{224b2df3-e203-421c-8ea3-c7117f3f1211}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第8章 设计并发代码\8.6 总结">
      <UniqueIdentifier>{9acdfed1-9a81-4f28-bedf-8b5b5bc96592}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第9章 高级线程管理">
      <UniqueIdentifier>{83fa260f-bf9f-4c01-8311-7c942a5d3c1a}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第9章 高级线程管理\9.1 线程池">
      <UniqueIdentifier>{32a33e8f-3548-4611-bfba-08a461b84597}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第9章 高级线程管理\9.1 线程池\9.1.1 最简单的线程池">
      <UniqueIdentifier>{26fa2ddf-48ba-4555-b320-2d497a08841e}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第9章 高级线程管理\9.1 线程池\9.1.2 等待提交给线程池的任务">
      <UniqueIdentifier>{1d1336f0-193a-4b35-92df-9c126597bd1a}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第9章 高级线程管理\9.1 线程池\9.1.3 等待其他任务的任务">
      <UniqueIdentifier>{f58a3069-6de6-4843-a8fd-7dbd663f45b6}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第9章 高级线程管理\9.1 线程池\9.1.4 避免工作队列上的竞争">
      <UniqueIdentifier>{0d65c53d-b852-4f84-9f30-b55edf0b3b77}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第9章 高级线程管理\9.1 线程池\9.1.5 工作窃取">
      <UniqueIdentifier>{8663be6e-3371-4873-95d2-e8cd554d9560}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第9章 高级线程管理\9.2 中断线程">
      <UniqueIdentifier>{e2b8ec54-3f5b-4289-aed7-88096cb300a9}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第9章 高级线程管理\9.2 中断线程\9.2.1 启动和中断另一个线程">
      <UniqueIdentifier>{a905bd55-1497-4384-b1a8-b0d835626cf1}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第9章 高级线程管理\9.2 中断线程\9.2.2 检测一个线程是否被中断">
      <UniqueIdentifier>{bb259286-e369-41e8-bc89-197db58e042c}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第9章 高级线程管理\9.2 中断线程\9.2.3 中断等待条件变量">
      <UniqueIdentifier>{af29b882-fd71-4744-9e39-0e62af956cbf}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第9章 高级线程管理\9.2 中断线程\9.2.4 中断在std::condition_variable_any上的等待">
      <UniqueIdentifier>{d22889e1-0b5f-4ff3-ba99-20a3bbbcd443}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第9章 高级线程管理\9.2 中断线程\9.2.5 中断其他阻塞调用">
      <UniqueIdentifier>{1352b710-4105-4e60-ae2d-34a166ae14c1}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第9章 高级线程管理\9.2 中断线程\9.2.6 处理中断">
      <UniqueIdentifier>{d024e1d8-c0e1-4fa3-ae07-a761c53ce277}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第9章 高级线程管理\9.2 中断线程\9.2.7 在应用退出时中断后台任务">
      <UniqueIdentifier>{1bdaf109-2e2b-44cb-93d3-80ea7e6e3be1}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第9章 高级线程管理\9.3 总结">
      <UniqueIdentifier>{e699461c-2e3e-4a3a-8a2c-64416755c085}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第10章 多线程应用的测试与调试">
      <UniqueIdentifier>{9fca4b5d-50d8-49a4-b966-4f8fb987b771}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第10章 多线程应用的测试与调试\10.1 并发相关错误的类型">
      <UniqueIdentifier>{01a21908-00c0-45aa-8317-6ad0b06aec2d}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第10章 多线程应用的测试与调试\10.1 并发相关错误的类型\10.1.1 不必要的阻塞">
      <UniqueIdentifier>{a912c724-0d21-4a98-8e9b-f02a4fced3c3}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第10章 多线程应用的测试与调试\10.1 并发相关错误的类型\10.1.2 竞争条件">
      <UniqueIdentifier>{9f1a086a-eec6-4779-bd0f-2015425813ab}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第10章 多线程应用的测试与调试\10.2 定位并发相关的错误的技巧">
      <UniqueIdentifier>{5c2d0928-3b2e-40d6-b63f-ae445a270a0e}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第10章 多线程应用的测试与调试\10.2 定位并发相关的错误的技巧\10.2.1 审阅代码以定位潜在的错误">
      <UniqueIdentifier>{62153ed0-4195-4805-aae4-6f5db0cb6e5a}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第10章 多线程应用的测试与调试\10.2 定位并发相关的错误的技巧\10.2.2 通过测试定位并发相关的错误">
      <UniqueIdentifier>{531f496e-10ef-4c2d-9a8c-c0c99284bac3}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第10章 多线程应用的测试与调试\10.2 定位并发相关的错误的技巧\10.2.3 可测试性设计">
      <UniqueIdentifier>{f53f97ec-a618-4505-8f58-b6181292337d}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第10章 多线程应用的测试与调试\10.2 定位并发相关的错误的技巧\10.2.4 多线程测试技术">
      <UniqueIdentifier>{10ca69a3-0fc3-48fd-b616-3f2eca7499d9}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第10章 多线程应用的测试与调试\10.2 定位并发相关的错误的技巧\10.2.5 构建多线程的测试代码">
      <UniqueIdentifier>{c2fe5a6b-9995-4a6b-88a8-562a435059c1}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第10章 多线程应用的测试与调试\10.2 定位并发相关的错误的技巧\10.2.6 测试多线程代码的性能">
      <UniqueIdentifier>{6ea4007c-6257-4af7-88f0-11b05369cc1d}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\第10章 多线程应用的测试与调试\10.3 总结">
      <UniqueIdentifier>{5c1568b1-82ef-47e5-bd79-6e7d2f50e6eb}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\附录A 附录A C++11部分语言特性简明参考">
      <UniqueIdentifier>{96021a28-3b64-4551-9e73-9195b4bd456b}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\附录B 并发类库简要对比">
      <UniqueIdentifier>{57de0dcf-0d61-4c24-8649-d2785e0286ef}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\附录C 消息传递框架与完事的ATM示例">
      <UniqueIdentifier>{4dcdcfbc-3f1f-4bb4-8e59-d7fe87b9417c}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Concurrency In Action（C++ 并发编程实战）\附录D C++线程类库参考">
      <UniqueIdentifier>{d774b7bf-63d5-4293-8566-90ef306bc325}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Multithreading Cookbook（C++ 多线程编程实战）">
      <UniqueIdentifier>{657549ee-f6ab-4c44-8756-72cee9fabb44}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Multithreading Cookbook（C++ 多线程编程实战）\0.">
      <UniqueIdentifier>{5b17e620-c271-427b-a294-583847193556}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Multithreading Cookbook（C++ 多线程编程实战）\0.\0.1 作者简介">
      <UniqueIdentifier>{c1083738-02e2-4188-832c-fd22d3c3f004}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Multithreading Cookbook（C++ 多线程编程实战）\0.\0.2 致谢">
      <UniqueIdentifier>{ff717d57-f075-4896-8f8b-66d84fcb4126}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Multithreading Cookbook（C++ 多线程编程实战）\0.\0.3 审稿人简介">
      <UniqueIdentifier>{c8dc5842-3db4-4df3-bce4-312700fc1edb}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Multithreading Cookbook（C++ 多线程编程实战）\0.\0.4 前言">
      <UniqueIdentifier>{fd513bc6-f7cb-4db2-96fa-328619ab2f4b}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Multithreading Cookbook（C++ 多线程编程实战）\0.\0.4 前言\0.4.1 本书涵盖的内容">
      <UniqueIdentifier>{1ba0ae22-fba7-4c05-a10e-88c589769d5a}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Multithreading Cookbook（C++ 多线程编程实战）\0.\0.4 前言\0.4.2 本书必备软件">
      <UniqueIdentifier>{d364a6d5-977c-41fa-835a-50dd19a4ccc1}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Multithreading Cookbook（C++ 多线程编程实战）\0.\0.4 前言\0.4.3 本书的读者对象">
      <UniqueIdentifier>{c17850c2-9ec9-423f-9683-fef5ad21e08b}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Multithreading Cookbook（C++ 多线程编程实战）\0.\0.4 前言\0.4.4 本书的体例">
      <UniqueIdentifier>{be84a613-9996-467f-be40-833cd1c402dd}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Multithreading Cookbook（C++ 多线程编程实战）\第1章　C++概念和特性简介">
      <UniqueIdentifier>{169a88cc-b026-402b-957d-86aa06891c4c}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Multithreading Cookbook（C++ 多线程编程实战）\第1章　C++概念和特性简介\1.1　介绍">
      <UniqueIdentifier>{9266d1a0-1476-4afd-864f-cf24e37df408}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Multithreading Cookbook（C++ 多线程编程实战）\第1章　C++概念和特性简介\1.2　创建C++项目">
      <UniqueIdentifier>{4bfb82fd-54b8-421b-88d4-0408e9e8ceb9}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Multithreading Cookbook（C++ 多线程编程实战）\第1章　C++概念和特性简介\1.3　程序结构、执行流和运行时对象">
      <UniqueIdentifier>{1f352072-4924-478f-9442-036147cfbbb3}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Multithreading Cookbook（C++ 多线程编程实战）\第1章　C++概念和特性简介\1.4　结构化编程方法">
      <UniqueIdentifier>{56981515-3bb4-49fa-9b51-736750f21836}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Multithreading Cookbook（C++ 多线程编程实战）\第1章　C++概念和特性简介\1.5　理解面向对象编程方法">
      <UniqueIdentifier>{11e345c4-5dbe-4bb2-92c1-83d60b22c5f8}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Multithreading Cookbook（C++ 多线程编程实战）\第1章　C++概念和特性简介\1.6　解释继承、重载和覆盖">
      <UniqueIdentifier>{e5a526f5-89e7-4875-b81b-b78e3c9e0b4e}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Multithreading Cookbook（C++ 多线程编程实战）\第1章　C++概念和特性简介\1.7　理解多态">
      <UniqueIdentifier>{50d4c24e-a94f-42bd-b11c-8bc39a720ac7}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Multithreading Cookbook（C++ 多线程编程实战）\第1章　C++概念和特性简介\1.8　事件处理器和消息传递接口">
      <UniqueIdentifier>{6ad18d57-589c-4888-8c13-c0805c5dc307}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Multithreading Cookbook（C++ 多线程编程实战）\第1章　C++概念和特性简介\1.9　链表、队列和栈示例">
      <UniqueIdentifier>{bec48a18-705d-4fbd-9a38-f989040bf243}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Multithreading Cookbook（C++ 多线程编程实战）\第2章　进程和线程的概念">
      <UniqueIdentifier>{985ea629-6e8d-40cb-bd09-451598782aa7}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Multithreading Cookbook（C++ 多线程编程实战）\第2章　进程和线程的概念\2.1　简介">
      <UniqueIdentifier>{37e44000-cf12-4af1-80e8-a8ee6714d8b9}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Multithreading Cookbook（C++ 多线程编程实战）\第2章　进程和线程的概念\2.2　进程和线程">
      <UniqueIdentifier>{e255ae76-9e6a-4f08-bbcc-f24483736540}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Multithreading Cookbook（C++ 多线程编程实战）\第2章　进程和线程的概念\2.3　解释进程模型">
      <UniqueIdentifier>{f942d7a3-40cf-4711-af4b-f0afb1c249be}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Multithreading Cookbook（C++ 多线程编程实战）\第2章　进程和线程的概念\2.4　进程的实现">
      <UniqueIdentifier>{577e1ad8-23e9-4fde-82d2-e1fbb149f7be}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Multithreading Cookbook（C++ 多线程编程实战）\第2章　进程和线程的概念\2.5　进程间通信（IPC）">
      <UniqueIdentifier>{c6732dbe-e30e-4124-98ba-7d21edbbfb35}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Multithreading Cookbook（C++ 多线程编程实战）\第2章　进程和线程的概念\2.6　解决典型的IPC问题">
      <UniqueIdentifier>{53a62e5a-4ac1-4a91-b3ff-095067252275}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Multithreading Cookbook（C++ 多线程编程实战）\第2章　进程和线程的概念\2.7　线程模型的实现">
      <UniqueIdentifier>{0786706a-752f-4ca9-8731-4ef5a6df24fc}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Multithreading Cookbook（C++ 多线程编程实战）\第2章　进程和线程的概念\2.8　线程的用法">
      <UniqueIdentifier>{00917072-17b4-4465-8a24-406176d59f0f}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Multithreading Cookbook（C++ 多线程编程实战）\第2章　进程和线程的概念\2.9　在用户空间实现线程">
      <UniqueIdentifier>{a7b2406b-2380-4976-953e-26065b655432}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Multithreading Cookbook（C++ 多线程编程实战）\第2章　进程和线程的概念\2.10　在内核实现线程">
      <UniqueIdentifier>{81b8ac37-fd68-461b-b995-883919dcb607}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Multithreading Cookbook（C++ 多线程编程实战）\第3章　管理进程">
      <UniqueIdentifier>{a2c8d7e5-979b-4367-be71-781f9880e004}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Multithreading Cookbook（C++ 多线程编程实战）\第3章　管理进程\3.1　介绍">
      <UniqueIdentifier>{ef22b1f3-eaf9-4180-a428-b2e93e523f38}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Multithreading Cookbook（C++ 多线程编程实战）\第3章　管理进程\3.2　进程和线程">
      <UniqueIdentifier>{673bcbaf-9a33-4574-bf04-7b74e5b51ecc}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Multithreading Cookbook（C++ 多线程编程实战）\第3章　管理进程\3.3　协作式和抢占式多任务处理">
      <UniqueIdentifier>{099bc193-13bb-4ce1-90e0-05faa5935252}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Multithreading Cookbook（C++ 多线程编程实战）\第3章　管理进程\3.4　解释Windows线程对象">
      <UniqueIdentifier>{0bb5dcb0-3242-4f5a-96c1-5d3ac3f6e318}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Multithreading Cookbook（C++ 多线程编程实战）\第3章　管理进程\3.5　基本线程管理">
      <UniqueIdentifier>{dbfc2a54-f546-4492-ae28-27a1dc7eabf6}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Multithreading Cookbook（C++ 多线程编程实战）\第3章　管理进程\3.6　实现异步的线程">
      <UniqueIdentifier>{97e61795-e28a-49c8-b580-886a8d1c86ce}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Multithreading Cookbook（C++ 多线程编程实战）\第3章　管理进程\3.7　实现同步的线程">
      <UniqueIdentifier>{6b307ff9-cfb2-4961-a162-2d61387216fc}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Multithreading Cookbook（C++ 多线程编程实战）\第3章　管理进程\3.8　Win32同步对象和技术">
      <UniqueIdentifier>{726e5501-a3ca-42da-b376-ef0d53269246}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Multithreading Cookbook（C++ 多线程编程实战）\第3章　管理进程\3.8　Win32同步对象和技术\3.8.1　同步对象：互斥量">
      <UniqueIdentifier>{6d6fd9e7-0cf4-428f-82c8-6b46e1e93ae8}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Multithreading Cookbook（C++ 多线程编程实战）\第3章　管理进程\3.8　Win32同步对象和技术\3.8.2　同步对象：信号量">
      <UniqueIdentifier>{2ed89e3e-bb0a-4425-9647-d1f1c297f62a}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Multithreading Cookbook（C++ 多线程编程实战）\第3章　管理进程\3.8　Win32同步对象和技术\3.8.3　同步对象：事件">
      <UniqueIdentifier>{026b7ad2-8f88-4bb7-ae7c-0eed1889b506}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Multithreading Cookbook（C++ 多线程编程实战）\第3章　管理进程\3.8　Win32同步对象和技术\3.8.4　同步对象：临界区">
      <UniqueIdentifier>{4a035af4-32d4-4978-a7a7-8d8ef523f741}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Multithreading Cookbook（C++ 多线程编程实战）\第4章　消息传递">
      <UniqueIdentifier>{6bf56aab-8f88-46ca-a125-d83a83c3de23}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Multithreading Cookbook（C++ 多线程编程实战）\第4章　消息传递\4.1　介绍">
      <UniqueIdentifier>{39bcc35f-8910-4b43-8030-8ddbd9d5a9f3}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Multithreading Cookbook（C++ 多线程编程实战）\第4章　消息传递\4.2　解释消息传递接口">
      <UniqueIdentifier>{5cf05e12-61d5-4dcc-b7f1-d9d3c1896940}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Multithreading Cookbook（C++ 多线程编程实战）\第4章　消息传递\4.3　理解消息队列">
      <UniqueIdentifier>{66f74d21-191a-48b9-b110-9d7d2c733fb1}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Multithreading Cookbook（C++ 多线程编程实战）\第4章　消息传递\4.4　使用线程消息队列">
      <UniqueIdentifier>{ca8e9eb1-cad6-4752-9217-f7a624b44d65}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Multithreading Cookbook（C++ 多线程编程实战）\第4章　消息传递\4.5　通过管道对象通信">
      <UniqueIdentifier>{03da94ca-b4b4-4516-909f-31ef8e903af0}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Multithreading Cookbook（C++ 多线程编程实战）\第5章　线程同步和并发操作">
      <UniqueIdentifier>{6c0108e5-f5ca-44b8-b751-8fd8e495962d}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Multithreading Cookbook（C++ 多线程编程实战）\第5章　线程同步和并发操作\5.1　介绍">
      <UniqueIdentifier>{4d0ad270-11b7-4120-9922-99335d187699}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Multithreading Cookbook（C++ 多线程编程实战）\第5章　线程同步和并发操作\5.2　伪并行">
      <UniqueIdentifier>{6f826bc4-5d37-4a1b-a906-89cf0c2b046c}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Multithreading Cookbook（C++ 多线程编程实战）\第5章　线程同步和并发操作\5.3　理解进程和线程优先级">
      <UniqueIdentifier>{cc867bf2-71c5-4023-be42-9c276cdf43db}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Multithreading Cookbook（C++ 多线程编程实战）\第5章　线程同步和并发操作\5.4　Windows分发器对象和调度">
      <UniqueIdentifier>{71481c6a-11d8-4b47-bd9c-87400385d606}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Multithreading Cookbook（C++ 多线程编程实战）\第5章　线程同步和并发操作\5.5　使用互斥量">
      <UniqueIdentifier>{e40ea066-67dd-4726-9628-a584df7894b4}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Multithreading Cookbook（C++ 多线程编程实战）\第5章　线程同步和并发操作\5.6　使用信号量">
      <UniqueIdentifier>{f8709de1-d064-4565-ace7-c7d3d6d95d6b}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Multithreading Cookbook（C++ 多线程编程实战）\第5章　线程同步和并发操作\5.7　使用事件">
      <UniqueIdentifier>{954d022a-b72d-402a-b2b6-35adb4423c63}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Multithreading Cookbook（C++ 多线程编程实战）\第5章　线程同步和并发操作\5.8　使用临界区">
      <UniqueIdentifier>{946b1d52-344d-40e6-892d-bced20f33e7c}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Multithreading Cookbook（C++ 多线程编程实战）\第5章　线程同步和并发操作\5.9　使用管道">
      <UniqueIdentifier>{d374f57c-e266-432d-9769-d8f87c31bfad}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Multithreading Cookbook（C++ 多线程编程实战）\第6章　.NET框架中的线程">
      <UniqueIdentifier>{d06a15dd-81db-4e48-9510-396315366e82}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Multithreading Cookbook（C++ 多线程编程实战）\第6章　.NET框架中的线程\6.1　介绍">
      <UniqueIdentifier>{6b3bdb27-b135-48ab-9a47-172fed924235}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Multithreading Cookbook（C++ 多线程编程实战）\第6章　.NET框架中的线程\6.2　托管代码和非托管代码">
      <UniqueIdentifier>{9959051d-07e1-408f-a2f4-4e29996f8af1}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Multithreading Cookbook（C++ 多线程编程实战）\第6章　.NET框架中的线程\6.3　如何在.NET中运行线程">
      <UniqueIdentifier>{93912dd0-0960-41d7-9614-4080cf2d2c32}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Multithreading Cookbook（C++ 多线程编程实战）\第6章　.NET框架中的线程\6.4　前台线程和后台线程的区别">
      <UniqueIdentifier>{6478f9c7-d963-4a4e-be9a-4fa05c66aee1}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Multithreading Cookbook（C++ 多线程编程实战）\第6章　.NET框架中的线程\6.5　理解.NET同步要素">
      <UniqueIdentifier>{09b0f296-3841-4ab0-ab3a-810140a1dbb6}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Multithreading Cookbook（C++ 多线程编程实战）\第6章　.NET框架中的线程\6.6　锁和避免死锁">
      <UniqueIdentifier>{724aa462-a021-41e3-a1da-2ad7be65417e}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Multithreading Cookbook（C++ 多线程编程实战）\第6章　.NET框架中的线程\6.7　线程安全和.NET框架的类型">
      <UniqueIdentifier>{a28cf79e-6b5f-4652-937a-f0c1ac298c77}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Multithreading Cookbook（C++ 多线程编程实战）\第6章　.NET框架中的线程\6.8　事件等待">
      <UniqueIdentifier>{2f1d0931-8449-4156-a726-2c12a443ba03}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Multithreading Cookbook（C++ 多线程编程实战）\第6章　.NET框架中的线程\6.9  基于事件的异步模式">
      <UniqueIdentifier>{63b42b39-4c41-4b19-8c27-1b9fe9bd4e82}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Multithreading Cookbook（C++ 多线程编程实战）\第6章　.NET框架中的线程\6.10 BackgoundWorker类">
      <UniqueIdentifier>{cc2dc6fd-6c3c-4674-9dc0-10661a3c7cd8}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Multithreading Cookbook（C++ 多线程编程实战）\第6章　.NET框架中的线程\6.11 中断、中止和安全取消线程执行">
      <UniqueIdentifier>{cb2e357c-86f9-4874-8f1b-b46f16c773f5}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Multithreading Cookbook（C++ 多线程编程实战）\第6章　.NET框架中的线程\6.12 非阻塞同步">
      <UniqueIdentifier>{a3d7fdf4-35c8-48bb-abbb-0ed1868566a7}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Multithreading Cookbook（C++ 多线程编程实战）\第6章　.NET框架中的线程\6.13 Wait和Pulse触发">
      <UniqueIdentifier>{85026236-f49e-44d3-86ff-1a1fcf835ce1}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Multithreading Cookbook（C++ 多线程编程实战）\第6章　.NET框架中的线程\6.14 Barrier类">
      <UniqueIdentifier>{e3638541-0230-4921-abb7-c787d6573e99}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Multithreading Cookbook（C++ 多线程编程实战）\第7章 理解并发代码设计">
      <UniqueIdentifier>{950b3d5d-06f0-44e2-8100-6a2129c1bb55}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Multithreading Cookbook（C++ 多线程编程实战）\第7章 理解并发代码设计\7.1 介绍">
      <UniqueIdentifier>{e46ee2a3-2adb-4acb-85c2-b1320595a68b}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Multithreading Cookbook（C++ 多线程编程实战）\第7章 理解并发代码设计\7.2 如何设计并行应用程序">
      <UniqueIdentifier>{10a2abcd-dda9-4fb7-94dc-bce526a1a643}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Multithreading Cookbook（C++ 多线程编程实战）\第7章 理解并发代码设计\7.3 理解代码设计中的并行">
      <UniqueIdentifier>{bc11c89b-a704-421f-bbf2-c8819a49351a}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Multithreading Cookbook（C++ 多线程编程实战）\第7章 理解并发代码设计\7.4 转向并行">
      <UniqueIdentifier>{a9097dff-b002-4514-88b5-5b5c9f3c354a}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Multithreading Cookbook（C++ 多线程编程实战）\第7章 理解并发代码设计\7.5 改进性能因素">
      <UniqueIdentifier>{83e5fb61-505b-4f76-812b-d8e060626537}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Multithreading Cookbook（C++ 多线程编程实战）\第8章 高级线程管理">
      <UniqueIdentifier>{a4187a5e-62c7-445b-be07-5f400d6cd9c3}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Multithreading Cookbook（C++ 多线程编程实战）\第8章 高级线程管理\8.1 介绍">
      <UniqueIdentifier>{321aa9cb-884d-4dac-aaed-70f1d2bfe6b8}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Multithreading Cookbook（C++ 多线程编程实战）\第8章 高级线程管理\8.2 使用线程池">
      <UniqueIdentifier>{5225ebc1-9c37-40a4-9244-b80863fc8c94}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Multithreading Cookbook（C++ 多线程编程实战）\第8章 高级线程管理\8.3 定制线程池分发器">
      <UniqueIdentifier>{c33f54ee-0b13-46c2-804f-2c13d718d1bf}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Multithreading Cookbook（C++ 多线程编程实战）\第8章 高级线程管理\8.4 使用远程线程">
      <UniqueIdentifier>{2f125ff9-98b8-47b5-ae13-fe14e20b6657}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Multithreading Cookbook（C++ 多线程编程实战）\附录A">
      <UniqueIdentifier>{66d09b97-24f4-4f44-8e74-8beebe19eaf8}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Multithreading Cookbook（C++ 多线程编程实战）\附录A\A.1 安装MySQL Connector/C">
      <UniqueIdentifier>{9d7c19ee-7a2b-45f9-b46c-62d82d0b92d2}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Multithreading Cookbook（C++ 多线程编程实战）\附录A\A.2 安装WinDDK-Driver开发套件">
      <UniqueIdentifier>{0216ecb6-e8e5-4da0-87c5-f2e300fe5222}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Multithreading Cookbook（C++ 多线程编程实战）\附录A\A.3 设置驱动器编译的Visual Studio项目">
      <UniqueIdentifier>{d0529ae7-06f3-4eea-8ac5-85077ba123bf}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Multithreading Cookbook（C++ 多线程编程实战）\附录A\A.4 使用DebugView应用程序">
      <UniqueIdentifier>{884fb953-d5ca-48a1-8d58-4e183cb9967a}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\C++ Multithreading Cookbook（C++ 多线程编程实战）\附录A\A.5 设置OpenMP编译的Visual Studio项目">
      <UniqueIdentifier>{a0ab3660-e61a-402f-9cce-8f6d70c95d81}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\0. 作者序">
      <UniqueIdentifier>{bfc36620-2c82-40f3-81c8-6c76c37147f3}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\0. 作者序\0.1 谁应该读这本书">
      <UniqueIdentifier>{6f5ada7a-de48-464b-b017-ccb2f22498e6}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\0. 作者序\0.2 本书架构">
      <UniqueIdentifier>{dcc83e4d-d616-4d6f-8206-68c358fe6f64}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\0. 作者序\0.3 关于范例程序">
      <UniqueIdentifier>{f558e228-2210-48a3-ab45-605a74633cec}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\0. 作者序\0.4 相关阅读">
      <UniqueIdentifier>{155738b2-4db0-4f39-977d-38dc81ce61f5}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\第1篇 上路吧，线程">
      <UniqueIdentifier>{a36a8d91-d3c8-4c9c-9c1e-42513adbfc80}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\第1篇 上路吧，线程\第1章 为什么要“千头万绪”">
      <UniqueIdentifier>{3010f074-f581-4ef3-b081-2171671e939d}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\第1篇 上路吧，线程\第1章 为什么要“千头万绪”\1.1 一条曲折的路">
      <UniqueIdentifier>{ea857e25-42e1-4498-8088-51172ce14dd6}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\第1篇 上路吧，线程\第1章 为什么要“千头万绪”\1.2 与线程茶枕">
      <UniqueIdentifier>{f7712cdb-43e9-45f8-add5-97e785b2645c}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\第1篇 上路吧，线程\第1章 为什么要“千头万绪”\1.3 为什么最终用户也需要多线程多任务">
      <UniqueIdentifier>{85a7a15a-b393-4a06-9f5b-54dda7da37e6}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\第1篇 上路吧，线程\第1章 为什么要“千头万绪”\1.4 Win32基础">
      <UniqueIdentifier>{e7feb2c1-e130-461b-885d-6fc137e23e5d}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\第1篇 上路吧，线程\第1章 为什么要“千头万绪”\1.5 Context Switching">
      <UniqueIdentifier>{f10d2365-c205-4de3-acdf-2018e6b6fe1e}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\第1篇 上路吧，线程\第1章 为什么要“千头万绪”\1.6 Race Conditions（竞争条件）">
      <UniqueIdentifier>{1e0c8c7e-4c7d-45f0-9b19-547f69a8ffce}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\第1篇 上路吧，线程\第1章 为什么要“千头万绪”\1.7 Atomic Operations（原子操作）">
      <UniqueIdentifier>{b8d28eae-63df-4489-a06f-7292ff745665}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\第1篇 上路吧，线程\第1章 为什么要“千头万绪”\1.8 线程之间如何通讯">
      <UniqueIdentifier>{9430427e-e9d0-4441-b807-edc8421f8ebf}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\第1篇 上路吧，线程\第1章 为什么要“千头万绪”\1.9 好消息与坏消息">
      <UniqueIdentifier>{06905ae7-ebfe-4531-9b72-4e8e20754275}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\第1篇 上路吧，线程\第2章 线程的第一次接触">
      <UniqueIdentifier>{a987ef3c-e3a9-4f48-bf9a-b02818b621ca}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\第1篇 上路吧，线程\第2章 线程的第一次接触\2.1 产生一个线程">
      <UniqueIdentifier>{0b37c087-3550-42ce-a330-ad256d808c96}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\第1篇 上路吧，线程\第2章 线程的第一次接触\2.2 使用多个线程的结果">
      <UniqueIdentifier>{5f875373-6711-43a6-a02d-f343feb09079}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\第1篇 上路吧，线程\第2章 线程的第一次接触\2.3 核心对象（Kernel Objects）">
      <UniqueIdentifier>{62a2eee9-a91b-479f-9ed5-039d285fa381}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\第1篇 上路吧，线程\第2章 线程的第一次接触\2.4 线程结束代码（Exit Code）">
      <UniqueIdentifier>{a315916c-99b4-4c30-aa83-ca735907dfde}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\第1篇 上路吧，线程\第2章 线程的第一次接触\2.5 结束一个线程">
      <UniqueIdentifier>{709a7267-9d56-4f7a-a60f-62df3d51aa3f}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\第1篇 上路吧，线程\第2章 线程的第一次接触\2.6 错误处理">
      <UniqueIdentifier>{2391265a-58c0-42da-bbd2-73e5548883d3}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\第1篇 上路吧，线程\第2章 线程的第一次接触\2.7 后台打印（Background Printing）">
      <UniqueIdentifier>{ab73fec4-be09-42c8-ab79-b5c8c2bf05a6}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\第1篇 上路吧，线程\第2章 线程的第一次接触\2.8 成功的秘诀">
      <UniqueIdentifier>{abbe382d-8ffb-4fac-80f2-d614a9028968}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\第1篇 上路吧，线程\第3章 快跑与等待">
      <UniqueIdentifier>{d0fc96da-0b2b-4cbc-aef3-36a788a528b0}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\第1篇 上路吧，线程\第3章 快跑与等待\3.1 看似闲暇却忙碌（Busy Waiting）">
      <UniqueIdentifier>{ac94c680-f975-42fb-b6ef-1681b5d46fed}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\第1篇 上路吧，线程\第3章 快跑与等待\3.2 性能监视器（Performance Monitor）">
      <UniqueIdentifier>{bc5bc6d2-c7c0-465d-a350-b2844dbd8bc3}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\第1篇 上路吧，线程\第3章 快跑与等待\3.3 等待一个线程的结束">
      <UniqueIdentifier>{8705d018-1a96-4fda-b87b-df5d542f898e}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\第1篇 上路吧，线程\第3章 快跑与等待\3.4 在一个GUI程序中等待">
      <UniqueIdentifier>{02250f1a-b1c7-46e9-8909-f870b01197b6}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\第1篇 上路吧，线程\第3章 快跑与等待\3.5 提要">
      <UniqueIdentifier>{04cbd055-bc41-4c3a-896f-501486ea4300}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\第1篇 上路吧，线程\第4章 同步控制">
      <UniqueIdentifier>{f6181e5f-988b-405f-86ee-11ff68a4693c}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\第1篇 上路吧，线程\第4章 同步控制\4.1 Critical Sections（关键区域、临界区域）">
      <UniqueIdentifier>{10b13e60-3cb3-4a24-84bf-d615752da0bf}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\第1篇 上路吧，线程\第4章 同步控制\4.2 死锁（Deadlock）">
      <UniqueIdentifier>{cf8dc0ac-b1fd-4536-8c9f-1b078c08d91f}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\第1篇 上路吧，线程\第4章 同步控制\4.3 哲学家进餐问题（The Dining Philosophers）">
      <UniqueIdentifier>{f80a5564-cf81-4abd-821b-77f85a0f91d2}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\第1篇 上路吧，线程\第4章 同步控制\4.4 互斥器（Mutexes）">
      <UniqueIdentifier>{7eed0991-aaf6-4edd-bf3f-d9e44348f197}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\第1篇 上路吧，线程\第4章 同步控制\4.5 信号量（Semaphores）">
      <UniqueIdentifier>{bc677144-7b54-4794-bed0-be21f5e1fc51}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\第1篇 上路吧，线程\第4章 同步控制\4.6 事件（Event Objects）">
      <UniqueIdentifier>{be676416-db96-4fb3-a423-40141ae8e798}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\第1篇 上路吧，线程\第4章 同步控制\4.7 从Worker线程中显示输出">
      <UniqueIdentifier>{f8151a71-ae34-4756-b89b-ab05bd30c7fd}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\第1篇 上路吧，线程\第4章 同步控制\4.8 Interlocked Variables">
      <UniqueIdentifier>{56c49e42-58eb-4d65-8453-8c277ed22af8}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\第1篇 上路吧，线程\第4章 同步控制\4.9 同步机制摘要">
      <UniqueIdentifier>{b50635f7-1096-4ec2-b985-650995ab4e74}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\第1篇 上路吧，线程\第5章 不要让线程成为脱缰野马">
      <UniqueIdentifier>{a4deef2e-0957-45f2-96c0-f36631ffb86b}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\第1篇 上路吧，线程\第5章 不要让线程成为脱缰野马\5.1 干净地终止一个线程">
      <UniqueIdentifier>{0c238456-38ce-435c-8ca1-611e795f6781}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\第1篇 上路吧，线程\第5章 不要让线程成为脱缰野马\5.2 线程优先权（Thread Priority）">
      <UniqueIdentifier>{75dab089-4b8a-439d-ac97-abbd381c25b7}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\第1篇 上路吧，线程\第5章 不要让线程成为脱缰野马\5.3 初始化一个线程">
      <UniqueIdentifier>{399dc7ff-5a42-48d1-ae46-eeaae3254255}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\第1篇 上路吧，线程\第5章 不要让线程成为脱缰野马\5.4 提要">
      <UniqueIdentifier>{5ed005fe-e801-4758-9ae1-45fc9813124c}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\第1篇 上路吧，线程\第6章 Overlapped IO,在你身后变戏法">
      <UniqueIdentifier>{f2001ad6-1857-40c4-a963-f2955b4f54a9}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\第1篇 上路吧，线程\第6章 Overlapped IO,在你身后变戏法\6.1 Win32文件操作函数">
      <UniqueIdentifier>{d262a3b6-95c5-4c4b-a4d7-9de6d9835d50}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\第1篇 上路吧，线程\第6章 Overlapped IO,在你身后变戏法\6.2 被激发的File Handles">
      <UniqueIdentifier>{ab355b23-2a2b-4b1d-8a0f-d4cc614257e3}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\第1篇 上路吧，线程\第6章 Overlapped IO,在你身后变戏法\6.3 被激发的Event对象">
      <UniqueIdentifier>{3af8e363-8d25-4a22-aacc-bd3829b039d2}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\第1篇 上路吧，线程\第6章 Overlapped IO,在你身后变戏法\6.4 异步过程调用（Asynchronous Procedure Calls,APCs）">
      <UniqueIdentifier>{0c87e45e-1543-446b-9458-61e45f1a011f}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\第1篇 上路吧，线程\第6章 Overlapped IO,在你身后变戏法\6.5 对文件进行Overlapped I/O的缺点">
      <UniqueIdentifier>{58a01ee0-72dc-400d-9cfa-d8f07fe9cf8a}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\第1篇 上路吧，线程\第6章 Overlapped IO,在你身后变戏法\6.6 I/O Completion Ports">
      <UniqueIdentifier>{1ba21aca-842a-44dc-9c28-0bb47a32c666}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\第1篇 上路吧，线程\第6章 Overlapped IO,在你身后变戏法\6.7 对Sockets使用">
      <UniqueIdentifier>{b3f1ef7f-43b4-4bef-b1b9-f174e6fc722f}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\第1篇 上路吧，线程\第6章 Overlapped IO,在你身后变戏法\6.8 Overlapped I/O">
      <UniqueIdentifier>{3558653b-fb1f-48f3-9592-cd198586337d}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\第1篇 上路吧，线程\第6章 Overlapped IO,在你身后变戏法\6.9 提要">
      <UniqueIdentifier>{ddbefb71-3249-4665-8286-d856c1ce60ae}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\第2篇 多线程程序设计的工具与手法">
      <UniqueIdentifier>{836b48f9-e23e-4a00-9fa9-d95242c8ad49}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\第2篇 多线程程序设计的工具与手法\第7章 数据一致性">
      <UniqueIdentifier>{b92e7932-a7ec-4b65-9bf0-7732b1ac3729}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\第2篇 多线程程序设计的工具与手法\第7章 数据一致性\7.1 认识volatile关键字">
      <UniqueIdentifier>{8aaa2c9f-8c87-4e8c-9e12-7d2ef0c2689d}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\第2篇 多线程程序设计的工具与手法\第7章 数据一致性\7.2 Referential Integrity">
      <UniqueIdentifier>{43075330-18f1-4142-b595-b7582db21601}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\第2篇 多线程程序设计的工具与手法\第7章 数据一致性\7.3 The Readers/Writers Lock">
      <UniqueIdentifier>{2eff540f-adfc-43fb-a99b-4a0c659fb9f3}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\第2篇 多线程程序设计的工具与手法\第7章 数据一致性\7.4 我需要锁定吗？">
      <UniqueIdentifier>{ef8b8b57-56e3-4403-93e0-c5e40ba3a31a}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\第2篇 多线程程序设计的工具与手法\第7章 数据一致性\7.5 锁定粒度">
      <UniqueIdentifier>{b93cce4c-a14c-414e-a787-14408a1fd07f}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\第2篇 多线程程序设计的工具与手法\第7章 数据一致性\7.6 提要">
      <UniqueIdentifier>{b8d02af0-896a-4a3f-a62c-1ed92dce9644}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\第2篇 多线程程序设计的工具与手法\第8章 使用C Run-time Library">
      <UniqueIdentifier>{c1c051bf-c919-4542-a921-635c641f05e6}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\第2篇 多线程程序设计的工具与手法\第8章 使用C Run-time Library\8.1 什么是C Run-time Library多线程版本">
      <UniqueIdentifier>{8ee55e31-a8b6-4225-aba8-7dd74853de21}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\第2篇 多线程程序设计的工具与手法\第8章 使用C Run-time Library\8.2 选择一个多线程版本的C Run-time Library">
      <UniqueIdentifier>{4c06bf83-bcfe-453b-bde1-23b61ab0dbcf}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\第2篇 多线程程序设计的工具与手法\第8章 使用C Run-time Library\8.3 以C Run-time Library启动线程">
      <UniqueIdentifier>{fde781a7-b471-430e-b9a7-267faf9c776a}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\第2篇 多线程程序设计的工具与手法\第8章 使用C Run-time Library\8.4 哪一个好：CreateThread%28%29抑或_beginthreadex%28%29？">
      <UniqueIdentifier>{2e4adc9e-43d6-422e-854e-fe96243b609e}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\第2篇 多线程程序设计的工具与手法\第8章 使用C Run-time Library\8.5 避免stdio.h">
      <UniqueIdentifier>{164d3bef-0ca1-4422-93c7-f405f61b6c15}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\第2篇 多线程程序设计的工具与手法\第8章 使用C Run-time Library\8.6 一个安全的多线程程序">
      <UniqueIdentifier>{372d3a4a-1e73-40f5-87f3-40d3d272571e}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\第2篇 多线程程序设计的工具与手法\第8章 使用C Run-time Library\8.7 结束进程">
      <UniqueIdentifier>{7c3d0573-2def-41bf-91e1-b5cbcb7729b2}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\第2篇 多线程程序设计的工具与手法\第8章 使用C Run-time Library\8.8 为什么你应该避免_beginthread%28%29">
      <UniqueIdentifier>{e7c03174-ee37-44a0-89a9-81478e7eee97}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\第2篇 多线程程序设计的工具与手法\第8章 使用C Run-time Library\8.9 提要">
      <UniqueIdentifier>{5d2edacd-597b-4afe-94f6-97386f5683af}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\第2篇 多线程程序设计的工具与手法\第9章 使用C++">
      <UniqueIdentifier>{8e141e7f-813c-46de-911b-03e7c47a5dde}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\第2篇 多线程程序设计的工具与手法\第9章 使用C++\9.1 处理有问题的_beginthreadex%28%29函数原型">
      <UniqueIdentifier>{569e3291-9146-4242-8376-69f4eb36b47f}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\第2篇 多线程程序设计的工具与手法\第9章 使用C++\9.2 以一个C++对象启动一个线程">
      <UniqueIdentifier>{59273850-836b-4df4-acb2-ab9239b1f606}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\第2篇 多线程程序设计的工具与手法\第9章 使用C++\9.3 建立比较安全的Critical Sections">
      <UniqueIdentifier>{971b4945-c515-4add-9b2d-91d78e24476f}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\第2篇 多线程程序设计的工具与手法\第9章 使用C++\9.4 建立比较安全的Locks">
      <UniqueIdentifier>{571fc21d-9e4b-4b47-af7a-da55e82a11f9}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\第2篇 多线程程序设计的工具与手法\第9章 使用C++\9.5 建立可互换的locks">
      <UniqueIdentifier>{25b73931-a1d2-4a01-8f60-471bdce1f87f}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\第2篇 多线程程序设计的工具与手法\第9章 使用C++\9.6 异常情况的处理">
      <UniqueIdentifier>{d9da31a3-26fe-4620-968b-e08f899fbd73}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\第2篇 多线程程序设计的工具与手法\第9章 使用C++\9.7 提要">
      <UniqueIdentifier>{069e494d-547a-4714-9f56-02e074b9cf22}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\第2篇 多线程程序设计的工具与手法\第10章 MFC中的线程">
      <UniqueIdentifier>{4a04404a-0c6b-4067-90f1-d46c5f8c9d02}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\第2篇 多线程程序设计的工具与手法\第10章 MFC中的线程\10.1 在MFC中启动一个Worker线程">
      <UniqueIdentifier>{e00f2947-5494-4f37-995c-89fd54ce9990}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\第2篇 多线程程序设计的工具与手法\第10章 MFC中的线程\10.2 安全地使用AfxBeginThread%28%29的传回值">
      <UniqueIdentifier>{c1d0deb8-57db-4827-b95c-d0f164a5d3ae}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\第2篇 多线程程序设计的工具与手法\第10章 MFC中的线程\10.3 在MFC中启动一个UI线程">
      <UniqueIdentifier>{72e0ad80-980e-4853-b301-0d017f5ab7e1}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\第2篇 多线程程序设计的工具与手法\第10章 MFC中的线程\10.4 与MFC对象共处">
      <UniqueIdentifier>{c57bd9db-032a-42bf-9938-c88148d9aff0}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\第2篇 多线程程序设计的工具与手法\第10章 MFC中的线程\10.5 MFC的同步控制">
      <UniqueIdentifier>{964b68e3-34ad-4404-9f57-38a59a2acf18}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\第2篇 多线程程序设计的工具与手法\第10章 MFC中的线程\10.6 MFC对于MsgWaitForMultipleObject%28%29的支持">
      <UniqueIdentifier>{9bfcd2d3-573c-462b-bba6-5232dcb128ed}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\第2篇 多线程程序设计的工具与手法\第10章 MFC中的线程\10.7 提要">
      <UniqueIdentifier>{7359707b-0e29-460c-8549-865df636d61f}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\第2篇 多线程程序设计的工具与手法\第11章 GDI与窗口管理">
      <UniqueIdentifier>{e4ecbdcb-2e93-44de-8254-63aa2f3502c8}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\第2篇 多线程程序设计的工具与手法\第11章 GDI与窗口管理\11.1 线程的消息队列">
      <UniqueIdentifier>{50bafadb-7876-4437-b06c-1bbfacbe5209}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\第2篇 多线程程序设计的工具与手法\第11章 GDI与窗口管理\11.2 消息如何周游列国">
      <UniqueIdentifier>{5aae69c5-1909-436a-80b6-3c349e6bd4bb}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\第2篇 多线程程序设计的工具与手法\第11章 GDI与窗口管理\11.3 GUI效率问题">
      <UniqueIdentifier>{92810d39-c248-482a-9b5c-052af635fdee}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\第2篇 多线程程序设计的工具与手法\第11章 GDI与窗口管理\11.4 以Worker线程完成多线程MDI程序">
      <UniqueIdentifier>{1bb54372-3ae0-4d8c-a892-21d3716bad3d}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\第2篇 多线程程序设计的工具与手法\第11章 GDI与窗口管理\11.5 多个上层窗口如何是好？">
      <UniqueIdentifier>{2dc061c0-dbf3-45a7-941d-a620d38d04c7}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\第2篇 多线程程序设计的工具与手法\第11章 GDI与窗口管理\11.6 线程之间的通讯">
      <UniqueIdentifier>{bb72d3d5-6230-4b8e-aa3e-eed606863399}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\第2篇 多线程程序设计的工具与手法\第11章 GDI与窗口管理\11.7 NT的影子线程">
      <UniqueIdentifier>{f6efc6e6-ea34-499a-9b61-9e26717f4b19}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\第2篇 多线程程序设计的工具与手法\第11章 GDI与窗口管理\11.8 关于“Cancel”对话框">
      <UniqueIdentifier>{04ef7d98-eada-4513-b04a-1b5c90d8c5ac}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\第2篇 多线程程序设计的工具与手法\第11章 GDI与窗口管理\11.9 锁住GDI对象">
      <UniqueIdentifier>{ca162686-2391-4e53-bb71-5cdc9cba72dd}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\第2篇 多线程程序设计的工具与手法\第11章 GDI与窗口管理\11.10 提要">
      <UniqueIdentifier>{ab3d532d-917d-402c-b9ac-74ab7e90d0ef}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\第2篇 多线程程序设计的工具与手法\第12章 调试">
      <UniqueIdentifier>{3f0f7d7a-cc9b-4d96-a337-1f86bef60d1a}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\第2篇 多线程程序设计的工具与手法\第12章 调试\12.1 使用WindowsNT">
      <UniqueIdentifier>{c2f19ddb-a154-4a30-928e-4bdacfb01dbb}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\第2篇 多线程程序设计的工具与手法\第12章 调试\12.2 有计划地对付错误">
      <UniqueIdentifier>{efbb3a83-db1c-4001-a964-32eeb746d99f}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\第2篇 多线程程序设计的工具与手法\第12章 调试\12.3 Bench Testing">
      <UniqueIdentifier>{8657371e-fc48-4e83-86ea-2c1561de49a7}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\第2篇 多线程程序设计的工具与手法\第12章 调试\12.4 线程对话框">
      <UniqueIdentifier>{9a8be9d1-dd74-4d28-af1a-fb918ae21679}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\第2篇 多线程程序设计的工具与手法\第12章 调试\12.5 运转记录">
      <UniqueIdentifier>{19394339-d737-4023-9aed-2740f5540874}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\第2篇 多线程程序设计的工具与手法\第12章 调试\12.6 内存记号">
      <UniqueIdentifier>{21289bc4-984b-4477-a32c-4c59f2a572a7}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\第2篇 多线程程序设计的工具与手法\第12章 调试\12.7 硬件调试寄存器">
      <UniqueIdentifier>{b47a031d-1596-4f91-ad43-b2a48046f95f}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\第2篇 多线程程序设计的工具与手法\第12章 调试\12.8 科学方法">
      <UniqueIdentifier>{e9f42a85-21c7-45bc-be24-8d12ad31a4e7}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\第2篇 多线程程序设计的工具与手法\第12章 调试\12.9 提要">
      <UniqueIdentifier>{ad1a03a6-6eeb-40f3-8224-7e217f358706}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\第2篇 多线程程序设计的工具与手法\第13章 进程之间的通讯">
      <UniqueIdentifier>{ea5395c2-eae6-4856-82a9-7fdb7866138e}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\第2篇 多线程程序设计的工具与手法\第13章 进程之间的通讯\13.1 以消息队列权充数据转运中心">
      <UniqueIdentifier>{44c1e617-62fd-475e-a99d-ff3c2a6097d8}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\第2篇 多线程程序设计的工具与手法\第13章 进程之间的通讯\13.2 使用共享内存">
      <UniqueIdentifier>{82800e14-4522-4fb2-b487-0671c7adc312}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\第2篇 多线程程序设计的工具与手法\第13章 进程之间的通讯\13.3 使用指针指向共享内存">
      <UniqueIdentifier>{fe521a78-1f4d-4ca8-b36c-7b6f8cb66b96}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\第2篇 多线程程序设计的工具与手法\第13章 进程之间的通讯\13.4 较高层次的进程通讯">
      <UniqueIdentifier>{b9b2e852-04da-48f0-8c89-d7b4936e2bb0}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\第2篇 多线程程序设计的工具与手法\第13章 进程之间的通讯\13.5 提要">
      <UniqueIdentifier>{a2c74576-b868-4ca3-a351-6c52bb12c5a1}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\第2篇 多线程程序设计的工具与手法\第14章 建造DLLs">
      <UniqueIdentifier>{e3ee8e7b-032b-4731-8128-1c1ce7046e61}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\第2篇 多线程程序设计的工具与手法\第14章 建造DLLs\14.1 DLL的通告消息">
      <UniqueIdentifier>{ad8c7256-0438-477a-94c5-03688667ba4b}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\第2篇 多线程程序设计的工具与手法\第14章 建造DLLs\14.2 通告消息的问题">
      <UniqueIdentifier>{07312e04-bc4e-4c1f-8862-cdd79bafd75c}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\第2篇 多线程程序设计的工具与手法\第14章 建造DLLs\14.3 DLL进入点的依序执行特性">
      <UniqueIdentifier>{cd8d57a5-a0ad-49d6-a02e-255440e89316}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\第2篇 多线程程序设计的工具与手法\第14章 建造DLLs\14.4 MFC中的DLL通告消息">
      <UniqueIdentifier>{0ddbf44e-2cfd-4bb2-85b9-70de9e0d8a91}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\第2篇 多线程程序设计的工具与手法\第14章 建造DLLs\14.5 喂食给Worker线程">
      <UniqueIdentifier>{1eb4b02c-e6a1-4778-a192-48227ae2225b}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\第2篇 多线程程序设计的工具与手法\第14章 建造DLLs\14.6 线程局部存储">
      <UniqueIdentifier>{24b1e8ad-8669-419d-b7e0-d7b23fcaaa37}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\第2篇 多线程程序设计的工具与手法\第14章 建造DLLs\14.7 _declspec%28thread%29">
      <UniqueIdentifier>{1edf0a70-aeb6-4457-a676-3f857968c61c}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\第2篇 多线程程序设计的工具与手法\第14章 建造DLLs\14.8 数据的一致性">
      <UniqueIdentifier>{9a4bf9f1-4b5c-44f1-8d56-5f7201958d98}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\第2篇 多线程程序设计的工具与手法\第14章 建造DLLs\14.9 提要">
      <UniqueIdentifier>{dd826d4e-fd6a-48d1-b7c5-54f9f5a5e863}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\第3篇 真实世界中的多线程应用程序">
      <UniqueIdentifier>{86652853-c771-4183-a748-b3fcf8b31f84}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\第3篇 真实世界中的多线程应用程序\第15章 规划一个应用程序">
      <UniqueIdentifier>{088dfa64-c79a-4e00-9a75-992857e9bfe7}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\第3篇 真实世界中的多线程应用程序\第15章 规划一个应用程序\15.1 多线程的理由">
      <UniqueIdentifier>{e6c052a6-18ae-4d07-b353-dd8c8495d753}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\第3篇 真实世界中的多线程应用程序\第15章 规划一个应用程序\15.2 要线程还是要进程？">
      <UniqueIdentifier>{2991db38-bf4f-469c-ba80-fa246dc3de71}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\第3篇 真实世界中的多线程应用程序\第15章 规划一个应用程序\15.3 多线程程序的架构">
      <UniqueIdentifier>{57df7c07-fe68-4b41-9508-5fab892527dd}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\第3篇 真实世界中的多线程应用程序\第15章 规划一个应用程序\15.4 评估既有程序代码的适用性">
      <UniqueIdentifier>{0dbd9c01-4eb7-4bfb-a3a2-a68ff9dfaafb}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\第3篇 真实世界中的多线程应用程序\第15章 规划一个应用程序\15.5 对ODBC做规划">
      <UniqueIdentifier>{16e336ba-74cc-4825-a653-a297330037b7}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\第3篇 真实世界中的多线程应用程序\第15章 规划一个应用程序\15.6 第三方的函数库">
      <UniqueIdentifier>{b2032683-ff5a-4a84-a8e4-7608dd567bd6}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\第3篇 真实世界中的多线程应用程序\第15章 规划一个应用程序\15.7 提要">
      <UniqueIdentifier>{19a66196-c4ab-4a4e-8ce1-23dfbf26596f}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\第3篇 真实世界中的多线程应用程序\第16章 ISAPI">
      <UniqueIdentifier>{60e2bf05-075a-4956-82e6-a10d90814105}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\第3篇 真实世界中的多线程应用程序\第16章 ISAPI\16.1  Web服务器及其工作原理">
      <UniqueIdentifier>{5e83eefd-ac21-42e4-b00b-34316aa19b57}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\第3篇 真实世界中的多线程应用程序\第16章 ISAPI\16.2 ISAPI">
      <UniqueIdentifier>{e0ca6fa2-618a-4e3d-9e13-66d3311d5b10}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\第3篇 真实世界中的多线程应用程序\第16章 ISAPI\16.3 IS2ODBC范例程序">
      <UniqueIdentifier>{d4f687a9-e06f-44ae-80eb-0d5e94e9ccba}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\第3篇 真实世界中的多线程应用程序\第16章 ISAPI\16.4 提要">
      <UniqueIdentifier>{c304432b-c7a3-4834-9af7-96034819d1f1}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\第3篇 真实世界中的多线程应用程序\第17章 OLE，ActiveX，COM">
      <UniqueIdentifier>{e1b6cb66-555d-4c0f-af66-1f78cc8e4e04}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\第3篇 真实世界中的多线程应用程序\第17章 OLE，ActiveX，COM\17.1 COM的线程模型">
      <UniqueIdentifier>{859f048e-57e0-4312-9e38-aa47c44dfdc7}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\第3篇 真实世界中的多线程应用程序\第17章 OLE，ActiveX，COM\17.2 AUTOINCR范例程序">
      <UniqueIdentifier>{10db2f06-f9fd-4b39-8f13-604adff1fb84}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\第3篇 真实世界中的多线程应用程序\第17章 OLE，ActiveX，COM\17.3 提要">
      <UniqueIdentifier>{7d9e8aa7-5481-45f9-8db3-980b76041a10}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\附录A MTVERIFY宏">
      <UniqueIdentifier>{c8842daa-971a-4d4c-8af3-2768c334819b}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Multithreading Applications in Win32（Win32 多线程程序设计）\附录B 更多的信息">
      <UniqueIdentifier>{1003ceab-791c-4c01-ac28-d022929fe950}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\0. 前言">
      <UniqueIdentifier>{c4c02a97-9f22-4b5a-91cf-8780560f6d90}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\0. 前言\0.1 关于多核编程">
      <UniqueIdentifier>{9e615246-e9f4-4367-922c-47361b19ce96}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\0. 前言\0.2 不同的视角">
      <UniqueIdentifier>{2663eb19-73ae-4b60-9754-c1bba96c0793}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\0. 前言\0.3 解决方案是多范型方法">
      <UniqueIdentifier>{9b89820f-c8f0-4b22-8ed7-f935078b4ba4}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\0. 前言\0.4 为什么使用C++">
      <UniqueIdentifier>{f458ed14-0647-4f2f-bc14-572483d80b44}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\0. 前言\0.5 UML图">
      <UniqueIdentifier>{a4089f14-ad91-4a5b-ad3b-2ef21f3812d6}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\0. 前言\0.6 支持的开发环境">
      <UniqueIdentifier>{4beab425-f4f3-4258-bcae-f99c591093f7}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\0. 前言\0.7 程序概要">
      <UniqueIdentifier>{189c342a-926a-4d34-8b18-b6b00a4c3763}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\0. 前言\0.8 测试及代码可靠性">
      <UniqueIdentifier>{f3e53951-75f1-47d6-ac63-5b2fe0c441e9}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\0. 前言\0.9 约定">
      <UniqueIdentifier>{79a563aa-e46a-4ac1-b6a0-09539d458b61}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\0. 前言\0.10 源代码">
      <UniqueIdentifier>{6adffb70-74f6-44c8-b9be-32fcd54ee129}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\0. 前言\0.11 勘误表">
      <UniqueIdentifier>{0a187ddb-be70-4f77-bf57-46d292df868c}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\0. 前言\0.12 p2p.wrox.com">
      <UniqueIdentifier>{73f5e995-7d9b-4cb2-b08d-3cb9765b2426}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第1章 新的体系结构">
      <UniqueIdentifier>{17453d98-df05-4f7c-bdf8-9add8df3b48c}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第1章 新的体系结构\1.1 什么是多核">
      <UniqueIdentifier>{a52f4839-98a2-4747-a576-4dbe309afc1f}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第1章 新的体系结构\1.2 多核体系结构">
      <UniqueIdentifier>{57f63085-d9ad-49ee-9325-23ff9d37ab66}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第1章 新的体系结构\1.3 软件开发人员眼中的多核体系结构">
      <UniqueIdentifier>{742e0865-b8af-4e30-b0d7-b973a3224ca5}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第1章 新的体系结构\1.3 软件开发人员眼中的多核体系结构\1.3.1 基本的处理器体系结构">
      <UniqueIdentifier>{c6a50475-50a9-4610-b90e-3df8d04212da}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第1章 新的体系结构\1.3 软件开发人员眼中的多核体系结构\1.3.2 CPU%28指令集%29">
      <UniqueIdentifier>{4711e78b-5ab0-4a20-930c-db5227cc3f2e}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第1章 新的体系结构\1.3 软件开发人员眼中的多核体系结构\1.3.3 内存是关键">
      <UniqueIdentifier>{5a626da7-5439-4b71-b4dc-668a0c940f6e}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第1章 新的体系结构\1.3 软件开发人员眼中的多核体系结构\1.3.4 寄存器">
      <UniqueIdentifier>{3db81f52-5584-4f75-a383-299668a301c4}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第1章 新的体系结构\1.3 软件开发人员眼中的多核体系结构\1.3.5 cache">
      <UniqueIdentifier>{3f5e457c-3c87-464f-94de-d3882b42ac83}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第1章 新的体系结构\1.3 软件开发人员眼中的多核体系结构\1.3.6 主存">
      <UniqueIdentifier>{0eee931e-f181-4530-b5e9-b451ae6233db}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第1章 新的体系结构\1.4 总线连接">
      <UniqueIdentifier>{f2f4dc25-26d8-4de1-8509-01b6acaab414}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第1章 新的体系结构\1.5 从单核到多核">
      <UniqueIdentifier>{ba6fbbef-d2ec-4bd5-9022-394f880ba7c3}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第1章 新的体系结构\1.5 从单核到多核\1.5.1 多道程序设计和多处理">
      <UniqueIdentifier>{ca34f426-58cb-4cd4-890b-e7696b44ddbe}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第1章 新的体系结构\1.5 从单核到多核\1.5.2 并行编程">
      <UniqueIdentifier>{90900bf2-b8d6-4378-a31a-f6a0c703d4e7}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第1章 新的体系结构\1.5 从单核到多核\1.5.3 多核应用程序的设计与实现">
      <UniqueIdentifier>{0c7a2a97-d150-41b7-878f-638b87004957}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第1章 新的体系结构\1.6 小结">
      <UniqueIdentifier>{46aa1c16-d919-4368-b265-865a4b4ef814}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第2章 4种有影响的多核设计">
      <UniqueIdentifier>{91f4ff61-2a90-42c2-b514-8a4575c1d893}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第2章 4种有影响的多核设计\2.1 AMD Multicore Opteron">
      <UniqueIdentifier>{1bbfe9d8-221d-47b3-bfd7-18c49bba4ba2}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第2章 4种有影响的多核设计\2.1 AMD Multicore Opteron\2.1.1 Opteron的直连和HyperTransport">
      <UniqueIdentifier>{48454e83-260b-4c5e-abf2-4d8f47535626}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第2章 4种有影响的多核设计\2.1 AMD Multicore Opteron\2.1.2 系统请求接口和交叉开关">
      <UniqueIdentifier>{f0970e53-ed79-419f-a40c-81d9d03c65bf}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第2章 4种有影响的多核设计\2.1 AMD Multicore Opteron\2.1.3 Opteron使用NUMA结构">
      <UniqueIdentifier>{c09d8fe5-c988-4c34-99b6-8781ea334415}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第2章 4种有影响的多核设计\2.1 AMD Multicore Opteron\2.1.4 cache以及多处理器Opteron">
      <UniqueIdentifier>{346ae77b-1456-4c94-964d-f13ef7134e5b}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第2章 4种有影响的多核设计\2.2 Sun UltraSparc T1 多处理器">
      <UniqueIdentifier>{0ad308ab-308b-4ea1-8c2a-e5242e8f4d6c}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第2章 4种有影响的多核设计\2.2 Sun UltraSparc T1 多处理器\2.2.1 UltraSparc T1内核">
      <UniqueIdentifier>{17c484e8-1cef-417d-939d-cdaf8decd175}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第2章 4种有影响的多核设计\2.2 Sun UltraSparc T1 多处理器\2.2.2 Cross Talk与Crossbar">
      <UniqueIdentifier>{cb2c3ec9-ee9d-4ec8-9a99-78fdcdbf0eb3}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第2章 4种有影响的多核设计\2.2 Sun UltraSparc T1 多处理器\2.2.3 DDRAM控制器和L2 cache">
      <UniqueIdentifier>{856b5f98-8995-45c7-901a-e5f45bbb1bef}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第2章 4种有影响的多核设计\2.2 Sun UltraSparc T1 多处理器\2.2.4 UltraSparc T1、Sun和GNU gcc编译器">
      <UniqueIdentifier>{d39b652a-5cbf-418d-93bb-3f0bf3471668}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第2章 4种有影响的多核设计\2.3 IBM Cell Broadband Engine">
      <UniqueIdentifier>{dc86720d-27b8-44e5-af83-3542cd9be962}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第2章 4种有影响的多核设计\2.3 IBM Cell Broadband Engine\2.3.1 CBE与Linux">
      <UniqueIdentifier>{068691ea-12b5-479b-93c2-035d14f6e538}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第2章 4种有影响的多核设计\2.3 IBM Cell Broadband Engine\2.3.2 CBE内存模型">
      <UniqueIdentifier>{09d2af69-e258-4de2-916a-6a5dc150920d}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第2章 4种有影响的多核设计\2.3 IBM Cell Broadband Engine\2.3.3 对操作系统隐藏">
      <UniqueIdentifier>{d61dd089-8cab-4016-a2df-83ea423cc6ff}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第2章 4种有影响的多核设计\2.3 IBM Cell Broadband Engine\2.3.4 协处理器部件">
      <UniqueIdentifier>{47863642-1ae4-4cf5-9526-d7a7a68ac78a}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第2章 4种有影响的多核设计\2.4 Intel Core 2 Duo处理器">
      <UniqueIdentifier>{1d927bba-385d-4505-99a0-a16cbff9f95a}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第2章 4种有影响的多核设计\2.4 Intel Core 2 Duo处理器\2.4.1 北桥和南桥">
      <UniqueIdentifier>{9e97db74-ba75-4aeb-8a75-bbe0898d4cd5}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第2章 4种有影响的多核设计\2.4 Intel Core 2 Duo处理器\2.4.2 Intel的PCI Express">
      <UniqueIdentifier>{9f89263f-f47c-43f0-a02f-03c91bbafb83}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第2章 4种有影响的多核设计\2.4 Intel Core 2 Duo处理器\2.4.3 Core 2 Duo的指令集">
      <UniqueIdentifier>{acddff98-df46-4e40-8f4c-3a9cf02b7180}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第2章 4种有影响的多核设计\2.5 小结">
      <UniqueIdentifier>{f1e186c0-e1e5-4fc3-9b4d-1d0e562a43e6}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第3章 多核编程的挑战">
      <UniqueIdentifier>{d8904fdb-429d-4ca7-ac2a-d1e8e7cca9fb}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第3章 多核编程的挑战\3.1 什么是顺序模型">
      <UniqueIdentifier>{0dc2a3a0-6da0-4bd6-9242-19d217ee123f}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第3章 多核编程的挑战\3.2 什么是并发">
      <UniqueIdentifier>{102b356a-0576-4ebe-98c8-11804a804903}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第3章 多核编程的挑战\3.3 软件开发">
      <UniqueIdentifier>{2b4638f5-e151-4587-af1d-90b9c7f7a502}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第3章 多核编程的挑战\3.3 软件开发\3.3.1 挑战1：软件分解">
      <UniqueIdentifier>{547e1f45-6d71-4cf9-9f78-930dcb1f119e}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第3章 多核编程的挑战\3.3 软件开发\3.3.2 挑战2：任务间通信">
      <UniqueIdentifier>{c809249c-4465-439c-8c50-330bb00f58c6}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第3章 多核编程的挑战\3.3 软件开发\3.3.3 挑战3：多个任务或agent对数据或资源的并发访问">
      <UniqueIdentifier>{0a8f970f-f61f-4e6a-91e8-3688b4ab67dd}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第3章 多核编程的挑战\3.3 软件开发\3.3.4 挑战4：识别并发执行的任务之间的关系">
      <UniqueIdentifier>{145e6745-16c6-4166-b869-7ec1174b6be4}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第3章 多核编程的挑战\3.3 软件开发\3.3.5 挑战5：控制任务之间的资源争夺">
      <UniqueIdentifier>{8543217f-8076-42dc-973f-adc7c4411413}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第3章 多核编程的挑战\3.3 软件开发\3.3.6 挑战6：需要多少个进程或线程">
      <UniqueIdentifier>{aeba1dbb-c746-4e16-8cfb-b9df26808e30}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第3章 多核编程的挑战\3.3 软件开发\3.3.7 挑战7和挑战8：寻找可靠的、可重现的调试和测试">
      <UniqueIdentifier>{c48941ff-3eed-484f-9dc9-53ed55ab27a0}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第3章 多核编程的挑战\3.3 软件开发\3.3.8 挑战9：与拥有多进程组件的设计的相关人员进行沟通">
      <UniqueIdentifier>{48063d34-e4d4-4881-8c9b-f730bc7ed141}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第3章 多核编程的挑战\3.3 软件开发\3.3.9 挑战10：在C++中实现多处理和多线程">
      <UniqueIdentifier>{641eda93-f099-4b39-9414-43d9d3d20dfc}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第3章 多核编程的挑战\3.4 C++开发人员必须学习新的库">
      <UniqueIdentifier>{02f1cb30-a251-473a-a0ca-180e7e1cf002}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第3章 多核编程的挑战\3.5 处理器架构的挑战">
      <UniqueIdentifier>{999bcd7b-b1d8-4850-84ca-e5d2560f58a5}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第3章 多核编程的挑战\3.6 小结">
      <UniqueIdentifier>{c993f403-644c-4db6-9ad2-8b7f12e6b779}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第4章 操作系统的任务">
      <UniqueIdentifier>{5b0ec149-157c-49fe-a4a4-ae0be7b3d6a7}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第4章 操作系统的任务\4.1 操作系统扮演什么角色">
      <UniqueIdentifier>{82feb4eb-9ed3-4dd2-bb42-7866984e7ddf}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第4章 操作系统的任务\4.1 操作系统扮演什么角色\4.1.1 提供一致的接口">
      <UniqueIdentifier>{aecf1f53-fa78-4597-93ea-bb0d963882f5}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第4章 操作系统的任务\4.1 操作系统扮演什么角色\4.1.2 管理硬件资源和其他应用软件">
      <UniqueIdentifier>{f4d94335-7edb-4041-b2d4-29d91b1c6be3}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第4章 操作系统的任务\4.1 操作系统扮演什么角色\4.1.3 开发人员与操作系统的交互">
      <UniqueIdentifier>{4dbabd80-1714-4d1a-ae3f-726c4519a176}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第4章 操作系统的任务\4.1 操作系统扮演什么角色\4.1.4 操作系统的核心服务">
      <UniqueIdentifier>{542bfc78-0dc2-4625-a2ee-7c82e63d64cb}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第4章 操作系统的任务\4.1 操作系统扮演什么角色\4.1.5 应用程序员的接口">
      <UniqueIdentifier>{ca62b081-b9b4-4e7d-88ba-860268953f15}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第4章 操作系统的任务\4.1 操作系统扮演什么角色\程序概要4-1">
      <UniqueIdentifier>{b333a5c4-ff62-4e77-a172-68f94ce26445}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第4章 操作系统的任务\4.1 操作系统扮演什么角色\程序概要4-2">
      <UniqueIdentifier>{a023ebde-3f83-4a34-9a85-182c3ee48cb6}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第4章 操作系统的任务\4.2 分解以及操作系统的任务">
      <UniqueIdentifier>{4c2f4028-d0fb-4489-9afd-33ab39399286}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第4章 操作系统的任务\4.3 隐藏操作系统的任务">
      <UniqueIdentifier>{6202512b-7b95-46f1-8268-5b6e6bb7189b}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第4章 操作系统的任务\4.3 隐藏操作系统的任务\4.3.1 利用C++抽象和封装的能力">
      <UniqueIdentifier>{35734bcb-9db5-4f0e-aefe-3ecf395e064d}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第4章 操作系统的任务\4.3 隐藏操作系统的任务\4.3.2 POSIX API的接口类">
      <UniqueIdentifier>{8762540e-b420-4f2f-919d-bf82b54f14ad}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第4章 操作系统的任务\4.4 小结">
      <UniqueIdentifier>{79a4fe79-78c4-47fb-9cd6-ac0acc7d439c}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第5章 进程、C++接口类和谓词">
      <UniqueIdentifier>{6263573f-e0b4-4845-8455-82719fb70543}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第5章 进程、C++接口类和谓词\5.1 多核是指多处理器">
      <UniqueIdentifier>{b4a553bc-c0b7-4363-83ba-0bc4fc161d4e}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第5章 进程、C++接口类和谓词\5.2 什么是进程">
      <UniqueIdentifier>{9369f2ab-c69c-4e33-973a-c8cc81a18fb5}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第5章 进程、C++接口类和谓词\5.3 为什么是进程而不是线程">
      <UniqueIdentifier>{69465021-c923-4f98-b8f7-05e5d94e49c4}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第5章 进程、C++接口类和谓词\5.4 使用posix_spawn%28%29">
      <UniqueIdentifier>{39652e2a-26fc-4338-8f5e-b00ec01115b6}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第5章 进程、C++接口类和谓词\5.4 使用posix_spawn%28%29\5.4.1 file_actions参数">
      <UniqueIdentifier>{45b8ec22-8dc7-4904-9696-f7f7c42c8cf7}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第5章 进程、C++接口类和谓词\5.4 使用posix_spawn%28%29\5.4.2 attrp参数">
      <UniqueIdentifier>{2fb89038-6870-44a8-a297-bc4de365b4e0}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第5章 进程、C++接口类和谓词\5.4 使用posix_spawn%28%29\5.4.3 简单的posix_spawn%28%29示例">
      <UniqueIdentifier>{c3cd110b-d91e-4edb-b4d6-b8a1f3588c69}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第5章 进程、C++接口类和谓词\5.4 使用posix_spawn%28%29\5.4.4 使用posix_spawn的guess_it">
      <UniqueIdentifier>{fc2a8839-0e25-405b-a1dc-6f228a10f038}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第5章 进程、C++接口类和谓词\5.5 哪个是父进程，哪个是子进程">
      <UniqueIdentifier>{9d564f06-57a4-429e-9230-68bc761d4853}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第5章 进程、C++接口类和谓词\5.6 对进程的详细讨论">
      <UniqueIdentifier>{e2bfca0f-0667-4b0d-8638-20df2085e0b8}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第5章 进程、C++接口类和谓词\5.6 对进程的详细讨论\5.6.1 进程控制块">
      <UniqueIdentifier>{e3bd9b3d-395a-4063-aa55-3d5140ca2066}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第5章 进程、C++接口类和谓词\5.6 对进程的详细讨论\5.6.2 进程的剖析">
      <UniqueIdentifier>{f26d9d1b-4806-40b5-b909-d58cca4baf60}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第5章 进程、C++接口类和谓词\5.6 对进程的详细讨论\5.6.3 进程状态">
      <UniqueIdentifier>{7e865293-6e31-4b89-b5b1-d5e995a2a4c1}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第5章 进程、C++接口类和谓词\5.6 对进程的详细讨论\5.6.4 进程是如何被调度的">
      <UniqueIdentifier>{3de90501-9181-42e5-8f15-24d39e52c266}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第5章 进程、C++接口类和谓词\5.7 使用ps实用工具监视进程">
      <UniqueIdentifier>{7175dc36-da2a-4859-9918-7909b3dd4e77}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第5章 进程、C++接口类和谓词\5.8 设置和获得进程优先级">
      <UniqueIdentifier>{febbe53e-fced-4c21-baf2-a9023ed153ad}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第5章 进程、C++接口类和谓词\5.9 什么是上下文切换">
      <UniqueIdentifier>{882dda61-4655-4eb1-b891-d1cd04fb02b1}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第5章 进程、C++接口类和谓词\5.10 进程创建中的活动">
      <UniqueIdentifier>{ba6f3a4b-1a62-4f8c-b179-7b8320d7dc36}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第5章 进程、C++接口类和谓词\5.10 进程创建中的活动\5.10.1 使用fork%28%29函数调用">
      <UniqueIdentifier>{8bd88e75-64db-4556-b9ea-b76a9f804618}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第5章 进程、C++接口类和谓词\5.10 进程创建中的活动\5.10.2 使用exec%28%29系统调用系列">
      <UniqueIdentifier>{5b1317a6-4069-453b-ac76-af26f25b92fc}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第5章 进程、C++接口类和谓词\5.11 进程环境变量的使用">
      <UniqueIdentifier>{62f6d97b-1d95-451d-b9b4-c2fbd2445a63}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第5章 进程、C++接口类和谓词\5.12 使用system%28%29生成新的进程">
      <UniqueIdentifier>{3631cdf5-b78b-4137-8922-b885168e6ffe}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第5章 进程、C++接口类和谓词\5.13 删除进程">
      <UniqueIdentifier>{89186710-d481-47f2-8939-8aaf33406b4f}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第5章 进程、C++接口类和谓词\5.13 删除进程\5.13.1 调用exit%28%29和abort%28%29">
      <UniqueIdentifier>{15ca4e69-815d-4f1c-ae39-16a8c60aeda8}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第5章 进程、C++接口类和谓词\5.13.2 kill%28%29函数">
      <UniqueIdentifier>{2603ffcf-40e6-4644-896a-005b699a4374}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第5章 进程、C++接口类和谓词\5.14 进程资源">
      <UniqueIdentifier>{0a1e87c9-c3bf-4a61-a0cd-1efa9878564f}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第5章 进程、C++接口类和谓词\5.14 进程资源\5.14.1 资源的类型">
      <UniqueIdentifier>{fdac3487-ae5a-486f-a8bc-023bc1117fa2}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第5章 进程、C++接口类和谓词\5.14 进程资源\5.14.2 设置资源限制的POSIX函数">
      <UniqueIdentifier>{714a8e32-d457-466e-b8d2-43038856b70c}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第5章 进程、C++接口类和谓词\5.15 异步进程和同步进程">
      <UniqueIdentifier>{3869f29e-53c9-4996-93eb-65f01983ed39}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第5章 进程、C++接口类和谓词\5.16 wait%28 %29函数调用">
      <UniqueIdentifier>{b45d1a11-d4cc-449c-b39c-6223305121db}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第5章 进程、C++接口类和谓词\5.17 谓词、进程和接口类">
      <UniqueIdentifier>{fb4b62f0-b448-4e20-ba59-18be8da934bb}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第5章 进程、C++接口类和谓词\5.18 小结">
      <UniqueIdentifier>{2a3704f8-856d-441c-be36-c2ae198ea957}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第6章 多线程">
      <UniqueIdentifier>{e1e238bb-14b6-4e9a-8c84-74445cd21a5c}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第6章 多线程\6.1 什么是线程">
      <UniqueIdentifier>{ad326f52-ed54-4a47-ae4b-0842a0760395}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第6章 多线程\6.1 什么是线程\6.1.1 用户级线程和内核级线程">
      <UniqueIdentifier>{dfc7e031-322f-4da8-aaef-ba10ea28487f}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第6章 多线程\6.1 什么是线程\6.1.2 线程上下文">
      <UniqueIdentifier>{3556ab37-c48a-451e-829c-f66ae3db1a0c}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第6章 多线程\6.1 什么是线程\6.1.3 硬件线程和软件线程">
      <UniqueIdentifier>{d2f42904-4748-437a-955a-17a841daf0fb}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第6章 多线程\6.1 什么是线程\6.1.4 线程资源">
      <UniqueIdentifier>{64af8d63-5696-4530-b0a0-c704d1015059}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第6章 多线程\6.2 线程和进程的比较">
      <UniqueIdentifier>{fe527dda-76eb-4ae2-bc69-be10f8963ed6}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第6章 多线程\6.2 线程和进程的比较\6.2.1 上下文切换">
      <UniqueIdentifier>{54f4b9cc-4e68-4eae-a8e2-8c6f69760b71}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第6章 多线程\6.2 线程和进程的比较\6.2.2 吞吐量">
      <UniqueIdentifier>{5ffdefdb-e615-4203-9fff-a272588aef1e}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第6章 多线程\6.2 线程和进程的比较\6.2.3 实体间的通信">
      <UniqueIdentifier>{4b8561a4-59cd-439e-92a6-1c6c64e3de81}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第6章 多线程\6.2 线程和进程的比较\6.2.4 破坏进程数据">
      <UniqueIdentifier>{13e01e45-e92d-4220-b7ef-4722dbb96161}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第6章 多线程\6.2 线程和进程的比较\6.2.5 删除整个进程">
      <UniqueIdentifier>{2c7d90ff-8db0-4ac1-a30f-c66dbdd53a6d}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第6章 多线程\6.2 线程和进程的比较\6.2.6 被其他程序重用">
      <UniqueIdentifier>{0bfc5120-a8ce-4427-b271-f8f48d1727d6}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第6章 多线程\6.2 线程和进程的比较\6.2.7 线程与进程的关键类似和差别">
      <UniqueIdentifier>{84269dae-b75f-4afe-a587-8f3800e7fbad}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第6章 多线程\6.3 设置线程属性">
      <UniqueIdentifier>{be954500-388e-47bd-b091-b51c8c3d2ce8}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第6章 多线程\6.4 线程的结构">
      <UniqueIdentifier>{05671b42-ff7c-4e16-8064-f7fb64e1ddee}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第6章 多线程\6.4 线程的结构\6.4.1 线程状态">
      <UniqueIdentifier>{68a78a67-48d6-45f7-a2e8-491b65c0d4a2}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第6章 多线程\6.4 线程的结构\6.4.2 调度和线程竞争范围">
      <UniqueIdentifier>{c954d4f3-086c-4434-908d-4f735e66aa5e}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第6章 多线程\6.4 线程的结构\6.4.3 调度策略和优先级">
      <UniqueIdentifier>{81adc821-56d9-4dd6-9aeb-b6b4b4881ecc}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第6章 多线程\6.4 线程的结构\6.4.4 调度分配域">
      <UniqueIdentifier>{24a1763b-6c88-42e9-be5e-58ef75dee0b2}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第6章 多线程\6.5 简单的线程程序">
      <UniqueIdentifier>{43bf7bae-8afe-4821-81c0-7d497bb564fd}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第6章 多线程\6.6 创建线程">
      <UniqueIdentifier>{9986afd6-834e-4585-89ab-924b8d64b5a2}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第6章 多线程\6.6 创建线程\6.6.1 向线程传递参数">
      <UniqueIdentifier>{13c0bdb0-78d2-4179-9121-c2512d25b2e9}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第6章 多线程\6.6 创建线程\6.6.2 结合线程">
      <UniqueIdentifier>{f6af85f1-366f-41df-91f9-f88bafa78817}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第6章 多线程\6.6 创建线程\6.6.3 获得线程id">
      <UniqueIdentifier>{62b367cf-021a-48ca-bb3b-afcb6ff99ece}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第6章 多线程\6.6 创建线程\6.6.4 使用pthread属性对象">
      <UniqueIdentifier>{a71df3b5-62f1-4ec1-b3cf-dd2070bbd551}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第6章 多线程\6.7 管理线程">
      <UniqueIdentifier>{a422f9d4-c688-4f31-9eb6-6050677a0cd2}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第6章 多线程\6.7 管理线程\6.7.1 终止线程">
      <UniqueIdentifier>{0f9fa587-c60a-4dec-a3a0-5f9a195d03fe}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第6章 多线程\6.7 管理线程\6.7.2 管理线程的栈">
      <UniqueIdentifier>{09092d02-6617-4bef-b74b-31f509b5e81d}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第6章 多线程\6.7 管理线程\6.7.3 设置线程调度和优先级">
      <UniqueIdentifier>{c8f486d7-37e4-4f1b-aba6-4dd20fecbfdd}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第6章 多线程\6.7 管理线程\6.7.4 设置线程的竞争范围">
      <UniqueIdentifier>{27ba02d5-b1a8-4b79-9054-5365c6c91ff5}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第6章 多线程\6.7 管理线程\6.7.5 使用sysconf%28%29">
      <UniqueIdentifier>{d528bc13-9be1-4655-b83d-55df7e6602d2}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第6章 多线程\6.7 管理线程\6.7.6 线程安全和库">
      <UniqueIdentifier>{3a464cf7-b4e7-4636-89ac-0810f3560673}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第6章 多线程\6.8 扩展线程接口类">
      <UniqueIdentifier>{318c4e9b-8dbb-4557-adbb-bb665f4f285c}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第6章 多线程\6.9 小结">
      <UniqueIdentifier>{8e100247-92c9-483b-a247-daf12d902c76}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第7章 并发任务的通信和同步">
      <UniqueIdentifier>{74c83f2f-d9aa-40fe-97ae-6248ee8a2da9}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第7章 并发任务的通信和同步\7.1 通信和同步">
      <UniqueIdentifier>{56f80a31-e8f3-4a07-9fa3-01ca65c544e3}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第7章 并发任务的通信和同步\7.1 通信和同步\7.1.1 依赖关系">
      <UniqueIdentifier>{181ba17b-b73c-4e5b-9bb1-303ddf170b85}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第7章 并发任务的通信和同步\7.1 通信和同步\7.1.2 对任务依赖进行计数">
      <UniqueIdentifier>{d32ffbff-59b8-49b8-9641-af34c8d0df3c}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第7章 并发任务的通信和同步\7.1 通信和同步\7.1.3 什么是进程间通信">
      <UniqueIdentifier>{47baf2d1-351b-48b5-9714-6348573519b5}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第7章 并发任务的通信和同步\7.1 通信和同步\7.1.4 什么是线程间通信">
      <UniqueIdentifier>{1f4f33de-9f1f-4274-ba8a-d999abefd416}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第7章 并发任务的通信和同步\7.2 对并发进行同步">
      <UniqueIdentifier>{f94dc4cc-4f98-4dc9-84b6-748e5abddc15}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第7章 并发任务的通信和同步\7.2 对并发进行同步\7.2.1 同步的类型">
      <UniqueIdentifier>{872425f0-3a5b-45fd-9ca5-09508fe57f71}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第7章 并发任务的通信和同步\7.2 对并发进行同步\7.2.2 同步对数据的访问">
      <UniqueIdentifier>{d83dfdcd-d45f-4f50-88d1-05ac9c8740e8}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第7章 并发任务的通信和同步\7.2 对并发进行同步\7.2.3 同步机制">
      <UniqueIdentifier>{83e72096-27a9-42b8-a4bf-f92fbce7b46a}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第7章 并发任务的通信和同步\7.3 线程策略方法">
      <UniqueIdentifier>{15a12464-1acc-4a42-a369-90573be008e2}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第7章 并发任务的通信和同步\7.3 线程策略方法\7.3.1 委托模型">
      <UniqueIdentifier>{259d65d5-d44d-4678-b20a-54de4d2467ca}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第7章 并发任务的通信和同步\7.3 线程策略方法\7.3.2 对等模型">
      <UniqueIdentifier>{4025192e-d34f-4d49-8546-86833b9a02d8}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第7章 并发任务的通信和同步\7.3 线程策略方法\7.3.3 生产者-消费者模型">
      <UniqueIdentifier>{93559fbc-858b-4fa8-9389-6ffa34882595}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第7章 并发任务的通信和同步\7.3 线程策略方法\7.3.4 流水线模型">
      <UniqueIdentifier>{a87f2ef5-a8fc-4bd1-b093-741ff9ff94ed}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第7章 并发任务的通信和同步\7.3 线程策略方法\7.3.5 用于线程的SPMD和MPMD">
      <UniqueIdentifier>{cb20f751-5508-4b08-a602-46d82b17d83c}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第7章 并发任务的通信和同步\7.4 工作的分解和封装">
      <UniqueIdentifier>{53e5f409-c369-4ea8-b392-54a19721e3da}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第7章 并发任务的通信和同步\7.4 工作的分解和封装\7.4.1 问题陈述">
      <UniqueIdentifier>{2569d4c3-4a2f-416b-9438-dc45e60e339a}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第7章 并发任务的通信和同步\7.4 工作的分解和封装\7.4.2 策略">
      <UniqueIdentifier>{63da6941-0221-4f3c-9397-92c6c6575a78}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第7章 并发任务的通信和同步\7.4 工作的分解和封装\7.4.3 观察">
      <UniqueIdentifier>{86e4bb5e-bf06-474f-93e5-9c58e9e3fdd3}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第7章 并发任务的通信和同步\7.4 工作的分解和封装\7.4.4 问题和解决方案">
      <UniqueIdentifier>{dbad375e-b0a6-4771-9485-d5c230f4bcc7}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第7章 并发任务的通信和同步\7.4 工作的分解和封装\7.4.5 流水线的简单agent模型实例">
      <UniqueIdentifier>{8a361d10-01be-4664-b197-71ac744dc065}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第7章 并发任务的通信和同步\7.5 小结">
      <UniqueIdentifier>{d8ac69c0-4081-4fc9-b576-1732c9b5d4b7}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第8章 PADL和PBS：应用程序设计方法">
      <UniqueIdentifier>{cd44a3a9-da3e-46f9-94e8-fffaf5e54496}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第8章 PADL和PBS：应用程序设计方法\8.1 为大规模多核处理器设计应用程序">
      <UniqueIdentifier>{ff45edcc-23d4-48f3-b058-63df3fd18a81}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第8章 PADL和PBS：应用程序设计方法\8.2 什么是PADL">
      <UniqueIdentifier>{a2f36828-6028-4a67-bd1e-d52fc3c3c1d5}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第8章 PADL和PBS：应用程序设计方法\8.2 什么是PADL\8.2.1 第5层：应用程序架构选择">
      <UniqueIdentifier>{af572d38-fd2b-48ad-890a-ef76feadc9a4}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第8章 PADL和PBS：应用程序设计方法\8.2 什么是PADL\8.2.2 第4层：PADL中的并发模型">
      <UniqueIdentifier>{c17214f8-4d03-43e3-bbd1-8e5cd013dcdb}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第8章 PADL和PBS：应用程序设计方法\8.2 什么是PADL\8.2.3 第3层：PADL的实现模型">
      <UniqueIdentifier>{832b0b8e-d451-4283-bb06-dbc2c32cded1}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第8章 PADL和PBS：应用程序设计方法\8.3 谓词分解结构">
      <UniqueIdentifier>{1a913364-7ca5-4403-abf2-bfc0423f1d8b}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第8章 PADL和PBS：应用程序设计方法\8.3 谓词分解结构\8.3.1 示例：Guess-My-Code游戏的PBS">
      <UniqueIdentifier>{32afd66f-071b-457a-bb2a-2f52d7600f88}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第8章 PADL和PBS：应用程序设计方法\8.3 谓词分解结构\8.3.2 将PBS、PADL和SDLC联系起来">
      <UniqueIdentifier>{26f38c7b-7a99-4071-b391-6bedb2d7388a}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第8章 PADL和PBS：应用程序设计方法\8.3 谓词分解结构\8.3.3 对PBS进行编码">
      <UniqueIdentifier>{724b5797-f066-4675-9238-a3c9cd3bc1a2}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第8章 PADL和PBS：应用程序设计方法\8.4 小结">
      <UniqueIdentifier>{95c479ec-ff45-450a-b9ae-1dc2dae08e5c}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第9章 对要求并发的软件系统进行建模">
      <UniqueIdentifier>{da90d1ff-66ac-4fba-ba70-42b36f979438}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第9章 对要求并发的软件系统进行建模\9.1 统一建模语言">
      <UniqueIdentifier>{25ffdbad-519a-41be-a870-5cd733f55714}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第9章 对要求并发的软件系统进行建模\9.2 对系统的结构进行建模">
      <UniqueIdentifier>{0a97e5ae-1bc1-494a-aba8-37dd05e2488d}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第9章 对要求并发的软件系统进行建模\9.2 对系统的结构进行建模\9.2.1 类模型">
      <UniqueIdentifier>{42918497-b8dc-400b-a041-5cac713d1bbb}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第9章 对要求并发的软件系统进行建模\9.2 对系统的结构进行建模\9.2.2 类的可视化">
      <UniqueIdentifier>{1426bb73-c8ee-4b2f-9fe8-3ea2bb546fc5}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第9章 对要求并发的软件系统进行建模\9.2 对系统的结构进行建模\9.2.3 对属性和服务进行排序">
      <UniqueIdentifier>{3063b23f-5545-4992-a85d-a43369c1e5fd}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第9章 对要求并发的软件系统进行建模\9.2 对系统的结构进行建模\9.2.4 类的实例的可视化">
      <UniqueIdentifier>{520a4a36-681e-433e-908a-97648b419bc1}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第9章 对要求并发的软件系统进行建模\9.2 对系统的结构进行建模\9.2.5 模板类的可视化">
      <UniqueIdentifier>{d911a52e-c6b1-42b5-835e-8245306b7d0e}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第9章 对要求并发的软件系统进行建模\9.2 对系统的结构进行建模\9.2.6 显示类与对象的关系">
      <UniqueIdentifier>{27fe7beb-8d0c-491c-87a4-a7b637a360d6}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第9章 对要求并发的软件系统进行建模\9.2 对系统的结构进行建模\9.2.7 接口类的可视化">
      <UniqueIdentifier>{7e8d6f58-bb51-4909-8efd-809a7018065b}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第9章 对要求并发的软件系统进行建模\9.2 对系统的结构进行建模\9.2.8 交互式对象的组织">
      <UniqueIdentifier>{469f9a54-a900-40cd-8630-d5a96606b91e}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第9章 对要求并发的软件系统进行建模\9.3 UML与并发行为">
      <UniqueIdentifier>{e6d08da1-05e7-47b7-9e47-17aee324381b}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第9章 对要求并发的软件系统进行建模\9.3 UML与并发行为\9.3.1 协作对象">
      <UniqueIdentifier>{8ad4fe17-f69c-4b7b-8e04-bbc2e642e26f}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第9章 对要求并发的软件系统进行建模\9.3 UML与并发行为\9.3.2 使用进程与线程的多任务与多线程">
      <UniqueIdentifier>{be4927b2-da37-43ee-b998-b2f185192270}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第9章 对要求并发的软件系统进行建模\9.3 UML与并发行为\9.3.3 对象间的消息序列">
      <UniqueIdentifier>{70810002-d5eb-4eed-975d-8afbd786afa3}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第9章 对要求并发的软件系统进行建模\9.3 UML与并发行为\9.3.4 对象的活动">
      <UniqueIdentifier>{236d52a9-0902-4c10-b695-78a7553d94a9}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第9章 对要求并发的软件系统进行建模\9.3 UML与并发行为\9.3.5 状态机">
      <UniqueIdentifier>{168ed7df-f087-40de-80d1-cf9d9b71475f}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第9章 对要求并发的软件系统进行建模\9.4 整个系统的可视化">
      <UniqueIdentifier>{e518417d-fd33-4949-9cb2-ad980ad26fdb}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第9章 对要求并发的软件系统进行建模\9.5 小结">
      <UniqueIdentifier>{337da51c-cf57-4c70-abff-cca19c4ee1db}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第10章 并行程序的测试和逻辑容错">
      <UniqueIdentifier>{f6eec281-a41a-4a6b-8813-5948254d9dfd}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第10章 并行程序的测试和逻辑容错\10.1 能否跳过测试">
      <UniqueIdentifier>{67cc27c1-3603-4eb1-b2f1-488ad314adf7}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第10章 并行程序的测试和逻辑容错\10.2 测试中必须检查的5个并发挑战">
      <UniqueIdentifier>{213153d8-8305-458c-81ea-3dcd3622ff4f}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第10章 并行程序的测试和逻辑容错\10.3 失效：缺陷与故障导致的结果">
      <UniqueIdentifier>{f333e11a-4823-405f-a6d4-c793723d78d4}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第10章 并行程序的测试和逻辑容错\10.3 失效：缺陷与故障导致的结果\10.3.1 基本的测试类型">
      <UniqueIdentifier>{02ef7cdb-a5ad-4f6b-a2ba-5d86a6f1120b}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第10章 并行程序的测试和逻辑容错\10.3 失效：缺陷与故障导致的结果\10.3.2 缺陷排除与缺陷存活">
      <UniqueIdentifier>{6b848630-e2a1-45ef-94ce-c8b87972c5fb}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第10章 并行程序的测试和逻辑容错\10.4 如何对并行程序实现缺陷排除">
      <UniqueIdentifier>{5dabe003-468a-424b-b20e-c9e3fbbd6e3f}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第10章 并行程序的测试和逻辑容错\10.4 如何对并行程序实现缺陷排除\10.4.1 问题陈述">
      <UniqueIdentifier>{660d29f7-5279-473e-a5e2-d63f5301c5fd}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第10章 并行程序的测试和逻辑容错\10.4 如何对并行程序实现缺陷排除\10.4.2 简单策略和粗解决方案模型">
      <UniqueIdentifier>{ea801851-8871-4d07-8949-886ef8c8c8e5}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第10章 并行程序的测试和逻辑容错\10.4 如何对并行程序实现缺陷排除\10.4.3 使用PADL第5层的修正的解决方案模型">
      <UniqueIdentifier>{8069ecc7-492c-4db2-bc50-f1f7cab32a19}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第10章 并行程序的测试和逻辑容错\10.4 如何对并行程序实现缺陷排除\10.4.4 agent解决方案模型的PBS">
      <UniqueIdentifier>{2aa4152b-3366-42e9-a5dc-1df78dd75c36}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第10章 并行程序的测试和逻辑容错\10.5 什么是标准软件工程测试">
      <UniqueIdentifier>{088de389-45af-4a52-b21e-75e769e8727e}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第10章 并行程序的测试和逻辑容错\10.5 什么是标准软件工程测试\10.5.1 软件验证与确认">
      <UniqueIdentifier>{b2c649f4-19c1-4bcc-86a6-c2811f0d1edf}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第10章 并行程序的测试和逻辑容错\10.5 什么是标准软件工程测试\10.5.2 代码不能正常工作该怎么办">
      <UniqueIdentifier>{7968b598-465e-41fe-95c9-613c1a7a4709}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第10章 并行程序的测试和逻辑容错\10.5 什么是标准软件工程测试\10.5.3 什么是逻辑容错">
      <UniqueIdentifier>{b5c635ce-b87e-481d-b170-b0e189750f53}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第10章 并行程序的测试和逻辑容错\10.5 什么是标准软件工程测试\10.5.4 谓词异常和可能世界">
      <UniqueIdentifier>{070dd8aa-5cdc-45ee-9aeb-b659600f3018}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第10章 并行程序的测试和逻辑容错\10.5 什么是标准软件工程测试\10.5.5 什么是模型检测">
      <UniqueIdentifier>{fc98ce46-2ea1-4124-bfa4-ea409b602a0a}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\第10章 并行程序的测试和逻辑容错\10.6 小结">
      <UniqueIdentifier>{ae5dae58-375a-4e5d-b23a-16fcfe55e43b}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\附录A 并发设计使用的UML">
      <UniqueIdentifier>{94b5dd8e-8638-4328-909d-2a97c8833a67}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\附录B 并发模型">
      <UniqueIdentifier>{78b1468b-d373-4847-a486-eedd67d45205}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\附录C 线程管理的POSIX标准">
      <UniqueIdentifier>{795135d9-141c-4d07-8e54-0aad68c06551}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Professional Multicore Programming（C++ 多核高级编程）\附录D 进程管理的POSIX标准">
      <UniqueIdentifier>{497ec663-600a-4875-8f9c-1c50926a5542}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\0. 前言">
      <UniqueIdentifier>{c783ce56-d901-4e81-b786-551cf1122545}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\0. 前言\0.1 学习本书的必要性">
      <UniqueIdentifier>{9f9bcd5b-4dc8-4a54-95b2-03b71603fc3e}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\0. 前言\0.2 发展趋势">
      <UniqueIdentifier>{8fd3d753-a647-4dd7-a3ca-1c4ab8d307c5}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\0. 前言\0.3 存在的难题">
      <UniqueIdentifier>{ea963648-8edc-4743-ae73-92e07b100e7e}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\0. 前言\0.4 解决方案">
      <UniqueIdentifier>{698d19e2-7647-4ae1-9812-166db629e6cc}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\0. 前言\0.5 本书为谁而写">
      <UniqueIdentifier>{834243f2-45f7-4333-9fed-da8459839329}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\0. 前言\0.6 本书的组织">
      <UniqueIdentifier>{3e13060e-aee5-4daa-842d-848ef9fa3d2a}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\0. 前言\0.7 类关系图">
      <UniqueIdentifier>{17585fe6-3219-42de-ae00-2dd24db4bdbd}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\0. 前言\0.8 支持的线程环境和编译器">
      <UniqueIdentifier>{e21f6312-94e4-46ef-9d84-7a72fd96ed21}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\0. 前言\0.9 测试与代码可靠性">
      <UniqueIdentifier>{21f3336a-0b61-417a-ab6f-67097189198f}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\0. 前言\0.10 致谢">
      <UniqueIdentifier>{903fdba2-6904-4bbf-a663-8168e1ebde66}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第1章 C++组件简介">
      <UniqueIdentifier>{78ab4184-a77d-467d-89ac-4a08aba85b38}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第1章 C++组件简介\1.1 既是好消息，也是坏消息">
      <UniqueIdentifier>{bf1e48e3-6202-47e3-8963-a0d63dcfbe9d}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第1章 C++组件简介\1.2 面向对象方法">
      <UniqueIdentifier>{1e0cc760-473a-4f91-ac18-39d7760d40c7}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第1章 C++组件简介\1.3 面向对象架构">
      <UniqueIdentifier>{b6b54015-171a-4ccc-86c0-f5e15607be05}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第1章 C++组件简介\1.4 C++组件">
      <UniqueIdentifier>{ef2c142c-b930-4975-8ca6-94639d502f41}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第1章 C++组件简介\1.5 面向对象软件组件">
      <UniqueIdentifier>{77d1d7ec-85c3-4daf-a573-b90cc3a5997e}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第1章 C++组件简介\1.5 面向对象软件组件\1.5.1 什么是类">
      <UniqueIdentifier>{ef0615e6-82dc-4e61-8184-0bef9bea47a8}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第1章 C++组件简介\1.5 面向对象软件组件\1.5.2 抽象数据类型">
      <UniqueIdentifier>{33a32617-a5a1-4ba3-9f33-a59da0907311}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第1章 C++组件简介\1.5 面向对象软件组件\1.5.3 类作为模型">
      <UniqueIdentifier>{f6c24e03-6f01-4646-b88c-0de99213475b}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第1章 C++组件简介\1.5 面向对象软件组件\1.5.4 类类型">
      <UniqueIdentifier>{986a69c9-d6f3-431b-bc4f-936fcf3cc867}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第2章 进程解剖">
      <UniqueIdentifier>{f961cd77-0eb3-43ba-a887-f90045ceb289}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第2章 进程解剖\2.1 什么是进程">
      <UniqueIdentifier>{74f482a8-413a-45ad-b61c-4ba1ae24d1b8}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第2章 进程解剖\2.2 进程状态">
      <UniqueIdentifier>{89c2b55f-af75-4e1b-b222-41cabb0ec249}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第2章 进程解剖\2.3 进程优先权">
      <UniqueIdentifier>{07444a0e-01f2-4e8c-b6f6-27a3abb9f31d}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第2章 进程解剖\2.4 上下文切换">
      <UniqueIdentifier>{6d53c72f-ac8f-48d1-988c-e6634f4bbaaa}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第2章 进程解剖\2.5 进程关系">
      <UniqueIdentifier>{0ac31c9d-abbf-4e2a-97e6-94244bd3c4b4}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第2章 进程解剖\2.5 进程关系\2.5.1 进程终止">
      <UniqueIdentifier>{a9eedf48-3544-4cbb-83b1-5d15cd7a982b}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第2章 进程解剖\2.5 进程关系\2.5.2 同步和异步进程">
      <UniqueIdentifier>{1b33e078-78e6-4190-9620-ed50ab2fb556}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第2章 进程解剖\2.6 进程映射">
      <UniqueIdentifier>{639c901f-d834-40b2-a53c-61efa62c3c11}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第2章 进程解剖\2.7 进程资源">
      <UniqueIdentifier>{e582020f-2700-469c-ba31-48543e72b138}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第2章 进程解剖\2.7 进程资源\2.7.1 硬件资源">
      <UniqueIdentifier>{47e8c8e8-ca00-41d8-8868-c14a642b5c8a}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第2章 进程解剖\2.7 进程资源\2.7.2 数据资源">
      <UniqueIdentifier>{5263e376-3eef-40b4-bc64-5eeeea44bf58}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第2章 进程解剖\2.7 进程资源\2.7.3 软件资源">
      <UniqueIdentifier>{3cef6c24-2e89-4136-8f68-30e513a6dee7}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第2章 进程解剖\2.7 进程资源\2.7.4 优先权与资源">
      <UniqueIdentifier>{abc11bf5-5248-4c2d-a56f-262389a3ddcc}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第3章 轻量级进程：线程">
      <UniqueIdentifier>{94f1cfaf-1f31-47bc-a713-cd780a791bc0}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第3章 轻量级进程：线程\3.1 多线程处理">
      <UniqueIdentifier>{1fc611e4-3959-4568-ab92-2726bd34795f}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第3章 轻量级进程：线程\3.2 线程与进程的相似之处">
      <UniqueIdentifier>{b46724be-e234-4a8e-8a7f-c0553a9a127e}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第3章 轻量级进程：线程\3.3 线程与进程的不同之处">
      <UniqueIdentifier>{d211768e-8dba-4a89-80c2-75b40cba7a73}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第3章 轻量级进程：线程\3.4 线程的优点">
      <UniqueIdentifier>{eb5c66e4-685e-47a3-9838-9f4ff53b8d88}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第3章 轻量级进程：线程\3.5 线程的缺点">
      <UniqueIdentifier>{21c2d7a4-2fab-4eb9-a9bd-85181abe54f9}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第3章 轻量级进程：线程\3.6 线程类型">
      <UniqueIdentifier>{676dd43a-734c-4b43-b439-67af957b05c0}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第3章 轻量级进程：线程\3.6 线程类型\3.6.1 休眠（sleeper）和单步（one-shot）">
      <UniqueIdentifier>{8a946953-cfa7-4428-b145-4f2588cc7360}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第3章 轻量级进程：线程\3.6 线程类型\3.6.2 先占工作">
      <UniqueIdentifier>{53bfefec-e586-4f06-acb2-0137e1748705}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第3章 轻量级进程：线程\3.6 线程类型\3.6.3 延迟工作">
      <UniqueIdentifier>{71b033fb-b4e6-4572-8e87-ae16d957924d}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第3章 轻量级进程：线程\3.7 线程相关信息">
      <UniqueIdentifier>{21d29e55-5f98-4104-9ec6-aa535b67f973}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第3章 轻量级进程：线程\3.8 线程创建">
      <UniqueIdentifier>{17e4802b-ae4b-4b42-ae7b-b67992c176f9}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第3章 轻量级进程：线程\3.8 线程创建\3.8.1 谁可以终止线程">
      <UniqueIdentifier>{d847db7a-0b23-41c6-a965-65a65c10a929}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第3章 轻量级进程：线程\3.8 线程创建\3.8.2 分离线程">
      <UniqueIdentifier>{dd229a8b-2074-4b38-abd2-da90eae28bc5}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第3章 轻量级进程：线程\3.8 线程创建\3.8.3 远程线程">
      <UniqueIdentifier>{d29775b8-062b-481c-b5f7-3f32b9049864}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第3章 轻量级进程：线程\3.9 线程堆栈">
      <UniqueIdentifier>{5a4a44ce-3b7e-4f62-b525-3caca0eb8369}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第3章 轻量级进程：线程\3.10 线程控制">
      <UniqueIdentifier>{75ead728-0ea8-48d8-bebc-602d2c319aa7}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第3章 轻量级进程：线程\3.10 线程控制\3.10.1 临界区">
      <UniqueIdentifier>{61b417ce-b85a-4da8-9faa-c4ed2fbc5740}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第3章 轻量级进程：线程\3.10 线程控制\3.10.2 挂起和恢复线程">
      <UniqueIdentifier>{0ba1b387-83db-4b4a-adb7-88ba314d92d5}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第3章 轻量级进程：线程\3.11 线程优先权">
      <UniqueIdentifier>{daef6321-10e1-4e72-9e1a-3a1765e2171a}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第3章 轻量级进程：线程\3.12 线程状态">
      <UniqueIdentifier>{9c3e473d-82e9-455d-8c49-dea50915932f}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第3章 轻量级进程：线程\3.13 线程与资源">
      <UniqueIdentifier>{94074877-5195-4b90-84df-56089bad3d86}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第3章 轻量级进程：线程\3.14 线程的实现模型：用户级线程">
      <UniqueIdentifier>{be423a32-a8b3-4bce-a4c7-f05b0a8ee244}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第3章 轻量级进程：线程\3.14 线程的实现模型：用户级线程\3.14.1 核心级线程">
      <UniqueIdentifier>{f5be01e6-f0c5-4d85-bec6-e9f8a9fa4eb4}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第3章 轻量级进程：线程\3.14 线程的实现模型：用户级线程\3.14.2 混合线程">
      <UniqueIdentifier>{4801b3dd-f77e-4ed4-a6dd-3e2395e04fdc}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第4章 多任务与多线程编程">
      <UniqueIdentifier>{fedbc62e-d12f-43b1-b854-c9c794af73be}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第4章 多任务与多线程编程\4.1 什么是多任务编程">
      <UniqueIdentifier>{ff5d8f58-f305-4efe-8d7f-e3d81ce2a2ee}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第4章 多任务与多线程编程\4.1 什么是多任务编程\4.1.1 对话级多任务编程">
      <UniqueIdentifier>{4a02e387-a4c3-4592-813c-9cda30d52e8d}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第4章 多任务与多线程编程\4.1 什么是多任务编程\4.1.2 进程级多任务编程">
      <UniqueIdentifier>{a0169774-bed9-4c10-b104-70903184b6e4}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第4章 多任务与多线程编程\4.1 什么是多任务编程\4.1.3 多线程编程">
      <UniqueIdentifier>{48a6e7cf-5a73-4836-8b66-c1a916e7950e}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第4章 多任务与多线程编程\4.2 合作和抢占式多任务">
      <UniqueIdentifier>{7eb547ce-7ba9-4098-bbce-212b3a5d0aa8}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第4章 多任务与多线程编程\4.2 合作和抢占式多任务\4.2.1 合作多任务">
      <UniqueIdentifier>{5ab0063c-d035-4b2e-9abf-0d399ffc64f6}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第4章 多任务与多线程编程\4.2 合作和抢占式多任务\4.2.2 抢占式多任务">
      <UniqueIdentifier>{5392c8e5-443e-4699-96e2-e643c67f613d}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第4章 多任务与多线程编程\4.2 合作和抢占式多任务\4.2.3 时间片的大小">
      <UniqueIdentifier>{3538a537-362c-461a-b0d4-070d4d27068c}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第4章 多任务与多线程编程\4.3 多处理器下的多线程">
      <UniqueIdentifier>{26574ded-5aaf-41e8-8334-c6c3fb5b682a}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第4章 多任务与多线程编程\4.3 多处理器下的多线程\4.3.1 非对称多处理器处理">
      <UniqueIdentifier>{e69a09cf-c9cf-4707-9860-51500db08122}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第4章 多任务与多线程编程\4.3 多处理器下的多线程\4.3.2 对称多处理器处理">
      <UniqueIdentifier>{391c4812-a593-40b5-abf8-9b500df01bb5}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第4章 多任务与多线程编程\4.3 多处理器下的多线程\4.3.3 具有多处理器的多线程处理模型">
      <UniqueIdentifier>{ef7a2af8-67c8-4079-a502-94a41b8d01c9}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第4章 多任务与多线程编程\4.4 规划策略">
      <UniqueIdentifier>{7b611af4-5812-449b-b2d4-f5903df5a85a}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第4章 多任务与多线程编程\4.4 规划策略\4.4.1 规划策略目标">
      <UniqueIdentifier>{8be66445-2657-4a48-afef-5ccb8cff9439}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第4章 多任务与多线程编程\4.4 规划策略\4.4.2 规划策略准则">
      <UniqueIdentifier>{50eed549-fd0d-47d0-8229-a8c1a0a5404d}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第4章 多任务与多线程编程\4.4 规划策略\4.4.3 轮询和FIFO规划">
      <UniqueIdentifier>{eb0472aa-5405-4a4d-a137-be0458e5dc77}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第4章 多任务与多线程编程\4.4 规划策略\4.4.4 最短任务优先规划法">
      <UniqueIdentifier>{73246e24-9382-4738-aa04-d10a8c4847bf}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第4章 多任务与多线程编程\4.4 规划策略\4.4.5 最短剩余时间规划法">
      <UniqueIdentifier>{a71bf1c7-fd0f-4b08-8ab1-52551c2b0cad}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第5章 进程间和线程间通信">
      <UniqueIdentifier>{5b8d1d9b-ea20-4a9e-bd80-ccce1520aea1}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第5章 进程间和线程间通信\5.1 依赖关系">
      <UniqueIdentifier>{83b73dd4-16c3-4bb6-a2d3-d4aea91b7312}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第5章 进程间和线程间通信\5.1 依赖关系\5.1.1 通信依赖性">
      <UniqueIdentifier>{46cd9a78-6681-430c-a56d-63e5b4a13678}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第5章 进程间和线程间通信\5.1 依赖关系\5.1.2 合作依赖性">
      <UniqueIdentifier>{2d1af143-1b10-40e2-a1bd-e1edff28fc6e}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第5章 进程间和线程间通信\5.1 依赖关系\5.1.3 计数线程与进程依赖性">
      <UniqueIdentifier>{587283e5-ec03-4249-962e-be88cd2555bf}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第5章 进程间和线程间通信\5.2 进程间和线程间通信">
      <UniqueIdentifier>{fd67bf79-8f14-46eb-bfe4-9fa207bc16fa}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第5章 进程间和线程间通信\5.2 进程间和线程间通信\5.2.1 什么是进程间通信">
      <UniqueIdentifier>{679d7dab-0329-424c-a817-1996a584ce6a}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第5章 进程间和线程间通信\5.2 进程间和线程间通信\5.2.2 进程间通信类型">
      <UniqueIdentifier>{67d4b7e0-3872-42ec-b546-6cfab6522bbb}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第5章 进程间和线程间通信\5.3 线程间通信">
      <UniqueIdentifier>{e1e75a0d-e3f7-4aa2-a152-bd73c308319d}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第6章 合作与同步">
      <UniqueIdentifier>{ee893f38-14ed-4cc1-9d81-e4a61f6bdce0}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第6章 合作与同步\6.1 竞争条件">
      <UniqueIdentifier>{ef4b24ae-3272-4f95-aff0-36ef2854c28f}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第6章 合作与同步\6.1 竞争条件\6.1.1 数据同步">
      <UniqueIdentifier>{c017cdc0-4dcb-4dd3-bfc0-3d111eb2485c}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第6章 合作与同步\6.1 竞争条件\6.1.2 硬件同步">
      <UniqueIdentifier>{bbe5edae-f09b-4b99-b92d-eb5221235d2e}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第6章 合作与同步\6.1 竞争条件\6.1.3 任务同步">
      <UniqueIdentifier>{e0bd30a7-429e-42f3-97dd-8104f227c267}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第6章 合作与同步\6.2 同步关系">
      <UniqueIdentifier>{6e7043d4-268d-413a-b68b-32fd4cdd2ab1}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第6章 合作与同步\6.3 进程同步机制">
      <UniqueIdentifier>{a95c1f39-990b-47fd-93b3-41f22e4d1b98}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第6章 合作与同步\6.3 进程同步机制\6.3.1 信号量提供钥匙">
      <UniqueIdentifier>{789cee65-f677-4781-b4ad-a3c7d80f27e0}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第6章 合作与同步\6.3 进程同步机制\6.3.2 信号量类型">
      <UniqueIdentifier>{a475e3a5-7554-47b1-897e-cd3702fed480}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第6章 合作与同步\6.3 进程同步机制\6.3.3 自愿互斥量策略">
      <UniqueIdentifier>{bf0f1cae-db98-476f-a46e-4add887fbefc}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第6章 合作与同步\6.3 进程同步机制\6.3.4 使用互斥量锁定防止竞争条件">
      <UniqueIdentifier>{87b863b3-0330-4135-b435-343f69ad8221}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第6章 合作与同步\6.3 进程同步机制\6.3.5 临界区">
      <UniqueIdentifier>{d41a7ee4-81a5-497d-b274-c8edee5beb53}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第6章 合作与同步\6.4 避免竞争条件">
      <UniqueIdentifier>{47ed5b6e-199e-42b6-951a-65421f9ba1dd}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第6章 合作与同步\6.5 死锁必需的条件">
      <UniqueIdentifier>{deaeaa5a-ea01-4d6b-891b-a895f8c3c1de}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第6章 合作与同步\6.6 远离死锁">
      <UniqueIdentifier>{f03f8ab1-d907-4e6a-b2c4-69ecf652754b}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第7章 接口类与进程间通信">
      <UniqueIdentifier>{eb704b6a-bb2f-403a-84aa-bfa580e92df9}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第7章 接口类与进程间通信\7.1 接口类详解">
      <UniqueIdentifier>{6d59402e-d255-4ebf-b090-bdae5acf9811}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第7章 接口类与进程间通信\7.1 接口类详解\7.1.1 接口类的类型">
      <UniqueIdentifier>{b6762c38-cfb7-446a-a85e-ee98c7347948}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第7章 接口类与进程间通信\7.1 接口类详解\7.1.2 减小参数和全局变量的数量">
      <UniqueIdentifier>{14068e78-6a92-46b0-90dc-165e07ebb709}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第7章 接口类与进程间通信\7.2 C++没有多线程处理的关键字">
      <UniqueIdentifier>{0fb9097d-9447-41a0-ac7e-b11611519b39}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第7章 接口类与进程间通信\7.3 面向对象接口到管道">
      <UniqueIdentifier>{be267f0f-07c6-44f9-93d5-61995bc6ff59}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第7章 接口类与进程间通信\7.4 使用接口类来实现面向对象命名管道">
      <UniqueIdentifier>{709a3df9-3122-4985-ad81-4117efef1345}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第7章 接口类与进程间通信\7.4 使用接口类来实现面向对象命名管道\7.4.1 相关客户/服务器术语">
      <UniqueIdentifier>{1bd7a00d-484a-45d7-9aea-d8cbd1b024d5}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第7章 接口类与进程间通信\7.4 使用接口类来实现面向对象命名管道\7.4.2 名字包含哪些内容">
      <UniqueIdentifier>{528b7c8d-20a3-48e6-99b9-efcf431cce3c}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第7章 接口类与进程间通信\7.4 使用接口类来实现面向对象命名管道\7.4.3 命名管道和iostream复合">
      <UniqueIdentifier>{8584ca28-68a8-41f0-a342-955e29bb2246}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第7章 接口类与进程间通信\7.4 使用接口类来实现面向对象命名管道\7.4.4 npstream接口类">
      <UniqueIdentifier>{8a01e507-a4e9-4c83-8554-3e0d5252bf0a}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第7章 接口类与进程间通信\7.4 使用接口类来实现面向对象命名管道\7.4.5 命名管道与STL istream_iterator和ostream_iterator">
      <UniqueIdentifier>{cd212803-4036-4dec-9ff7-da7b5fb472a3}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第8章 同步对象">
      <UniqueIdentifier>{4da93813-8ce8-48d2-a3d6-fab05b242a06}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第8章 同步对象\8.1 初识mutex类">
      <UniqueIdentifier>{886ff830-0aee-43d5-a061-4d87bbd2524c}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第8章 同步对象\8.1 初识mutex类\8.1.1 命名互斥量类">
      <UniqueIdentifier>{9da26f45-a007-4f69-8966-bf04ba4afb1d}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第8章 同步对象\8.1 初识mutex类\8.1.2 同步和依赖性关系（示例）">
      <UniqueIdentifier>{ecff6dd6-9745-400d-a69d-71df877a7bee}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第8章 同步对象\8.1 初识mutex类\8.1.3 表示条件的类">
      <UniqueIdentifier>{ede2a0fa-f326-4c96-b3cb-d5c821454726}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第8章 同步对象\8.1 初识mutex类\8.1.4 等待多个事件或互斥量">
      <UniqueIdentifier>{eb4999d9-4f27-4b5c-8202-68c2598fded3}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第8章 同步对象\8.1 初识mutex类\8.1.5 通过类成员函数锁定和取消锁定">
      <UniqueIdentifier>{9ab94557-b31c-42c2-9c58-b3dac3a1d246}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第8章 同步对象\8.1 初识mutex类\8.1.6 小结">
      <UniqueIdentifier>{4877bda1-2076-4b00-a720-48c20d8bfae6}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第9章 线程处理面向对象架构">
      <UniqueIdentifier>{61f90a7a-776c-48bd-a332-e068355d3268}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第9章 线程处理面向对象架构\9.1 什么是多线程架构">
      <UniqueIdentifier>{9ff9438a-ec51-4f40-bbc5-89df2ae07f51}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第9章 线程处理面向对象架构\9.2 使用多线程的常见架构">
      <UniqueIdentifier>{fb237b67-df68-4884-a51d-cf261b61b193}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第9章 线程处理面向对象架构\9.2 使用多线程的常见架构\9.2.1 文件服务器">
      <UniqueIdentifier>{a2956b39-693c-49da-a023-6688efe12de6}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第9章 线程处理面向对象架构\9.2 使用多线程的常见架构\9.2.2 数据库服务器和事务服务器">
      <UniqueIdentifier>{f0592a00-882b-4701-b4a9-7c7d1075f4af}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第9章 线程处理面向对象架构\9.2 使用多线程的常见架构\9.2.3 应用服务器">
      <UniqueIdentifier>{08d14113-4bda-4aa4-89d3-6e9ead391458}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第9章 线程处理面向对象架构\9.2 使用多线程的常见架构\9.2.4 事件驱动架构">
      <UniqueIdentifier>{24f7b115-9edf-4794-8771-41a4f953ec48}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第9章 线程处理面向对象架构\9.3 黑板架构">
      <UniqueIdentifier>{834f5559-8f2e-47d8-b9b8-1759862ebb17}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第9章 线程处理面向对象架构\9.4 途径上的不同（面向对象与过程化）">
      <UniqueIdentifier>{a40fb425-dd52-434f-9488-57b0d7bddee1}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第9章 线程处理面向对象架构\9.4 途径上的不同（面向对象与过程化）\9.4.1 封装是关键（保护和数据隐藏）">
      <UniqueIdentifier>{99bdd809-c6b8-4a4f-8b7d-8b80bb62be11}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第9章 线程处理面向对象架构\9.4 途径上的不同（面向对象与过程化）\9.4.2 类成员函数CREW策略">
      <UniqueIdentifier>{2ad35666-fb5e-4395-add1-c6cbf0c7f5d1}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第9章 线程处理面向对象架构\9.5 增量多线程处理">
      <UniqueIdentifier>{f58936ab-414c-4bff-9a49-285570f661f9}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第10章 类层次和线程处理C++组件">
      <UniqueIdentifier>{ca49e7e6-d705-4089-865e-04043a2501e4}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第10章 类层次和线程处理C++组件\10.1 抽象基类">
      <UniqueIdentifier>{3fe8be4b-e531-45c1-a445-c760123a6a87}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第10章 类层次和线程处理C++组件\10.2 具体类 理想终结者">
      <UniqueIdentifier>{a35dc16a-fc5a-4324-bed2-ead67b3dbe3d}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第10章 类层次和线程处理C++组件\10.2 具体类 理想终结者\10.2.1 多线程层次中的节点类">
      <UniqueIdentifier>{245f045b-8743-4664-b517-ab3cb92fd10e}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第10章 类层次和线程处理C++组件\10.2 具体类 理想终结者\10.2.2 线程与容器和集合类">
      <UniqueIdentifier>{b8683a33-2a6e-4c2b-b228-ceedd4ccd63f}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第10章 类层次和线程处理C++组件\10.2 具体类 理想终结者\10.2.3 应用框架类">
      <UniqueIdentifier>{10cb56de-6de7-4a60-a9ea-e2534472581f}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第11章 类行为和线程处理">
      <UniqueIdentifier>{2faddd28-a9df-4b0e-b83a-692080c86659}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第11章 类行为和线程处理\11.1 线程、对象和作用域">
      <UniqueIdentifier>{8db3e4be-045e-47bf-9355-8080f80e79d2}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第11章 类行为和线程处理\11.1 线程、对象和作用域\11.1.1 连接与作用域">
      <UniqueIdentifier>{b078dd68-4d16-46a5-a65c-6d5f6741b6f9}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第11章 类行为和线程处理\11.1 线程、对象和作用域\11.1.2 线程和类作用域">
      <UniqueIdentifier>{94992f0c-bd3a-4f94-b14f-d14802891cc1}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第11章 类行为和线程处理\11.2 同步关系和对象成员函数">
      <UniqueIdentifier>{768f20ea-221f-4ded-846e-d22a6d4a7a4c}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第11章 类行为和线程处理\11.3 在多线程环境中构建和析构对象">
      <UniqueIdentifier>{de6853ba-74b4-47da-b7a5-c20dac07f88e}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第11章 类行为和线程处理\11.3 在多线程环境中构建和析构对象\11.3.1 exit%28%29和abort%28%29">
      <UniqueIdentifier>{e8b1d083-a0fa-4f69-9054-6b83c1acde29}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第11章 类行为和线程处理\11.3 在多线程环境中构建和析构对象\11.3.2 构造函数和SS关系">
      <UniqueIdentifier>{388a7323-51a2-4686-a0c0-efcbf1ac247b}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第11章 类行为和线程处理\11.3 在多线程环境中构建和析构对象\11.3.3 析构函数与FF关系">
      <UniqueIdentifier>{42b0ab17-b35d-474c-804b-42b7957fab45}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第11章 类行为和线程处理\11.3 在多线程环境中构建和析构对象\11.3.4 线程集合与对象">
      <UniqueIdentifier>{c8a8fca9-0b33-41b0-8b10-3210f8c4e269}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第11章 类行为和线程处理\11.3 在多线程环境中构建和析构对象\11.3.5 线程与异常处理">
      <UniqueIdentifier>{b7e05e32-260d-48d1-b3f6-fa53bf6f0c81}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第11章 类行为和线程处理\11.4 线程安全函数">
      <UniqueIdentifier>{5a08cba6-f442-4701-88ff-2703adbe89a3}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第11章 类行为和线程处理\11.5 多线程环境中的不安全函数">
      <UniqueIdentifier>{136c266f-acca-4233-b3bf-93bbdc42297b}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第11章 类行为和线程处理\11.6 在多线程架构中使用STL算法">
      <UniqueIdentifier>{4c59d399-92ab-44de-b981-00f234557ba4}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第12章 测试多线程应用程序">
      <UniqueIdentifier>{bc4eb189-e787-4707-a9fc-dba0175cb496}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第12章 测试多线程应用程序\12.1 软件测试的目标">
      <UniqueIdentifier>{a4d24729-2da0-489a-9f22-b04979511d92}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第12章 测试多线程应用程序\12.1 软件测试的目标\12.1.1 分而治之（divide and conquer）">
      <UniqueIdentifier>{5ba0d2b9-439a-4d20-a15f-241d0d217317}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第12章 测试多线程应用程序\12.1 软件测试的目标\12.1.2 软件测试类型">
      <UniqueIdentifier>{3dd93eb0-b9da-45bb-9c0c-7778d063b67e}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第12章 测试多线程应用程序\12.1 软件测试的目标\12.1.3 对象的组件复合">
      <UniqueIdentifier>{8aa60493-0f9b-4640-9fde-23c8ff5fdacd}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第12章 测试多线程应用程序\12.1 软件测试的目标\12.1.4 成员函数访问数据组件">
      <UniqueIdentifier>{bce21774-58f2-4493-a0e1-a409d50daed4}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第12章 测试多线程应用程序\12.1 软件测试的目标\12.1.5 成员函数正确性">
      <UniqueIdentifier>{ce073b57-344a-427a-bb7e-8c244aff151d}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第12章 测试多线程应用程序\12.1 软件测试的目标\12.1.6 对象的过渡状态">
      <UniqueIdentifier>{a21c3452-0d69-43bb-96d2-9db9ba7436c0}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第12章 测试多线程应用程序\12.1 软件测试的目标\12.1.7 成员函数调用序列">
      <UniqueIdentifier>{60808f7b-c2c9-4f8a-910f-f272786c6bac}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第12章 测试多线程应用程序\12.1 软件测试的目标\12.1.8 对象完整性">
      <UniqueIdentifier>{10404efc-a93a-4625-8c21-273119f02c61}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第12章 测试多线程应用程序\12.2 对象的测试实例">
      <UniqueIdentifier>{9827cf59-49fc-4cd0-8d90-5a3e7e1abf25}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第12章 测试多线程应用程序\12.2 对象的测试实例\12.2.1 对象构建的测试实例">
      <UniqueIdentifier>{954cea61-d61f-4eed-a104-33c9ca763aff}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第12章 测试多线程应用程序\12.2 对象的测试实例\12.2.2 析构函数的测试实例">
      <UniqueIdentifier>{9c818866-f7fd-4b6d-91f2-9675f5942e02}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第12章 测试多线程应用程序\12.2 对象的测试实例\12.2.3 赋值的测试实例">
      <UniqueIdentifier>{412cde81-8381-4237-841d-1da1ea44cc71}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第12章 测试多线程应用程序\12.2 对象的测试实例\12.2.4 对象派生子类">
      <UniqueIdentifier>{3b0786d5-4c33-4c12-a024-96c67178105e}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第12章 测试多线程应用程序\12.2 对象的测试实例\12.2.5 成员函数性能的测试实例">
      <UniqueIdentifier>{cbd62844-3a8d-4017-b214-602165075526}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第12章 测试多线程应用程序\12.2 对象的测试实例\12.2.6 对象资源需求和测试实例">
      <UniqueIdentifier>{22345a11-0dd7-4f2f-878b-1b6cf01a2ad1}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第12章 测试多线程应用程序\12.2 对象的测试实例\12.2.7 测试公有对象访问、受保护对象访问以及线程化对象访问">
      <UniqueIdentifier>{f32ef7d1-ec57-4177-9806-778476fc5de6}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第12章 测试多线程应用程序\12.3 测试多线程架构的问题">
      <UniqueIdentifier>{f73d5ba4-3451-4cc1-a2fc-ff659e3ac62d}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第12章 测试多线程应用程序\12.3 测试多线程架构的问题\12.3.1 开放层次问题">
      <UniqueIdentifier>{c775cf5d-f921-4f68-8116-1284c84f4573}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第12章 测试多线程应用程序\12.3 测试多线程架构的问题\12.3.2 规划问题">
      <UniqueIdentifier>{67befa2d-bf86-41d3-b2ad-7e039aa69048}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第12章 测试多线程应用程序\12.4 使用常用模型和架构">
      <UniqueIdentifier>{26fc602f-5746-4094-8dd6-4e3dcaafa9d1}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\第13章 实现并发的最后思考">
      <UniqueIdentifier>{b03b0e0c-2ba7-4d40-8edb-c681930cdc84}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\附录A POSIX线程管理规范">
      <UniqueIdentifier>{b7959005-86c7-4686-9b9b-b3dd7b8871a3}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\附录B 类关系图规范">
      <UniqueIdentifier>{8138b148-7d9b-4d9b-ba96-818252681a40}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\附录C POSIX线程管理函数">
      <UniqueIdentifier>{b25e07ee-ea6d-4ea1-a262-42e5b2ec3fe8}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\附录D Win32线程管理函数">
      <UniqueIdentifier>{cc57ba76-61dc-4cc0-b8c8-11524119127b}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\附录E OS/2线程管理函数">
      <UniqueIdentifier>{94156d83-50ad-4856-ab22-16c9950d457f}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Object-Oriented Multithreading Using C++（C++ 面向对象多线程编程）\附录F 线程和同步类（POSIX, Win32以及OS/2）">
      <UniqueIdentifier>{18b46fa3-5858-443a-9c7b-784264f24ac3}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）">
      <UniqueIdentifier>{6dbb5e84-1029-451a-ba79-8ec99048c262}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\0. 前言">
      <UniqueIdentifier>{4afade3f-f9cb-422e-81f9-8354b578679a}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\0. 前言\0.1 第5版新增内容">
      <UniqueIdentifier>{2e347bea-5c8c-438f-9d16-aa4e28be437d}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\0. 前言\0.2 目的和读者群">
      <UniqueIdentifier>{ee33264a-b992-4fa7-ab7d-d9513a0358aa}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\0. 前言\0.3 本书的组织">
      <UniqueIdentifier>{4781a528-b3b8-4005-a9a9-40cd0e0baf7c}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\0. 前言\0.4 参考文献">
      <UniqueIdentifier>{95f4a55f-8c56-4cfe-ac60-7e764e719081}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\0. 前言\0.5 与第4版相关的改变">
      <UniqueIdentifier>{5a53d532-6212-49ca-be7c-4eec4fa7c0b3}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\0. 前言\0.6 致谢">
      <UniqueIdentifier>{034819ee-0180-4c33-a7e0-b4b3b0230ee2}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\0. 前言\0.7 Web站点">
      <UniqueIdentifier>{bd1113b0-dc1c-4cf4-b1bf-9d984d8b98ea}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第1章 分布式系统的特征">
      <UniqueIdentifier>{16ff516d-93a1-4393-94f7-3f8532fed65f}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第1章 分布式系统的特征\1.1 简介">
      <UniqueIdentifier>{a8f12178-c3e7-4a45-a45d-d5f5a48cb568}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第1章 分布式系统的特征\1.2 分布式系统的例子">
      <UniqueIdentifier>{127d3b94-c13d-4dac-896d-a6d7be7182c4}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第1章 分布式系统的特征\1.2 分布式系统的例子\1.2.1 Web搜索">
      <UniqueIdentifier>{68c88b42-0afd-43c3-a1fe-741e8236e87e}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第1章 分布式系统的特征\1.2 分布式系统的例子\1.2.2 大型多人在线游戏">
      <UniqueIdentifier>{5cc54f10-93fb-4adb-a1fa-3eef5b0450b1}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第1章 分布式系统的特征\1.2 分布式系统的例子\1.2.3 金融交易">
      <UniqueIdentifier>{c0cc27bf-8a5e-472c-96f9-e1b34c1a08c3}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第1章 分布式系统的特征\1.3 分布式系统的趋势">
      <UniqueIdentifier>{4feec100-b44a-4471-ad26-e3ef1c88174e}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第1章 分布式系统的特征\1.3 分布式系统的趋势\1.3.1 泛在联网和现代互联网">
      <UniqueIdentifier>{3a84d89e-5561-4854-ae45-fd7c56c9c561}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第1章 分布式系统的特征\1.3 分布式系统的趋势\1.3.2 移动和无处不在计算">
      <UniqueIdentifier>{fb6e3397-a9b1-4ab6-918e-87a458736992}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第1章 分布式系统的特征\1.3 分布式系统的趋势\1.3.3 分布式多媒体系统">
      <UniqueIdentifier>{8f8f3c85-3c9f-4e93-a9cd-d63be37d95db}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第1章 分布式系统的特征\1.3 分布式系统的趋势\1.3.4 把分布式计算作为一个公共设施">
      <UniqueIdentifier>{8b7ca901-f9e2-4a29-afb4-7cd6c6355b9c}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第1章 分布式系统的特征\1.4 关注资源共享">
      <UniqueIdentifier>{8dc9dfd6-6a08-4480-94f6-72393344a542}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第1章 分布式系统的特征\1.5 挑战">
      <UniqueIdentifier>{b631ebb6-84f0-44a8-94a2-17cc2f3474dd}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第1章 分布式系统的特征\1.5 挑战\1.5.1 异构性">
      <UniqueIdentifier>{7f089713-16fc-4209-a4df-9397a38d835f}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第1章 分布式系统的特征\1.5 挑战\1.5.2 开放性">
      <UniqueIdentifier>{4ac567cb-beee-4c67-9da3-8c5c48d739d6}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第1章 分布式系统的特征\1.5 挑战\1.5.3 安全性">
      <UniqueIdentifier>{dac84bd7-b993-4db8-b9be-f4e057599eb0}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第1章 分布式系统的特征\1.5 挑战\1.5.4 可伸缩性">
      <UniqueIdentifier>{4d809983-04cc-47ee-9f4e-5c1a94f3752e}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第1章 分布式系统的特征\1.5 挑战\1.5.5 故障处理">
      <UniqueIdentifier>{02d892a6-b8ce-4c65-9317-d9d409df12dc}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第1章 分布式系统的特征\1.5 挑战\1.5.6 并发性">
      <UniqueIdentifier>{02172f96-52a2-4a23-9462-71bb41939ab4}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第1章 分布式系统的特征\1.5 挑战\1.5.7 透明性">
      <UniqueIdentifier>{e3f09600-9589-492e-9347-f1dff01e3ba5}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第1章 分布式系统的特征\1.5 挑战\1.5.8 服务质量">
      <UniqueIdentifier>{698d2980-a016-4e58-8ffe-a4a4e948bfe4}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第1章 分布式系统的特征\1.6 实例研究：万维网">
      <UniqueIdentifier>{fcc02b3b-692d-477c-9fb1-c0fcc108f255}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第1章 分布式系统的特征\1.7 小结">
      <UniqueIdentifier>{57ef1241-77e5-4d72-b0ab-1f9aa31c6513}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第2章 系统模型">
      <UniqueIdentifier>{e7db4eec-1e51-42ec-bf47-3e83deb2e6b4}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第2章 系统模型\2.1 简介">
      <UniqueIdentifier>{0628cbea-b80f-40bc-8f22-84ad2df973f9}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第2章 系统模型\2.2 物理模型">
      <UniqueIdentifier>{5d8a3dc4-1d3f-48a5-a170-792c6cc843ca}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第2章 系统模型\2.3 体系结构模型">
      <UniqueIdentifier>{3300f9c5-96ca-4c4d-924a-eed73ce91a25}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第2章 系统模型\2.3 体系结构模型\2.3.1 体系结构元素">
      <UniqueIdentifier>{e6995166-aa7c-4971-a5a0-3d76b24b9d25}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第2章 系统模型\2.3 体系结构模型\2.3.2 体系结构模式">
      <UniqueIdentifier>{beca8139-75d0-4d91-af62-3444d54ec0f6}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第2章 系统模型\2.3 体系结构模型\2.3.3 相关的中间件解决方案">
      <UniqueIdentifier>{4cd94b81-6c4d-4e29-b416-f770ebdbf3ae}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第2章 系统模型\2.4 基础模型">
      <UniqueIdentifier>{f83f765d-cae5-4d75-a232-d9c7d869f17d}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第2章 系统模型\2.4 基础模型\2.4.1 交互模型">
      <UniqueIdentifier>{a3ef3e03-7d0d-4ca5-bb9e-69dde53ef26f}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第2章 系统模型\2.4 基础模型\2.4.2 故障模型">
      <UniqueIdentifier>{71b87ce8-1dd9-4a16-ae45-7ca1a1963fac}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第2章 系统模型\2.4 基础模型\2.4.3 安全模型">
      <UniqueIdentifier>{4f93d91b-4a37-4ae0-8bff-5d0689638901}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第2章 系统模型\2.5 小结">
      <UniqueIdentifier>{689ba0df-0c1d-4f88-babb-fcb82252ae57}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第3章 网络和网际互连">
      <UniqueIdentifier>{731f5272-986f-4a2f-8a36-21680f0538ee}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第3章 网络和网际互连\3.1 简介">
      <UniqueIdentifier>{936e2bdb-bcad-4cb5-bd5b-abbd2dd8447e}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第3章 网络和网际互连\3.2 网络类型">
      <UniqueIdentifier>{ed3f6d92-66a0-498b-89f1-a45dfd183b8d}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第3章 网络和网际互连\3.3 网络原理">
      <UniqueIdentifier>{0086a59f-a1a9-4deb-99ba-e06c009aef14}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第3章 网络和网际互连\3.3 网络原理\3.3.1 数据包的传输">
      <UniqueIdentifier>{ba6e30b5-9ba9-405d-8d83-914d82e4ef2f}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第3章 网络和网际互连\3.3 网络原理\3.3.2 数据流">
      <UniqueIdentifier>{aa5e3c49-8a6a-4f30-afa8-801af4d981e0}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第3章 网络和网际互连\3.3 网络原理\3.3.3 交换模式">
      <UniqueIdentifier>{5d4778e2-9c3f-4d67-962c-a312b20cbe0b}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第3章 网络和网际互连\3.3 网络原理\3.3.4 协议">
      <UniqueIdentifier>{3c76f440-0189-497a-b831-faaf8f194d23}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第3章 网络和网际互连\3.3 网络原理\3.3.5 路由">
      <UniqueIdentifier>{edb36cc6-8c24-4c06-a64c-d993a9c0c7fa}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第3章 网络和网际互连\3.3 网络原理\3.3.6 拥塞控制">
      <UniqueIdentifier>{e3345aa1-f3c1-43e8-925f-36e5c1d9d1dc}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第3章 网络和网际互连\3.3 网络原理\3.3.7 网际互连">
      <UniqueIdentifier>{1f8fd862-56be-4531-b783-16b6e62f2dba}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第3章 网络和网际互连\3.4 互联网协议">
      <UniqueIdentifier>{3735e8dc-b97a-4c3d-bf76-22db2cb384c7}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第3章 网络和网际互连\3.4 互联网协议\3.4.1 IP寻址">
      <UniqueIdentifier>{6d5b4b23-cab9-403d-88b5-39b97d4fcf5a}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第3章 网络和网际互连\3.4 互联网协议\3.4.2 IP协议">
      <UniqueIdentifier>{1a2ff4fa-a953-4a7b-917a-afb4973a5643}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第3章 网络和网际互连\3.4 互联网协议\3.4.3 IP路由">
      <UniqueIdentifier>{a5e52ce1-ff49-4a31-bb3d-8d773df0b75b}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第3章 网络和网际互连\3.4 互联网协议\3.4.4 IPv">
      <UniqueIdentifier>{57898953-3327-479a-9536-42426a481d1a}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第3章 网络和网际互连\3.4 互联网协议\3.4.5 移动IP">
      <UniqueIdentifier>{4d08ff39-69a5-4186-9317-e93a2f0a12f1}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第3章 网络和网际互连\3.4 互联网协议\3.4.6 TCP和UDP">
      <UniqueIdentifier>{05ca4bc1-2766-4e2a-8dce-fb5ad37eeae8}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第3章 网络和网际互连\3.4 互联网协议\3.4.7 域名">
      <UniqueIdentifier>{1bba4390-9165-4c41-abc2-3dce0a5d1c5b}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第3章 网络和网际互连\3.4 互联网协议\3.4.8 防火墙">
      <UniqueIdentifier>{402975f2-f108-4abb-9949-d4162098731d}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第3章 网络和网际互连\3.5 实例研究：以太网、WiFi、蓝牙">
      <UniqueIdentifier>{480bebca-7a83-4051-961f-c925feb88181}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第3章 网络和网际互连\3.5 实例研究：以太网、WiFi、蓝牙\3.5.1 以太网">
      <UniqueIdentifier>{0048b2c8-ab3c-4f01-bcdf-e12a8ea5e780}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第3章 网络和网际互连\3.5 实例研究：以太网、WiFi、蓝牙\3.5.2 IEEE 802.11无线LAN">
      <UniqueIdentifier>{56aaa7d4-8528-4fc0-bac4-1ff25ea0bdbe}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第3章 网络和网际互连\3.5 实例研究：以太网、WiFi、蓝牙\3.5.3 IEEE 802.15.1蓝牙无线PAN">
      <UniqueIdentifier>{1f8e95fe-e241-4156-9b4f-1c240ab80844}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第3章 网络和网际互连\3.6 小结">
      <UniqueIdentifier>{44a9ed12-fe81-4756-9701-f5e034fe32be}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第4章 进程间通信">
      <UniqueIdentifier>{53474419-97f9-4e61-b83a-0a16dbd82d1e}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第4章 进程间通信\4.1 简介">
      <UniqueIdentifier>{53841352-6b3e-4c96-af43-8d4824b79f84}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第4章 进程间通信\4.2 互联网协议的API">
      <UniqueIdentifier>{1b884d33-27f2-4b4c-b9e0-182836886915}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第4章 进程间通信\4.2 互联网协议的API\4.2.1 进程间通信的特征">
      <UniqueIdentifier>{cc608efa-0a8f-4993-aae4-864b4756b0c6}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第4章 进程间通信\4.2 互联网协议的API\4.2.2 套接字">
      <UniqueIdentifier>{b57ba565-0268-4cb6-a16d-6047338d91be}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第4章 进程间通信\4.2 互联网协议的API\4.2.3 UDP数据报通信">
      <UniqueIdentifier>{8cb156a0-9ce9-4e5e-b817-ee41b5be28b2}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第4章 进程间通信\4.2 互联网协议的API\4.2.4 TCP流通信">
      <UniqueIdentifier>{3159e969-ceb0-4247-9d7c-917fa1cada1a}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第4章 进程间通信\4.3 外部数据表示和编码">
      <UniqueIdentifier>{947a53c4-8b5e-4b46-85e2-313a0172eb53}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第4章 进程间通信\4.3 外部数据表示和编码\4.3.1 CORBA的公共数据表示">
      <UniqueIdentifier>{245fa00f-c775-4ed4-83a4-633e4109e1a0}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第4章 进程间通信\4.3 外部数据表示和编码\4.3.2 Java对象序列化">
      <UniqueIdentifier>{6b81d984-7dd0-4983-a2f5-0aa573302215}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第4章 进程间通信\4.3 外部数据表示和编码\4.3.3 可扩展标记语言">
      <UniqueIdentifier>{48e26c06-22ac-4e33-85b1-cb925a73fc2e}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第4章 进程间通信\4.3 外部数据表示和编码\4.3.4 远程对象引用">
      <UniqueIdentifier>{ace7b82c-173a-4064-9b0b-dd13df97fe85}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第4章 进程间通信\4.4 组播通信">
      <UniqueIdentifier>{b23e8ac1-3009-46a8-ae78-d4a548aba0e8}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第4章 进程间通信\4.4 组播通信\4.4.1 IP组播--组播通信的实现">
      <UniqueIdentifier>{4546bf85-d27e-4062-8685-e5703038f557}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第4章 进程间通信\4.4 组播通信\4.4.2 组播的可靠性和排序">
      <UniqueIdentifier>{5c032425-bcdb-467a-8a0e-ac0783f254d1}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第4章 进程间通信\4.5 网络虚拟化：覆盖网络">
      <UniqueIdentifier>{ff0c0df0-a926-4e0e-be7b-e35a09a5cf2a}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第4章 进程间通信\4.5 网络虚拟化：覆盖网络\4.5.1 覆盖网络">
      <UniqueIdentifier>{641f89b8-ebb0-4f16-8674-e7dd1ad788ec}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第4章 进程间通信\4.5 网络虚拟化：覆盖网络\4.5.2 Skype：一个覆盖网络的例子">
      <UniqueIdentifier>{db287f88-3ed2-4a25-8401-d74041b5f1b7}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第4章 进程间通信\4.6 实例研究：MPI">
      <UniqueIdentifier>{a4cf6875-de0b-4399-89e8-1be4d4c822b1}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第4章 进程间通信\4.7 小结">
      <UniqueIdentifier>{a8ef6e94-d5e6-404e-9cc3-113190e22f95}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第5章 远程调用">
      <UniqueIdentifier>{80dfd2eb-d3ff-442a-87df-fb0daba88f64}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第5章 远程调用\5.1 简介">
      <UniqueIdentifier>{1c481000-5eb7-4750-942f-68b1797d3aa4}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第5章 远程调用\5.2 请求-应答协议">
      <UniqueIdentifier>{55a5b45d-9587-448a-bb25-80d5d9d47b0a}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第5章 远程调用\5.3 远程过程调用">
      <UniqueIdentifier>{0c296375-290e-40fa-b361-4cfd6508b9a3}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第5章 远程调用\5.3 远程过程调用\5.3.1 RPC的设计问题">
      <UniqueIdentifier>{735e8f37-50d0-44bc-b930-831f62d3c8b5}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第5章 远程调用\5.3 远程过程调用\5.3.2 RPC的实现">
      <UniqueIdentifier>{92a29371-8ea8-413a-bdba-252d173a3c4b}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第5章 远程调用\5.3 远程过程调用\5.3.3 实例研究：Sun RPC">
      <UniqueIdentifier>{f52475ea-7b87-4cbd-9045-c04e6f88bc53}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第5章 远程调用\5.4 远程方法调用">
      <UniqueIdentifier>{1d7cec04-99e5-4a27-a5b2-04906420f431}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第5章 远程调用\5.4 远程方法调用\5.4.1 RMI的设计问题">
      <UniqueIdentifier>{2ebd6d8f-54db-4db5-85de-bd6c95438c6d}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第5章 远程调用\5.4 远程方法调用\5.4.2 RMI的实现">
      <UniqueIdentifier>{2f78873a-b34a-44d5-89dd-bf3453e55ffe}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第5章 远程调用\5.4 远程方法调用\5.4.3 分布式无用单元收集">
      <UniqueIdentifier>{383daed1-1501-4fdd-bd57-d6417e1265b4}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第5章 远程调用\5.5 实例研究：Java RMI">
      <UniqueIdentifier>{ae4fd987-6eb1-43de-b692-ab7a84060ec8}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第5章 远程调用\5.5 实例研究：Java RMI\5.5.1 创建客户和服务器程序">
      <UniqueIdentifier>{922fb0a9-90d7-463a-ba4f-dd28f719a9cb}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第5章 远程调用\5.5 实例研究：Java RMI\5.5.2 Java RMI的设计和实现">
      <UniqueIdentifier>{9aade493-0601-495d-abd3-f0f405b96737}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第5章 远程调用\5.6 小结">
      <UniqueIdentifier>{34074f83-d929-4b5f-be06-40721cd39b27}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第6章 间接通信">
      <UniqueIdentifier>{0f0ec70c-22b6-4740-bd97-f97691394cda}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第6章 间接通信\6.1 简介">
      <UniqueIdentifier>{55845258-5500-4389-9808-fe05626943c7}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第6章 间接通信\6.2 组通信">
      <UniqueIdentifier>{07e0b040-7969-4184-a2fc-3100274c6f75}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第6章 间接通信\6.2 组通信\6.2.1 编程模型">
      <UniqueIdentifier>{5d9f7a03-1b59-4ad8-a0b0-c7af5d1eaac7}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第6章 间接通信\6.2 组通信\6.2.2 实现问题">
      <UniqueIdentifier>{8e2834b5-80cd-4890-9336-5b536d8479e0}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第6章 间接通信\6.2 组通信\6.2.3 实例研究：JGroups工具箱">
      <UniqueIdentifier>{8850870b-c073-45e9-8956-866377266eab}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第6章 间接通信\6.3 发布-订阅系统">
      <UniqueIdentifier>{c232d9f2-0c05-481f-8826-e8043782100b}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第6章 间接通信\6.3 发布-订阅系统\6.3.1 编程模型">
      <UniqueIdentifier>{b98b730f-ffd7-4f08-b2e6-34489b503b48}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第6章 间接通信\6.3 发布-订阅系统\6.3.2 实现问题">
      <UniqueIdentifier>{c84bc21c-08cf-4fc9-8eeb-b19422ae3310}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第6章 间接通信\6.3 发布-订阅系统\6.3.3 发布-订阅系统的例子">
      <UniqueIdentifier>{7a6c49e8-fd03-44d9-9313-817bac64e1ef}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第6章 间接通信\6.4 消息队列">
      <UniqueIdentifier>{559c1a36-1a0b-4b42-a4d3-f8058afceed3}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第6章 间接通信\6.4 消息队列\6.4.1 编程模型">
      <UniqueIdentifier>{cddd4102-3047-4d26-b4bf-50adc73dfc01}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第6章 间接通信\6.4 消息队列\6.4.2 实现问题">
      <UniqueIdentifier>{8fd15761-0e7c-4e50-9a76-49e697f55afb}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第6章 间接通信\6.4 消息队列\6.4.3 实例研究：Java消息服务">
      <UniqueIdentifier>{42fb86fd-1318-4890-b4d5-87aa965feb0a}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第6章 间接通信\6.5 共享内存的方式">
      <UniqueIdentifier>{6421c68d-c15a-4401-8f6e-339a89a27093}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第6章 间接通信\6.5 共享内存的方式\6.5.1 分布式共享内存">
      <UniqueIdentifier>{40cec830-c906-42ef-8a6d-a36ef6e4c3da}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第6章 间接通信\6.5 共享内存的方式\6.5.2 元组空间通信">
      <UniqueIdentifier>{fc450178-e911-4131-9243-b95e64ff4aac}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第6章 间接通信\6.6 小结">
      <UniqueIdentifier>{d2d54166-f435-4ed2-965a-c1d6208c1862}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第7章 操作系统支持">
      <UniqueIdentifier>{a2ea213a-079b-4874-994a-e7480007387b}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第7章 操作系统支持\7.1 简介">
      <UniqueIdentifier>{3df7ed24-a392-465f-bf06-5cc7c55be966}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第7章 操作系统支持\7.2 操作系统层">
      <UniqueIdentifier>{b2a9c9d5-3378-4e55-bf15-f293af488dfa}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第7章 操作系统支持\7.3 保护">
      <UniqueIdentifier>{8c6d16bd-ac61-49a1-b7a6-98e2e1e0e3c6}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第7章 操作系统支持\7.4 进程和线程">
      <UniqueIdentifier>{c17bd0e1-728c-42c2-b581-b8c467d58b1c}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第7章 操作系统支持\7.4 进程和线程\7.4.1 地址空间">
      <UniqueIdentifier>{02e4506e-e916-45bb-bb79-8398cc9c2792}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第7章 操作系统支持\7.4 进程和线程\7.4.2 新进程的生成">
      <UniqueIdentifier>{6f31e461-40c0-4ecc-9c86-b3f81b436054}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第7章 操作系统支持\7.4 进程和线程\7.4.3 线程">
      <UniqueIdentifier>{b2097945-8ead-4948-9b48-846faf188a9c}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第7章 操作系统支持\7.5 通信和调用">
      <UniqueIdentifier>{b48a7d56-ea72-4cb3-bf6d-9058185a64fe}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第7章 操作系统支持\7.5 通信和调用\7.5.1 调用性能">
      <UniqueIdentifier>{078665a3-809d-4c9e-895d-071035b0ee18}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第7章 操作系统支持\7.5 通信和调用\7.5.2 异步操作">
      <UniqueIdentifier>{aaf9f548-8c82-441e-bb1d-460aca599c71}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第7章 操作系统支持\7.6 操作系统的体系结构">
      <UniqueIdentifier>{2ffd454b-83fe-4448-a5cd-cc88a4b0673a}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第7章 操作系统支持\7.7 操作系统层的虚拟化">
      <UniqueIdentifier>{1ea61ea4-d542-45a2-9bbb-e7f963104c85}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第7章 操作系统支持\7.7 操作系统层的虚拟化\7.7.1 系统虚拟化">
      <UniqueIdentifier>{daa67c4d-a19a-4d72-8799-d2e3244fb8d8}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第7章 操作系统支持\7.7 操作系统层的虚拟化\7.7.2 实例研究：系统虚拟化的Xen方法">
      <UniqueIdentifier>{a0d52826-8e47-40c7-b0b7-4372653ebcf5}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第7章 操作系统支持\7.8 小结">
      <UniqueIdentifier>{d68295a8-15e8-4077-8425-2cc53ef30094}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第8章 分布式对象和组件">
      <UniqueIdentifier>{b5c4e962-c86d-4c5c-8e25-279c8fc60b6c}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第8章 分布式对象和组件\8.1 简介">
      <UniqueIdentifier>{6b6c63bd-9420-499c-954b-332937fbca13}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第8章 分布式对象和组件\8.2 分布式对象">
      <UniqueIdentifier>{e52e852f-c8bd-40e7-80d2-d55472d30dad}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第8章 分布式对象和组件\8.3 实例研究：CORBA">
      <UniqueIdentifier>{9ed57bf8-1573-4bd4-89ce-395b03f94a48}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第8章 分布式对象和组件\8.3 实例研究：CORBA\8.3.1 CORBA RMI">
      <UniqueIdentifier>{ff731aac-b249-4bb4-854f-986ecd452998}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第8章 分布式对象和组件\8.3 实例研究：CORBA\8.3.2 CORBA的体系结构">
      <UniqueIdentifier>{d1a27513-5cf0-49f3-a1f9-0d5859aafce1}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第8章 分布式对象和组件\8.3 实例研究：CORBA\8.3.3 CORBA远程对象引用">
      <UniqueIdentifier>{73564c6a-a4b0-481b-9de9-a4388e09dd04}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第8章 分布式对象和组件\8.3 实例研究：CORBA\8.3.4 CORBA服务">
      <UniqueIdentifier>{60b86bfa-89ae-4f60-8d09-59df1fa81c26}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第8章 分布式对象和组件\8.3 实例研究：CORBA\8.3.5 CORBA客户和服务器实例">
      <UniqueIdentifier>{6975ab78-20e5-4d43-ad37-e8f8662f5280}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第8章 分布式对象和组件\8.4 从对象到组件">
      <UniqueIdentifier>{67112dbc-63b1-4e6d-8559-030e498ec347}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第8章 分布式对象和组件\8.5 实例研究：企业JavaBeans和Fractal">
      <UniqueIdentifier>{ce76048a-4a11-4660-8dfa-5840e475caf2}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第8章 分布式对象和组件\8.5 实例研究：企业JavaBeans和Fractal\8.5.1 企业JavaBeans">
      <UniqueIdentifier>{97ba7b57-d7b4-464e-b219-1cb08e956425}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第8章 分布式对象和组件\8.5 实例研究：企业JavaBeans和Fractal\8.5.2 Fractal">
      <UniqueIdentifier>{cfc09297-084a-4678-8a5e-ba4a68751e03}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第8章 分布式对象和组件\8.6 小结">
      <UniqueIdentifier>{25e2ee88-73d8-4024-b0b3-5854ac88a943}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第9章 Web服务">
      <UniqueIdentifier>{2fbf68be-dd2b-4b1c-af93-3d2368f9f5ba}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第9章 Web服务\9.1 简介">
      <UniqueIdentifier>{eabd3115-7c35-4174-b0cc-adc7e57f8548}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第9章 Web服务\9.2 Web服务">
      <UniqueIdentifier>{555d972a-0458-41e4-8f3f-cd22e9faed18}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第9章 Web服务\9.2 Web服务\9.2.1 SOAP">
      <UniqueIdentifier>{819f7fe5-8cb6-4700-93b8-62ccb2b69638}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第9章 Web服务\9.2 Web服务\9.2.2 Web服务与分布式对象模型的比较">
      <UniqueIdentifier>{b62808a0-630b-4da7-ab83-d447ce51a9c9}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第9章 Web服务\9.2 Web服务\9.2.3 在Java中使用SOAP">
      <UniqueIdentifier>{370f3cd3-ea4c-402d-8963-c78efbaf3cd0}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第9章 Web服务\9.2 Web服务\9.2.4 Web服务和CORBA的比较">
      <UniqueIdentifier>{eeb3b5c8-fb10-451c-9bb9-795fab721ba1}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第9章 Web服务\9.3 Web服务的服务描述和接口定义语言">
      <UniqueIdentifier>{f667f7e8-ccb2-4b3d-8904-19ea5c58911a}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第9章 Web服务\9.4 Web服务使用的目录服务">
      <UniqueIdentifier>{3213cd88-8f0c-4ad6-bfce-b5bb3c40b6ad}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第9章 Web服务\9.5 XML安全性">
      <UniqueIdentifier>{611305c0-6a49-42b0-9c18-206f390e2d31}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第9章 Web服务\9.6 Web服务的协作">
      <UniqueIdentifier>{38900e94-abbe-4a59-be3f-4ce674c6434a}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第9章 Web服务\9.7 Web服务的应用">
      <UniqueIdentifier>{bb906074-928d-4690-9439-d110490986fc}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第9章 Web服务\9.7 Web服务的应用\9.7.1 面向服务的体系结构">
      <UniqueIdentifier>{582a707b-be49-48e3-b1fe-ce7552dec456}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第9章 Web服务\9.7 Web服务的应用\9.7.2 网格">
      <UniqueIdentifier>{251469c0-df4d-4528-b8f6-15bc0df4b67a}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第9章 Web服务\9.7 Web服务的应用\9.7.3 云计算">
      <UniqueIdentifier>{3f8c3b28-3654-4a6c-b524-1051e9a8e03e}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第9章 Web服务\9.8 小结">
      <UniqueIdentifier>{cb183944-d1bb-434b-a6a1-b8d9604e5f8e}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第10章 对等系统">
      <UniqueIdentifier>{e900cf02-4296-431d-a200-21bf62fbcae7}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第10章 对等系统\10.1 简介">
      <UniqueIdentifier>{f89c672b-7471-49a7-aabd-1f4c3ac7a45a}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第10章 对等系统\10.2 Napster及其遗留系统">
      <UniqueIdentifier>{a8afb419-eaea-4e6a-ade3-8020ac86fa5e}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第10章 对等系统\10.3 对等中间件">
      <UniqueIdentifier>{1ec310d1-4496-4ad8-a73e-2c4146635b94}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第10章 对等系统\10.4 路由覆盖">
      <UniqueIdentifier>{6243ff91-935d-4274-ba29-25493979ff55}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第10章 对等系统\10.5 路由覆盖实例研究：Pastry和Tapestry">
      <UniqueIdentifier>{d14bb5f5-442f-4020-82b2-4834cb3bbb13}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第10章 对等系统\10.5 路由覆盖实例研究：Pastry和Tapestry\10.5.1 Pastry">
      <UniqueIdentifier>{8590b065-674a-4534-a10b-f06af3f9a9db}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第10章 对等系统\10.5 路由覆盖实例研究：Pastry和Tapestry\10.5.2 Tapestry">
      <UniqueIdentifier>{2b6ecd27-fca4-4e1d-b9c1-321a815772ae}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第10章 对等系统\10.5 路由覆盖实例研究：Pastry和Tapestry\10.5.3 从结构化对等方法到非结构化对等方法">
      <UniqueIdentifier>{68a45fc5-2a96-47f2-855c-003f50a26e0f}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第10章 对等系统\10.6 应用实例研究：Squirrel、OceanStore和Ivy">
      <UniqueIdentifier>{d83001e9-e89a-4144-92c5-ccfec4c034d5}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第10章 对等系统\10.6 应用实例研究：Squirrel、OceanStore和Ivy\10.6.1 Squirrel Web缓存">
      <UniqueIdentifier>{a8dd042c-ad20-428c-bbdd-b79c80d844b7}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第10章 对等系统\10.6 应用实例研究：Squirrel、OceanStore和Ivy\10.6.2 OceanStore文件存储">
      <UniqueIdentifier>{92277093-5055-4cce-9e52-d86c79c5a4c3}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第10章 对等系统\10.6 应用实例研究：Squirrel、OceanStore和Ivy\10.6.3 Ivy文件系统">
      <UniqueIdentifier>{eedf0e94-4ab9-4cbc-9f26-49dfcd226f03}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第10章 对等系统\10.7 小结">
      <UniqueIdentifier>{42cb3387-41c5-41cf-a2c8-ec4beb9c2f5a}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第11章 安全性">
      <UniqueIdentifier>{29d4d991-734e-4c12-805f-5d3b022a208f}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第11章 安全性\11.1 简介">
      <UniqueIdentifier>{96a15ab6-5476-4780-8fe5-28ff2778123d}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第11章 安全性\11.1 简介\11.1.1 威胁和攻击">
      <UniqueIdentifier>{4194a898-9580-4a15-9d9f-630ce619fd49}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第11章 安全性\11.1 简介\11.1.2 保护电子事务">
      <UniqueIdentifier>{14f7214a-b062-4f91-b8f9-37df1aa2e2cf}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第11章 安全性\11.1 简介\11.1.3 设计安全系统">
      <UniqueIdentifier>{24221a35-2b84-4e49-a1e0-ef27a4b79c14}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第11章 安全性\11.2 安全技术概述">
      <UniqueIdentifier>{3f71436b-8efd-4236-8707-b609486bffbe}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第11章 安全性\11.2 安全技术概述\11.2.1 密码学">
      <UniqueIdentifier>{e3ee3982-dc3d-44d5-8073-e8c784d05a01}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第11章 安全性\11.2 安全技术概述\11.2.2 密码学的应用">
      <UniqueIdentifier>{9a76f24a-7b29-4be5-8446-27abe30aec9d}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第11章 安全性\11.2 安全技术概述\11.2.3 证书">
      <UniqueIdentifier>{4273360c-d10e-4b5f-89a8-9b420ca2a724}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第11章 安全性\11.2 安全技术概述\11.2.4 访问控制">
      <UniqueIdentifier>{c512964c-5bee-4ece-9bd0-43d6d37a60b0}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第11章 安全性\11.2 安全技术概述\11.2.5 凭证">
      <UniqueIdentifier>{d8471ea4-4e14-44d8-a795-b3b7606c12dd}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第11章 安全性\11.2 安全技术概述\11.2.6 防火墙">
      <UniqueIdentifier>{76a1308b-14e9-4923-ad30-3b7fa2485da8}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第11章 安全性\11.3 密码算法">
      <UniqueIdentifier>{608674c2-ebdd-4cde-b777-e3ec0a89a2aa}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第11章 安全性\11.3 密码算法\11.3.1 密钥（对称）算法">
      <UniqueIdentifier>{a3a020c8-9c32-4f10-af5c-288271d2d567}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第11章 安全性\11.3 密码算法\11.3.2 公钥（不对称）算法">
      <UniqueIdentifier>{1c7d3cc4-dba6-4699-8543-db0a81f3ca25}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第11章 安全性\11.3 密码算法\11.3.3 混合密码协议">
      <UniqueIdentifier>{6e170d57-f663-4c91-a56a-a003c9d5afff}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第11章 安全性\11.4 数字签名">
      <UniqueIdentifier>{b6a685b7-12d5-4885-8035-d0cd515b4fbc}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第11章 安全性\11.4 数字签名\11.4.1 公钥数字签名">
      <UniqueIdentifier>{a384b5f3-8d4e-48f9-b872-2cf63bf21c2d}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第11章 安全性\11.4 数字签名\11.4.2 密钥数字签名--MAC">
      <UniqueIdentifier>{736806ae-6321-4038-bef5-f0e06d642232}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第11章 安全性\11.4 数字签名\11.4.3 安全摘要函数">
      <UniqueIdentifier>{30c5d417-bbb9-4736-b449-19e32ef4350c}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第11章 安全性\11.4 数字签名\11.4.4 证书标准和证书权威机构">
      <UniqueIdentifier>{47d7db2c-e8cb-4da5-a081-86f0247f234a}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第11章 安全性\11.5 密码实用学">
      <UniqueIdentifier>{37159eab-ded3-4fb2-a4bf-1d386118c337}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第11章 安全性\11.5 密码实用学\11.5.1 密码算法的性能">
      <UniqueIdentifier>{410ec3a0-83b1-43ea-8d1b-441bbe0a2d30}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第11章 安全性\11.5 密码实用学\11.5.2 密码学的应用和政治障碍">
      <UniqueIdentifier>{807111bd-421d-4c3f-bbec-c71a4cdf07db}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第11章 安全性\11.6 实例研究：Needham-Schroeder、Kerberos、TLS和802.11 WiFi">
      <UniqueIdentifier>{b696d681-ff69-47b5-a778-44ab8a978f35}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第11章 安全性\11.6 实例研究：Needham-Schroeder、Kerberos、TLS和802.11 WiFi\11.6.1 Needham-Schroeder认证协议">
      <UniqueIdentifier>{2ee197d9-8a9f-45e2-8af8-6871f0864160}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第11章 安全性\11.6 实例研究：Needham-Schroeder、Kerberos、TLS和802.11 WiFi\11.6.2 Kerberos">
      <UniqueIdentifier>{018861ba-dbbe-4a3d-8abb-c160b4fd7611}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第11章 安全性\11.6 实例研究：Needham-Schroeder、Kerberos、TLS和802.11 WiFi\11.6.3 使用安全套接字确保电子交易安全">
      <UniqueIdentifier>{c26dec25-a00f-405d-8b2f-82aa9049cf95}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第11章 安全性\11.6 实例研究：Needham-Schroeder、Kerberos、TLS和802.11 WiFi\11.6.4 IEEE 802.11 WiFi安全设计中最初的缺陷">
      <UniqueIdentifier>{a64f8db4-e498-40ef-b6cd-6483e8f110cd}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第11章 安全性\11.7 小结">
      <UniqueIdentifier>{77cc1bff-ff24-4943-827e-6e9e249dbe8a}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第12章 分布式文件系统">
      <UniqueIdentifier>{a7ece66b-b7ea-4a0d-ae06-4b93e83946f9}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第12章 分布式文件系统\12.1 简介">
      <UniqueIdentifier>{9cafbd6b-7ee7-49cb-a455-c3891c6f6998}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第12章 分布式文件系统\12.1 简介\12.1.1 文件系统的特点">
      <UniqueIdentifier>{6b5ccd74-dfb0-4d73-93c3-79779210da89}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第12章 分布式文件系统\12.1 简介\12.1.2 分布式文件系统的需求">
      <UniqueIdentifier>{eb01084e-ff20-410e-9a89-07b5ac51d3bb}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第12章 分布式文件系统\12.1 简介\12.1.3 实例研究">
      <UniqueIdentifier>{417908da-30eb-4a08-a688-4b6c64e522a3}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第12章 分布式文件系统\12.2 文件服务体系结构">
      <UniqueIdentifier>{4a37f402-1813-462d-96f0-32e7172dd7f6}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第12章 分布式文件系统\12.3 实例研究：SUN网络文件系统">
      <UniqueIdentifier>{bf8f76ba-602c-4451-a207-fcc11416ee1c}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第12章 分布式文件系统\12.4 实例研究：Andrew文件系统">
      <UniqueIdentifier>{912c0dfa-14cb-4518-b65f-f3694029b26e}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第12章 分布式文件系统\12.4 实例研究：Andrew文件系统\12.4.1 实现">
      <UniqueIdentifier>{6d07ad8e-d415-4ae7-9610-a5d6e08a8d09}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第12章 分布式文件系统\12.4 实例研究：Andrew文件系统\12.4.2 缓存的一致性">
      <UniqueIdentifier>{b6859c70-474c-474c-bb69-1135341be35a}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第12章 分布式文件系统\12.4 实例研究：Andrew文件系统\12.4.3 其他方面">
      <UniqueIdentifier>{ec60e536-42bb-4db2-8107-cf536827373e}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第12章 分布式文件系统\12.5 最新进展">
      <UniqueIdentifier>{2cec3c81-b8f5-489c-a695-265a950e7db2}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第12章 分布式文件系统\12.6 小结">
      <UniqueIdentifier>{158f1ae7-8ca3-4318-8500-2245d2ecb6ab}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第13章 名字服务">
      <UniqueIdentifier>{05ba1607-2368-4e20-b301-9e266d475451}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第13章 名字服务\13.1 简介">
      <UniqueIdentifier>{8c7bbcb7-f5de-4620-b4b9-0300e7a9ba1f}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第13章 名字服务\13.2 名字服务和域名系统">
      <UniqueIdentifier>{5c0d8d15-3147-4ae3-a28b-faed0a19ab31}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第13章 名字服务\13.2 名字服务和域名系统\13.2.1 名字空间">
      <UniqueIdentifier>{667e6bb6-831c-4dc7-a3d5-5b37ff6c63e0}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第13章 名字服务\13.2 名字服务和域名系统\13.2.2 名字解析">
      <UniqueIdentifier>{506167b3-dafa-4fdd-895a-0b46c6c62185}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第13章 名字服务\13.2 名字服务和域名系统\13.2.3 域名系统">
      <UniqueIdentifier>{fea74211-6558-4bd9-8ba7-093d29a20b2b}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第13章 名字服务\13.3 目录服务">
      <UniqueIdentifier>{31fff163-bb6e-40de-85ad-bee4e7cc1333}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第13章 名字服务\13.4 实例研究：全局名字服务">
      <UniqueIdentifier>{c10d6de6-737b-4b79-8ab1-a4f37d358281}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第13章 名字服务\13.5 实例研究：X.500目录服务">
      <UniqueIdentifier>{430f1056-7bfc-475a-989e-7fac073421a5}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第13章 名字服务\13.6 小结">
      <UniqueIdentifier>{95a83d1c-d909-4503-9c2d-b3d8a8f3db3e}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第14章 时间和全局状态">
      <UniqueIdentifier>{bc6861e3-fdd7-4c2f-9a10-8047466d7c44}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第14章 时间和全局状态\14.1 简介">
      <UniqueIdentifier>{a33e81f7-8dd0-451d-8ac3-555400b5ba29}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第14章 时间和全局状态\14.2 时钟、事件和进程状态">
      <UniqueIdentifier>{7a15dbf4-e952-4a2a-aa5b-f05dd02489c0}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第14章 时间和全局状态\14.3 同步物理时钟">
      <UniqueIdentifier>{31a491cb-6029-4896-bee7-c10685fcd43f}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第14章 时间和全局状态\14.3 同步物理时钟\14.3.1 同步系统中的同步">
      <UniqueIdentifier>{2c72d833-3456-4856-84d9-10f006b9374f}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第14章 时间和全局状态\14.3 同步物理时钟\14.3.2 同步时钟的Cristian方法">
      <UniqueIdentifier>{d5228d7a-aabd-4739-b495-c31ad0d457e7}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第14章 时间和全局状态\14.3 同步物理时钟\14.3.3 Berkeley算法">
      <UniqueIdentifier>{915ed6e2-ce72-441b-be9c-86d4b61bbdb1}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第14章 时间和全局状态\14.3 同步物理时钟\14.3.4 网络时间协议">
      <UniqueIdentifier>{dce65cc5-0814-48ea-bc60-adcd7385b74a}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第14章 时间和全局状态\14.4 逻辑时间和逻辑时钟">
      <UniqueIdentifier>{a8e015c9-0d9c-44e8-9068-4fba1eaedc06}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第14章 时间和全局状态\14.5 全局状态">
      <UniqueIdentifier>{babaae0a-7400-456e-9993-615415c18124}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第14章 时间和全局状态\14.5 全局状态\14.5.1 全局状态和一致割集">
      <UniqueIdentifier>{974e7f9a-9eae-4ca7-aac7-af35b833aa3e}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第14章 时间和全局状态\14.5 全局状态\14.5.2 全局状态谓词、稳定性、安全性和活性">
      <UniqueIdentifier>{2abd5487-2b7b-44d8-8cd1-1353f95b47d9}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第14章 时间和全局状态\14.5 全局状态\14.5.3 Chandy和Lamport的“快照”算法">
      <UniqueIdentifier>{4893a973-7c5d-41c8-b3cb-debbb4ad8ddd}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第14章 时间和全局状态\14.6 分布式调试">
      <UniqueIdentifier>{ecb3141a-aa24-47ad-b36f-bfa832b984eb}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第14章 时间和全局状态\14.6 分布式调试\14.6.1 收集状态">
      <UniqueIdentifier>{c77b3507-0cb6-438b-8734-dbdfe3a9caf9}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第14章 时间和全局状态\14.6 分布式调试\14.6.2 观察一致的全局状态">
      <UniqueIdentifier>{bb11c07a-655d-4d77-b19e-4a58f859c2f3}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第14章 时间和全局状态\14.6 分布式调试\14.6.3 判定可能的">
      <UniqueIdentifier>{b67bdaff-1b83-4fef-a843-fc99d7edd8de}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第14章 时间和全局状态\14.6 分布式调试\14.6.4 判定明确的">
      <UniqueIdentifier>{04892ca5-56f2-4dfc-b43e-74952dc67e09}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第14章 时间和全局状态\14.6 分布式调试\14.6.5 在同步系统中判定可能的和明确的">
      <UniqueIdentifier>{dccd5a4f-d77b-48be-b0dc-860de461bdc0}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第14章 时间和全局状态\14.7 小结">
      <UniqueIdentifier>{1328a91f-0415-4221-a87b-c47ea0a07a9c}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第15章 协调和协定">
      <UniqueIdentifier>{3357631e-0555-4115-a599-414e05815351}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第15章 协调和协定\15.1 简介">
      <UniqueIdentifier>{0222f8cf-8ff0-44d8-9817-96bdeae55a15}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第15章 协调和协定\15.2 分布式互斥">
      <UniqueIdentifier>{b39ab95a-7447-4111-9f1f-5c7356b70128}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第15章 协调和协定\15.3 选举">
      <UniqueIdentifier>{2c713860-956c-4a8c-84bd-56ae044551c5}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第15章 协调和协定\15.4 组通信中的协调与协定">
      <UniqueIdentifier>{0a824d37-e746-4061-a558-c01c6a491df6}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第15章 协调和协定\15.4 组通信中的协调与协定\15.4.1 基本组播">
      <UniqueIdentifier>{f037f9ae-cea3-4f9e-8156-42f8f7d86824}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第15章 协调和协定\15.4 组通信中的协调与协定\15.4.2 可靠组播">
      <UniqueIdentifier>{be000497-37e9-4aee-9130-b137b0b7f05e}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第15章 协调和协定\15.4 组通信中的协调与协定\15.4.3 有序组播">
      <UniqueIdentifier>{cd0ee79e-f0cf-4bec-8bc2-403b98bca955}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第15章 协调和协定\15.5 共识和相关问题">
      <UniqueIdentifier>{3d4f50dd-37eb-42d6-9285-6971b83d8a1b}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第15章 协调和协定\15.5 共识和相关问题\15.5.1 系统模型和问题定义">
      <UniqueIdentifier>{bc63f3d4-e33f-467a-a6c6-343d73143620}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第15章 协调和协定\15.5 共识和相关问题\15.5.2 同步系统中的共识问题">
      <UniqueIdentifier>{6f1cc30b-adf0-437d-ae29-871d7e88eb54}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第15章 协调和协定\15.5 共识和相关问题\15.5.3 同步系统中的拜占庭将军问题">
      <UniqueIdentifier>{67f80303-7c0c-4e08-a9f9-cfcba4d2adb8}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第15章 协调和协定\15.5 共识和相关问题\15.5.4 异步系统的不可能性">
      <UniqueIdentifier>{310aad61-07a9-4b68-928b-5f9a1839d0aa}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第15章 协调和协定\15.6 小结">
      <UniqueIdentifier>{61c9521c-f411-4007-ac3d-1d8b8f9ea2e8}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第16章 事务和并发控制">
      <UniqueIdentifier>{a0e2a54d-f9a9-44c3-a73f-9d2ffd3e576b}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第16章 事务和并发控制\16.1 简介">
      <UniqueIdentifier>{ce9a6f89-fc43-416c-8910-0ed52d9db00e}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第16章 事务和并发控制\16.1 简介\16.1.1 简单的同步机制（无事务）">
      <UniqueIdentifier>{2b61295e-8e83-49a9-9dad-658f3acb529e}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第16章 事务和并发控制\16.1 简介\16.1.2 事务的故障模型">
      <UniqueIdentifier>{78f36ea7-716a-45ee-9471-28aa3a893fe8}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第16章 事务和并发控制\16.2 事务">
      <UniqueIdentifier>{00de925d-856c-40f8-a33d-04ab5062c640}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第16章 事务和并发控制\16.2 事务\16.2.1 并发控制">
      <UniqueIdentifier>{fb893ba8-b643-4d6d-af87-bc08855a6435}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第16章 事务和并发控制\16.2 事务\16.2.2 事务放弃时的恢复">
      <UniqueIdentifier>{b03d7345-8285-4af7-97c9-8881dff68f91}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第16章 事务和并发控制\16.3 嵌套事务">
      <UniqueIdentifier>{a0c2d4da-bb1b-4933-98bb-502620204f54}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第16章 事务和并发控制\16.4 锁">
      <UniqueIdentifier>{09606c63-7829-45d2-98ff-807d6443a95d}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第16章 事务和并发控制\16.4 锁\16.4.1 死锁">
      <UniqueIdentifier>{faa34c2c-edf2-4f96-a01b-77e95f8ca00c}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第16章 事务和并发控制\16.4 锁\16.4.2 在加锁机制中增加并发度">
      <UniqueIdentifier>{b39daf11-27d1-4c4d-81e7-f524353772d5}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第16章 事务和并发控制\16.5 乐观并发控制">
      <UniqueIdentifier>{1b2ae800-b908-478b-98a8-7a8fe254c66e}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第16章 事务和并发控制\16.6 时间戳排序">
      <UniqueIdentifier>{79506cf3-5b49-45a6-a7b6-26a84aa9f7a3}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第16章 事务和并发控制\16.7 并发控制方法的比较">
      <UniqueIdentifier>{f76e16cd-6393-4c63-abba-334ffe1d240a}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第16章 事务和并发控制\16.8 小结">
      <UniqueIdentifier>{2fe94ed7-dd07-4e44-8bdc-55cf36727247}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第17章 分布式事务">
      <UniqueIdentifier>{11cf6aaa-aa3c-42e7-9192-2dd4773fe77c}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第17章 分布式事务\17.1 简介">
      <UniqueIdentifier>{f96ad0e0-6df3-4a38-8238-f5c271581b85}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第17章 分布式事务\17.2 平面分布式事务和嵌套分布式事务">
      <UniqueIdentifier>{a662de17-2d3e-4c67-b5fa-8c7db90362a2}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第17章 分布式事务\17.3 原子提交协议">
      <UniqueIdentifier>{be8389b3-2e97-49e7-a8e4-794b616d15be}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第17章 分布式事务\17.3 原子提交协议\17.3.1 两阶段提交协议">
      <UniqueIdentifier>{c5db7b8c-b502-42f2-960e-66afb59bd3bb}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第17章 分布式事务\17.3 原子提交协议\17.3.2 嵌套事务的两阶段提交协议">
      <UniqueIdentifier>{67526199-8614-406c-b9d6-cf23006e2aa5}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第17章 分布式事务\17.4 分布式事务的并发控制">
      <UniqueIdentifier>{3f370a2e-6a47-47da-8923-9335d809a82d}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第17章 分布式事务\17.4 分布式事务的并发控制\17.4.1 加锁">
      <UniqueIdentifier>{e482dba8-b2f8-4440-94b5-95124c984c7c}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第17章 分布式事务\17.4 分布式事务的并发控制\17.4.2 时间戳并发控制">
      <UniqueIdentifier>{c75a3dc1-39e7-4469-a764-a3798e94b711}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第17章 分布式事务\17.4 分布式事务的并发控制\17.4.3 乐观并发控制">
      <UniqueIdentifier>{33acf4fa-cc66-4d13-ad16-2ad5c7945290}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第17章 分布式事务\17.5 分布式死锁">
      <UniqueIdentifier>{2ee8e6a3-2408-4d90-adb4-956d44e25eb3}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第17章 分布式事务\17.6 事务恢复">
      <UniqueIdentifier>{eeb11d45-9813-4104-ad7b-186b7428137e}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第17章 分布式事务\17.6 事务恢复\17.6.1 日志">
      <UniqueIdentifier>{6ce6d9c1-1c3c-470c-b0d9-453be89faaaa}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第17章 分布式事务\17.6 事务恢复\17.6.2 影子版本">
      <UniqueIdentifier>{921e1cc4-02b1-4eb1-adcd-1280277c54a8}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第17章 分布式事务\17.6 事务恢复\17.6.3 为何恢复文件需要事务状态和意图列表">
      <UniqueIdentifier>{6d878831-e4b5-48b6-8876-35309517fb31}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第17章 分布式事务\17.6 事务恢复\17.6.4 两阶段提交协议的恢复">
      <UniqueIdentifier>{d8bf643d-f4b3-4354-a9ec-0043f9397184}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第17章 分布式事务\17.7 小结">
      <UniqueIdentifier>{86b9eab6-a2d0-42d1-9078-8cb2c8aa5699}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第18章 复制">
      <UniqueIdentifier>{9c6880d8-4b9f-415e-b3f4-7154a9c9e1b6}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第18章 复制\18.1 简介">
      <UniqueIdentifier>{532088f3-1ad8-4778-9dba-42aad70798b1}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第18章 复制\18.2 系统模型和组通信的作用">
      <UniqueIdentifier>{66d2a954-39f4-42e7-9dfe-f90afcdba9a8}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第18章 复制\18.2 系统模型和组通信的作用\18.2.1 系统模型">
      <UniqueIdentifier>{756863f5-67d4-44c0-b032-01b3270982e0}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第18章 复制\18.2 系统模型和组通信的作用\18.2.2 组通信的作用">
      <UniqueIdentifier>{4a238e0f-e06d-4634-b4a6-5c611376ceec}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第18章 复制\18.3 容错服务">
      <UniqueIdentifier>{75e66e4e-dd1c-4206-a204-4a04b96f155e}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第18章 复制\18.3 容错服务\18.3.1 被动（主备份）复制">
      <UniqueIdentifier>{145ca48b-322b-4bdd-9c59-0357a32b11cf}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第18章 复制\18.3 容错服务\18.3.2 主动复制">
      <UniqueIdentifier>{e702fc70-d52d-4c7d-ac96-706d4dacd7f5}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第18章 复制\18.4 高可用服务的实例研究：闲聊体系结构、Bayou和Coda">
      <UniqueIdentifier>{47276ea0-bc08-4a62-8cbe-99434b35cccf}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第18章 复制\18.4 高可用服务的实例研究：闲聊体系结构、Bayou和Coda\18.4.1 闲聊体系结构">
      <UniqueIdentifier>{00f8cd5c-b77e-4d13-9d76-30dea26244fa}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第18章 复制\18.4 高可用服务的实例研究：闲聊体系结构、Bayou和Coda\18.4.2 Bayou系统和操作变换方法">
      <UniqueIdentifier>{ad807a52-3e22-43d4-a1db-19d5a1b605df}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第18章 复制\18.4 高可用服务的实例研究：闲聊体系结构、Bayou和Coda\18.4.3 Coda文件系统">
      <UniqueIdentifier>{62b225e8-6e33-4213-96a7-aa892a96eb46}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第18章 复制\18.5 复制数据上的事务">
      <UniqueIdentifier>{eb9f467a-7148-4d89-bbef-d4765b72a07b}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第18章 复制\18.5 复制数据上的事务\18.5.1 复制事务的体系结构">
      <UniqueIdentifier>{04a8b2d9-5058-45b3-b63b-e9d1a90cea53}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第18章 复制\18.5 复制数据上的事务\18.5.2 可用拷贝复制">
      <UniqueIdentifier>{e707a1ef-0f0c-40f2-8a0c-8a3f0f7a2f9f}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第18章 复制\18.5 复制数据上的事务\18.5.3 网络分区">
      <UniqueIdentifier>{06378157-6318-474d-a637-694d86d87e63}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第18章 复制\18.5 复制数据上的事务\18.5.4 带验证的可用拷贝">
      <UniqueIdentifier>{06eaa1c9-51b0-4a91-b533-009bea7e6918}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第18章 复制\18.5 复制数据上的事务\18.5.5 法定数共识方法">
      <UniqueIdentifier>{840746c3-01be-4963-86a4-ea9d76fb1884}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第18章 复制\18.5 复制数据上的事务\18.5.6 虚拟分区算法">
      <UniqueIdentifier>{83acc3e5-d184-4b96-8c83-c3cfd3e1ab8b}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第18章 复制\18.6 小结">
      <UniqueIdentifier>{e258fd70-b77d-4c8c-979a-7272ce1c0444}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第19章 移动和无处不在计算">
      <UniqueIdentifier>{b3bb976e-af61-4969-aeb8-8cb7b116914b}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第19章 移动和无处不在计算\19.1 简介">
      <UniqueIdentifier>{fe22451f-42e7-4012-98d0-a248f6278ad2}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第19章 移动和无处不在计算\19.2 关联">
      <UniqueIdentifier>{81919fb3-802d-4384-bede-ed21e37ce45c}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第19章 移动和无处不在计算\19.2 关联\19.2.1 发现服务">
      <UniqueIdentifier>{0c467c8c-387b-49e2-a3e4-058a0ce1b46f}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第19章 移动和无处不在计算\19.2 关联\19.2.2 物理关联">
      <UniqueIdentifier>{b00f6543-5c2e-4d41-8e7b-5910e8b630c3}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第19章 移动和无处不在计算\19.2 关联\19.2.3 小结和前景">
      <UniqueIdentifier>{75165ab0-696d-4170-9b57-59ceb0b0a04a}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第19章 移动和无处不在计算\19.3 互操作">
      <UniqueIdentifier>{db327918-149b-4724-b9d0-9c2c142aa378}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第19章 移动和无处不在计算\19.3 互操作\19.3.1 易变系统的面向数据编程">
      <UniqueIdentifier>{cf1f9eac-8978-4e2a-8bd4-575eadb55c2e}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第19章 移动和无处不在计算\19.3 互操作\19.3.2 间接关联和软状态">
      <UniqueIdentifier>{871765c4-e693-48e6-ba80-25108950fe0c}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第19章 移动和无处不在计算\19.3 互操作\19.3.3 小结和前景">
      <UniqueIdentifier>{4d754cf0-259b-4f47-a6fa-14855b4e8dea}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第19章 移动和无处不在计算\19.4 感知和上下文敏感">
      <UniqueIdentifier>{e4259bb8-b40d-4937-ba25-cf52ae7184a3}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第19章 移动和无处不在计算\19.4 感知和上下文敏感\19.4.1 传感器">
      <UniqueIdentifier>{5a793ab9-3f5c-4f0f-8135-c2273ae948d3}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第19章 移动和无处不在计算\19.4 感知和上下文敏感\19.4.2 感知体系结构">
      <UniqueIdentifier>{6770eded-08ba-467a-9464-9ec117bd196a}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第19章 移动和无处不在计算\19.4 感知和上下文敏感\19.4.3 位置感知">
      <UniqueIdentifier>{b94c0747-aa57-4231-b323-e5b8c6714f0e}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第19章 移动和无处不在计算\19.4 感知和上下文敏感\19.4.4 小结和前景">
      <UniqueIdentifier>{5c1cdd5a-aa4f-4013-b38c-d1155f6a5f3e}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第19章 移动和无处不在计算\19.5 安全性和私密性">
      <UniqueIdentifier>{e95b1231-64c2-4075-8ad4-1d3d1397aa8c}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第19章 移动和无处不在计算\19.5 安全性和私密性\19.5.1 背景">
      <UniqueIdentifier>{27567607-e741-4ad8-998c-73ae27788358}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第19章 移动和无处不在计算\19.5 安全性和私密性\19.5.2 一些解决办法">
      <UniqueIdentifier>{41d282e2-2bdd-4bd6-85c1-f9453ce5b6a2}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第19章 移动和无处不在计算\19.5 安全性和私密性\19.5.3 小结和前景">
      <UniqueIdentifier>{29fb0cc7-19aa-45df-b45b-e327fd5ff9e3}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第19章 移动和无处不在计算\19.6 自适应">
      <UniqueIdentifier>{04237ed1-5b99-4d21-bb56-41f9c3f67b7c}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第19章 移动和无处不在计算\19.6 自适应\19.6.1 内容的上下文敏感自适应">
      <UniqueIdentifier>{c80d0c79-0c2c-4f18-998c-6783693b4c63}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第19章 移动和无处不在计算\19.6 自适应\19.6.2 适应变化的系统资源">
      <UniqueIdentifier>{b9107515-650d-476d-aaea-99cfd82e595f}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第19章 移动和无处不在计算\19.6 自适应\19.6.3 小结和前景">
      <UniqueIdentifier>{c3caf810-39be-4314-a981-e0e09490b7c5}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第19章 移动和无处不在计算\19.7 实例研究：Cooltown">
      <UniqueIdentifier>{2dd1dfd7-a0d0-41c8-a2bc-1fb515ba4d55}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第19章 移动和无处不在计算\19.7 实例研究：Cooltown\19.7.1 Web存在">
      <UniqueIdentifier>{61485001-6c6c-49d2-adaf-04c25455d355}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第19章 移动和无处不在计算\19.7 实例研究：Cooltown\19.7.2 物理超链接">
      <UniqueIdentifier>{1f755346-956e-4aef-99b6-c23223e5aab7}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第19章 移动和无处不在计算\19.7 实例研究：Cooltown\19.7.3 互操作和eSquirt协议">
      <UniqueIdentifier>{404b8cd5-cd36-4975-9222-283859d6a7fa}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第19章 移动和无处不在计算\19.7 实例研究：Cooltown\19.7.4 小结和前景">
      <UniqueIdentifier>{dd6418ae-5783-48c7-865c-9899c8b02318}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第19章 移动和无处不在计算\19.8 小结">
      <UniqueIdentifier>{6d72a207-e898-434f-b95e-1d7eb1f3c54f}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第20章 分布式多媒体系统">
      <UniqueIdentifier>{749195d8-b722-4619-b396-eefb6b4aac88}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第20章 分布式多媒体系统\20.1 简介">
      <UniqueIdentifier>{9b2cf945-820e-459b-babf-84e701e11898}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第20章 分布式多媒体系统\20.2 多媒体数据的特征">
      <UniqueIdentifier>{534a71aa-cc38-4e29-ab65-96f6e959e530}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第20章 分布式多媒体系统\20.3 服务质量管理">
      <UniqueIdentifier>{2d6e7c8a-c3ee-4cb9-83bc-8a27df8c550f}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第20章 分布式多媒体系统\20.3 服务质量管理\20.3.1 服务质量协商">
      <UniqueIdentifier>{049c3161-8f79-4518-92bf-bf452d9257e8}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第20章 分布式多媒体系统\20.3 服务质量管理\20.3.2 许可控制">
      <UniqueIdentifier>{2d864714-df80-4bf8-aee2-71dff1555c18}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第20章 分布式多媒体系统\20.4 资源管理">
      <UniqueIdentifier>{388080d8-31fe-424d-ab8f-e455c2d29ab5}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第20章 分布式多媒体系统\20.5 流自适应">
      <UniqueIdentifier>{dc90867c-f955-476a-a8b9-ec9b0a2cce3c}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第20章 分布式多媒体系统\20.5 流自适应\20.5.1 调整">
      <UniqueIdentifier>{4e7b8f01-0820-4272-8aa0-93665fed9daf}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第20章 分布式多媒体系统\20.5 流自适应\20.5.2 过滤">
      <UniqueIdentifier>{6a488007-4671-4f3e-83dc-495f29ce8dcb}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第20章 分布式多媒体系统\20.6 实例研究：Tiger视频文件服务器、BitTorrent和端系统多播">
      <UniqueIdentifier>{40019cd1-6378-4735-ae3e-41ed85eb94fa}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第20章 分布式多媒体系统\20.6 实例研究：Tiger视频文件服务器、BitTorrent和端系统多播\20.6.1 Tiger视频文件服务器">
      <UniqueIdentifier>{d7927ef1-7a34-4456-8016-163b7f42f04b}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第20章 分布式多媒体系统\20.6 实例研究：Tiger视频文件服务器、BitTorrent和端系统多播\20.6.2 BitTorrent">
      <UniqueIdentifier>{218c862e-cc29-4b96-a3e2-7cedcb275858}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第20章 分布式多媒体系统\20.6 实例研究：Tiger视频文件服务器、BitTorrent和端系统多播\20.6.3 端系统多播">
      <UniqueIdentifier>{29aeb7da-d427-46b4-bb4a-8fd9bd5d0e92}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第20章 分布式多媒体系统\20.7 小结">
      <UniqueIdentifier>{ea2484bf-6930-4d8f-b1d7-1da397da16e6}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第21章 分布式系统设计：Google实例研究">
      <UniqueIdentifier>{52577c93-107d-4491-a272-449426f528a2}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第21章 分布式系统设计：Google实例研究\21.1 简介">
      <UniqueIdentifier>{82274604-5eba-4951-b811-ec9c62a2f10e}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第21章 分布式系统设计：Google实例研究\21.2 实例研究简介：Google">
      <UniqueIdentifier>{cecb5126-acfd-4f03-af9f-71a4e8c95163}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第21章 分布式系统设计：Google实例研究\21.3 总体结构和设计理念">
      <UniqueIdentifier>{611e6635-deaa-42c3-8077-40af36c82aaa}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第21章 分布式系统设计：Google实例研究\21.3 总体结构和设计理念\21.3.1 物理模型">
      <UniqueIdentifier>{28177566-b9b5-4d3a-8f33-bbf867ae78a0}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第21章 分布式系统设计：Google实例研究\21.3 总体结构和设计理念\21.3.2 总的系统体系结构">
      <UniqueIdentifier>{22bab24c-ae08-4a06-a0d4-46a9a057b4f7}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第21章 分布式系统设计：Google实例研究\21.4 底层通信范型">
      <UniqueIdentifier>{7455d0b4-33df-44fc-ada1-d97ead66648c}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第21章 分布式系统设计：Google实例研究\21.4 底层通信范型\21.4.1 远程调用">
      <UniqueIdentifier>{4c205f64-58e9-4f26-9eda-ae2c9e39c67a}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第21章 分布式系统设计：Google实例研究\21.4 底层通信范型\21.4.2 发布-订阅">
      <UniqueIdentifier>{76fab39c-1a83-46ef-a9c7-5c8dd91dc455}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第21章 分布式系统设计：Google实例研究\21.4 底层通信范型\21.4.3 通信的关键设计选择总结">
      <UniqueIdentifier>{fa78d8fe-7c2a-4b80-9846-3dd672e099d4}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第21章 分布式系统设计：Google实例研究\21.5 数据存储和协调服务">
      <UniqueIdentifier>{34be9609-7962-4795-bc86-f5854ee9feaa}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第21章 分布式系统设计：Google实例研究\21.5 数据存储和协调服务\21.5.1 Google文件系统">
      <UniqueIdentifier>{058e4060-852f-442c-b27d-1cbabd37c04f}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第21章 分布式系统设计：Google实例研究\21.5 数据存储和协调服务\21.5.2 Chubby">
      <UniqueIdentifier>{2dde26fc-7e7f-448e-9fee-0eca4c740339}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第21章 分布式系统设计：Google实例研究\21.5 数据存储和协调服务\21.5.3 Bigtable">
      <UniqueIdentifier>{eb20e843-2bbe-40ee-b223-f572c598edf6}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第21章 分布式系统设计：Google实例研究\21.5 数据存储和协调服务\21.5.4 关键设计选择总结">
      <UniqueIdentifier>{47577ed6-535c-499e-9dfe-3b74a4fc5e78}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第21章 分布式系统设计：Google实例研究\21.6 分布式计算服务">
      <UniqueIdentifier>{61c9f23d-6e2c-40ac-aa9d-00ced30018b2}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第21章 分布式系统设计：Google实例研究\21.6 分布式计算服务\21.6.1 MapReduce">
      <UniqueIdentifier>{7ebe2d7d-1a88-4fd9-a1ac-9da5d53772b9}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第21章 分布式系统设计：Google实例研究\21.6 分布式计算服务\21.6.2 Sawzall">
      <UniqueIdentifier>{e03d5548-2653-4474-b4d3-c3a0420c3ddc}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第21章 分布式系统设计：Google实例研究\21.6 分布式计算服务\21.6.3 关键设计选择总结">
      <UniqueIdentifier>{d65f115f-fe5a-4467-96b6-888d6280a98a}</UniqueIdentifier>
    </Filter>
    <Filter Include="Book\Distributed Systems（分布式系统：概念与设计）\第21章 分布式系统设计：Google实例研究\21.7 小结">
      <UniqueIdentifier>{7bf8206b-2930-4d04-8cc7-457c735fbb8e}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <Text Include="Resource\C++ Concurrency In Action.txt">
      <Filter>资源文件</Filter>
    </Text>
    <Text Include="Resource\C++ Multithreading Cookbook.txt">
      <Filter>资源文件</Filter>
    </Text>
    <Text Include="Resource\Concurrent Programming On Windows.txt">
      <Filter>资源文件</Filter>
    </Text>
    <Text Include="Resource\Multithreading Applications in Win32.txt">
      <Filter>资源文件</Filter>
    </Text>
    <Text Include="Resource\Object-Oriented Multithreading Using C++.txt">
      <Filter>资源文件</Filter>
    </Text>
    <Text Include="Resource\Parallel and Distributed Programming Using C++.txt">
      <Filter>资源文件</Filter>
    </Text>
    <Text Include="Resource\Professional Multicore Programming.txt">
      <Filter>资源文件</Filter>
    </Text>
    <Text Include="Resource\ReadMe.txt">
      <Filter>资源文件</Filter>
    </Text>
    <Text Include="Resource\Schedule.txt">
      <Filter>资源文件</Filter>
    </Text>
    <Text Include="Resource\Todo\Level 0.txt">
      <Filter>资源文件\Todo</Filter>
    </Text>
    <Text Include="Resource\Todo\Level 1.txt">
      <Filter>资源文件\Todo</Filter>
    </Text>
    <Text Include="Resource\Todo\Level 2.txt">
      <Filter>资源文件\Todo</Filter>
    </Text>
    <Text Include="Resource\Todo\Level 3.txt">
      <Filter>资源文件\Todo</Filter>
    </Text>
    <Text Include="Resource\Todo\Level 4.txt">
      <Filter>资源文件\Todo</Filter>
    </Text>
    <Text Include="Resource\Todo\Level 5.txt">
      <Filter>资源文件\Todo</Filter>
    </Text>
    <Text Include="Resource\Todo\Level 6.txt">
      <Filter>资源文件\Todo</Filter>
    </Text>
    <Text Include="Resource\Todo\Level 7.txt">
      <Filter>资源文件\Todo</Filter>
    </Text>
    <Text Include="Resource\Todo\Level 8.txt">
      <Filter>资源文件\Todo</Filter>
    </Text>
    <Text Include="Resource\Todo\Level 9.txt">
      <Filter>资源文件\Todo</Filter>
    </Text>
    <Text Include="Resource\Distributed Systems.txt">
      <Filter>资源文件</Filter>
    </Text>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\..\..\..\Code\Example\BookOperatingSystem\BookConcurrentProgramming\BookConcurrentProgramming.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\..\Code\Example\BookOperatingSystem\BookConcurrentProgramming\BookConcurrentProgrammingDll.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\..\Code\Example\BookOperatingSystem\BookConcurrentProgramming\BookConcurrentProgrammingExport.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\..\Code\Example\BookOperatingSystem\BookConcurrentProgramming\BookConcurrentProgrammingFwd.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\..\Code\Example\BookOperatingSystem\BookConcurrentProgramming\BookConcurrentProgrammingImport.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\..\Code\Example\BookOperatingSystem\BookConcurrentProgramming\BookConcurrentProgrammingLib.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\..\Code\Example\BookOperatingSystem\BookConcurrentProgramming\BookConcurrentProgrammingNoImport.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\..\Code\Example\BookOperatingSystem\BookConcurrentProgramming\DllLib.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\..\Code\Example\BookOperatingSystem\BookConcurrentProgramming\Placeholder\Placeholder.h">
      <Filter>Placeholder 头文件</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\..\Code\Example\BookOperatingSystem\BookConcurrentProgramming\Helper\BookConcurrentProgrammingClassInvariantMacro.h">
      <Filter>Helper 头文件</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\..\Code\Example\BookOperatingSystem\BookConcurrentProgramming\Helper\BookConcurrentProgrammingCustomAssertMacro.h">
      <Filter>Helper 头文件</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\..\Code\Example\BookOperatingSystem\BookConcurrentProgramming\Helper\Helper.h">
      <Filter>Helper 头文件</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\..\Code\Example\BookOperatingSystem\BookConcurrentProgramming\Helper\HelperFwd.h">
      <Filter>Helper 头文件</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\..\Code\Example\BookOperatingSystem\BookConcurrentProgramming\Helper\UserMacro.h">
      <Filter>Helper 头文件</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="..\..\..\..\Code\Example\BookOperatingSystem\BookConcurrentProgramming\DllLib.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
    <ClCompile Include="..\..\..\..\Code\Example\BookOperatingSystem\BookConcurrentProgramming\DllMain.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
    <ClCompile Include="..\..\..\..\Code\Example\BookOperatingSystem\BookConcurrentProgramming\Placeholder\Placeholder.cpp">
      <Filter>Placeholder 源文件</Filter>
    </ClCompile>
  </ItemGroup>
</Project>